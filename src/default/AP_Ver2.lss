
AP_Ver2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000040c6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000f8  00800060  000040c6  0000415a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000252  00800158  00800158  00004252  2**0
                  ALLOC
  3 .debug_aranges 000000e0  00000000  00000000  00004252  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000657  00000000  00000000  00004332  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00002299  00000000  00000000  00004989  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000009b6  00000000  00000000  00006c22  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00001a88  00000000  00000000  000075d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000310  00000000  00000000  00009060  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000097a  00000000  00000000  00009370  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000181a  00000000  00000000  00009cea  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000000c0  00000000  00000000  0000b504  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 29 0e 	jmp	0x1c52	; 0x1c52 <__ctors_end>
       4:	0c 94 46 0e 	jmp	0x1c8c	; 0x1c8c <__bad_interrupt>
       8:	0c 94 46 0e 	jmp	0x1c8c	; 0x1c8c <__bad_interrupt>
       c:	0c 94 46 0e 	jmp	0x1c8c	; 0x1c8c <__bad_interrupt>
      10:	0c 94 46 0e 	jmp	0x1c8c	; 0x1c8c <__bad_interrupt>
      14:	0c 94 46 0e 	jmp	0x1c8c	; 0x1c8c <__bad_interrupt>
      18:	0c 94 46 0e 	jmp	0x1c8c	; 0x1c8c <__bad_interrupt>
      1c:	0c 94 46 0e 	jmp	0x1c8c	; 0x1c8c <__bad_interrupt>
      20:	0c 94 46 0e 	jmp	0x1c8c	; 0x1c8c <__bad_interrupt>
      24:	0c 94 46 0e 	jmp	0x1c8c	; 0x1c8c <__bad_interrupt>
      28:	0c 94 46 0e 	jmp	0x1c8c	; 0x1c8c <__bad_interrupt>
      2c:	0c 94 46 0e 	jmp	0x1c8c	; 0x1c8c <__bad_interrupt>
      30:	0c 94 46 0e 	jmp	0x1c8c	; 0x1c8c <__bad_interrupt>
      34:	0c 94 46 0e 	jmp	0x1c8c	; 0x1c8c <__bad_interrupt>
      38:	0c 94 46 0e 	jmp	0x1c8c	; 0x1c8c <__bad_interrupt>
      3c:	0c 94 46 0e 	jmp	0x1c8c	; 0x1c8c <__bad_interrupt>
      40:	0c 94 46 0e 	jmp	0x1c8c	; 0x1c8c <__bad_interrupt>
      44:	0c 94 46 0e 	jmp	0x1c8c	; 0x1c8c <__bad_interrupt>
      48:	0c 94 46 0e 	jmp	0x1c8c	; 0x1c8c <__bad_interrupt>
      4c:	0c 94 46 0e 	jmp	0x1c8c	; 0x1c8c <__bad_interrupt>
      50:	0c 94 46 0e 	jmp	0x1c8c	; 0x1c8c <__bad_interrupt>

00000054 <__c.2067>:
      54:	20 46 72 65 65 20 4d 65 6d 6f 72 79 3a 20 00         Free Memory: .

00000063 <__c.2060>:
      63:	54 6f 74 61 6c 20 4d 65 6d 6f 72 79 3a 20 00        Total Memory: .

00000072 <__c.1957>:
      72:	45 72 72 6f 72 20 69 6e 20 67 65 74 74 69 6e 67     Error in getting
      82:	20 63 6c 75 73 74 65 72 00                           cluster.

0000008b <__c.1955>:
      8b:	45 6e 64 20 6f 66 20 43 6c 75 73 74 65 72 20 43     End of Cluster C
      9b:	68 61 69 6e 00                                      hain.

000000a0 <__c.1947>:
      a0:	20 46 69 6c 65 20 43 72 65 61 74 65 64 21 00         File Created!.

000000af <__c.1942>:
      af:	20 46 69 6c 65 20 61 70 70 65 6e 64 65 64 21 00      File appended!.

000000bf <__c.1939>:
      bf:	20 4e 6f 20 66 72 65 65 20 63 6c 75 73 74 65 72      No free cluster
      cf:	21 00                                               !.

000000d1 <__c.1930>:
      d1:	20 45 6e 74 65 72 20 74 65 78 74 20 28 65 6e 64      Enter text (end
      e1:	20 77 69 74 68 20 7e 29 3a 00                        with ~):.

000000eb <__c.1928>:
      eb:	20 4e 6f 20 66 72 65 65 20 63 6c 75 73 74 65 72      No free cluster
      fb:	21 00                                               !.

000000fd <__c.1926>:
      fd:	20 43 72 65 61 74 69 6e 67 20 46 69 6c 65 2e 2e      Creating File..
	...

0000010e <__c.1922>:
     10e:	20 20 46 69 6c 65 20 61 6c 72 65 61 64 79 20 65       File already e
     11e:	78 69 73 74 69 6e 67 2c 20 61 70 70 65 6e 64 69     xisting, appendi
     12e:	6e 67 20 64 61 74 61 2e 2e 00                       ng data...

00000138 <__c.1869>:
     138:	49 6e 76 61 6c 69 64 20 66 69 6c 65 4e 61 6d 65     Invalid fileName
     148:	2e 2e 00                                            ...

0000014b <__c.1840>:
     14b:	45 72 72 6f 72 20 69 6e 20 67 65 74 74 69 6e 67     Error in getting
     15b:	20 63 6c 75 73 74 65 72 00                           cluster.

00000164 <__c.1790>:
     164:	45 72 72 6f 72 20 69 6e 20 67 65 74 74 69 6e 67     Error in getting
     174:	20 63 6c 75 73 74 65 72 00                           cluster.

0000017d <__c.1782>:
     17d:	52 4f 4f 54 00                                      ROOT.

00000182 <__c.1780>:
     182:	44 49 52 00                                         DIR.

00000186 <__c.1778>:
     186:	20 20 20 00                                            .

0000018a <__c.1776>:
     18a:	46 49 4c 45 00                                      FILE.

0000018f <__c.1774>:
     18f:	20 20 20 00                                            .

00000193 <__c.1768>:
     193:	46 69 6c 65 20 64 65 6c 65 74 65 64 21 00           File deleted!.

000001a1 <__c.1766>:
     1a1:	44 65 6c 65 74 69 6e 67 2e 2e 00                    Deleting...

000001ac <__c.1761>:
     1ac:	46 69 6c 65 20 64 6f 65 73 20 6e 6f 74 20 65 78     File does not ex
     1bc:	69 73 74 21 00                                      ist!.

000001c1 <pcm_samples>:
     1c1:	74 61 90 1a 00 00 80 80 80 80 80 80 80 80 80 80     ta..............
     1d1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     1e1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     1f1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     201:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     211:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     221:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     231:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     241:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     251:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     261:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     271:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     281:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     291:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     2a1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     2b1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     2c1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     2d1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     2e1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     2f1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     301:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     311:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     321:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     331:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     341:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     351:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     361:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     371:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     381:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     391:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     3a1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     3b1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     3c1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     3d1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     3e1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     3f1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     401:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     411:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     421:	80 80 80 80 80 80 80 80 7f 80 80 7f 80 7f 7f 80     ................
     431:	7f 7f 80 7f 80 80 7f 80 7f 7f 7f 7f 7f 7f 7f 7f     ................
     441:	7f 7f 7f 7f 7f 80 7f 7f 80 7f 80 7f 7f 80 7f 80     ................
     451:	80 80 80 80 80 82 81 80 84 81 7f 85 7f 80 83 7f     ................
     461:	80 83 81 7f 84 82 80 84 81 82 83 89 8a 82 8c 87     ................
     471:	80 89 82 7e 82 7c 7d 7e 79 7c 7a 77 79 78 75 76     ...~.|}~y|zwyxuv
     481:	79 76 78 7b 7e 83 86 8d 90 92 95 94 94 92 8e 8b     yvx{~...........
     491:	88 83 7f 7b 73 66 59 4a 3e 38 5e 60 54 95 92 89     ...{sfYJ>8^`T...
     4a1:	b7 ac 99 a6 91 7b 7f 6c 65 6c 6b 73 79 87 96 9a     .....{.lelksy...
     4b1:	a7 ad a6 a9 9e 8e 87 7b 74 70 73 78 7b 87 8e 90     .......{tpsx{...
     4c1:	96 94 8d 88 7d 71 68 5c 57 52 50 59 5e 68 78 7e     ....}qh\WRPY^hx~
     4d1:	8a 9a 9f 9d a1 a0 91 8f 8b 81 80 82 80 85 8d 8c     ................
     4e1:	93 97 94 8e 89 73 54 56 32 21 42 45 44 6a 8e 8a     .....sTV2!BEDj..
     4f1:	ab bf b1 b5 ad 96 8c 87 74 70 77 73 76 85 8d 93     ........tpwsv...
     501:	a1 a8 a6 a4 a3 98 89 85 7b 70 6e 6a 5c 56 5c 4a     ........{pnj\V\J
     511:	43 52 5d 6b 6f 89 97 8e 9f a0 97 97 8f 88 88 7f     CR]ko...........
     521:	7e 83 7f 86 8b 8d 98 9d a3 a8 a5 a1 98 8c 7b 6b     ~.............{k
     531:	55 49 44 2a 28 39 4a 5d 6e 93 9f a6 b6 b4 ab a4     UID*(9J]n.......
     541:	96 86 82 74 70 76 76 7d 87 92 9f aa b2 b5 b1 aa     ...tpvv}........
     551:	9b 89 76 63 4e 44 3e 2b 25 2d 3d 5b 6b 81 a2 a7     ..vcND>+%-=[k...
     561:	ad ba b0 a6 9e 8d 83 78 70 70 72 79 83 8c 9c a9     .......xppry....
     571:	b2 bc b8 b4 aa 96 85 71 5b 4b 45 38 28 27 2d 3e     .......q[KE8('->
     581:	5e 6c 7f a4 a5 ab bb ae a7 9d 8c 84 76 6f 73 73     ^l..........voss
     591:	7c 88 92 a2 b1 ba be bc b4 a6 91 7d 68 51 48 3d     |..........}hQH=
     5a1:	28 22 21 2a 49 5a 6b 8f 9c a5 b6 b6 b2 aa 9c 92     ("!*IZk.........
     5b1:	84 77 75 73 77 7e 86 95 a2 ae b7 b9 b8 af a1 90     .wusw~..........
     5c1:	7b 67 54 4a 3e 2c 25 29 36 4d 58 71 93 8d 9f b5     {gTJ>,%)6MXq....
     5d1:	a9 ad ab a0 99 88 83 83 79 7d 84 85 8f 98 a3 a8     ........y}......
     5e1:	a6 ab a5 95 8b 7d 6c 5d 5a 57 4c 49 4a 52 5a 5b     .....}l]ZWLIJRZ[
     5f1:	66 72 75 79 85 8c 90 95 98 99 94 90 90 8e 8c 8b     fruy............
     601:	8e 90 8f 92 93 90 8d 8c 87 82 7f 7d 7b 78 79 7b     ...........}{xy{
     611:	79 76 74 73 73 72 70 70 6f 6e 6f 70 72 75 78 7c     yvtssrpponoprux|
     621:	80 82 85 87 88 89 8b 8d 8f 90 8f 8f 8e 8c 8b 8a     ................
     631:	88 87 86 85 84 84 83 83 82 81 80 7f 7e 7d 7b 7a     ............~}{z
     641:	78 75 73 72 70 6f 6f 70 72 73 75 78 7a 7c 7e 81     xusrpooprsuxz|~.
     651:	83 85 87 88 8a 8b 8b 8b 8b 8a 8a 89 88 87 86 85     ................
     661:	84 84 83 82 81 80 80 7f 7f 7e 7d 7d 7c 7b 7b 7a     .........~}}|{{z
     671:	7a 7a 7a 7a 7a 7a 7b 7c 7c 7d 7e 7f 80 80 81 82     zzzzzz{||}~.....
     681:	82 82 83 83 83 83 83 82 82 82 82 81 81 81 81 81     ................
     691:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     6a1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     6b1:	81 81 81 81 81 81 81 81 80 80 80 80 80 80 80 80     ................
     6c1:	80 80 80 80 80 7f 7f 7f 7f 7f 7f 7f 7f 7f 7f 7f     ................
     6d1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 81     ................
     6e1:	81 81 81 81 81 81 80 80 80 80 80 80 80 80 80 80     ................
     6f1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     701:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     711:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     721:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     731:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     741:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     751:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     761:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     771:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     781:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     791:	80 80 80 80 80 80 80 80 81 80 7f 81 82 80 7f 80     ................
     7a1:	80 7f 7f 80 80 7f 80 80 80 80 80 80 80 80 80 80     ................
     7b1:	80 80 7f 80 80 80 80 80 7f 80 80 80 80 80 80 80     ................
     7c1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     7d1:	7f 80 80 80 80 80 80 80 80 80 80 81 80 80 80 80     ................
     7e1:	80 80 81 81 7f 80 80 7f 80 80 80 80 80 80 80 80     ................
     7f1:	80 80 80 80 80 7f 80 80 80 80 80 81 80 7f 80 80     ................
     801:	7f 81 80 81 81 80 80 7f 81 7f 80 7f 7f 80 80 81     ................
     811:	80 81 80 80 80 80 80 7f 80 80 80 80 80 82 80 81     ................
     821:	7f 80 80 7f 7f 80 81 7f 81 80 81 80 7f 80 80 7e     ...............~
     831:	82 81 7f 7f 80 80 80 7e 81 81 80 80 81 81 80 7f     .......~........
     841:	80 81 80 7e 80 80 81 7f 82 80 81 7d 81 7f 7f 81     ...~.......}....
     851:	7e 83 7d 83 80 82 7e 82 7e 7f 80 81 81 81 7e 80     ~.}...~.~.....~.
     861:	82 7d 81 7f 81 7e 80 7c 81 81 82 83 7d 7e 80 81     .}...~.|....}~..
     871:	7e 82 7f 82 81 7e 82 7f 7d 7d 82 80 7f 81 7f 83     ~....~..}}......
     881:	7d 7f 81 80 80 7f 80 7f 82 7e 7e 7d 7f 81 81 82     }........~~}....
     891:	80 82 7e 82 80 83 82 80 80 7d 81 7e 82 7f 82 82     ..~......}.~....
     8a1:	7f 80 80 82 7f 82 7e 82 82 7d 80 80 82 81 80 7d     ......~..}.....}
     8b1:	7f 82 7d 81 7f 81 84 80 7f 7e 82 7e 80 81 7f 82     ..}......~.~....
     8c1:	7f 80 7f 80 7e 7f 83 7e 81 7e 7c 83 80 7f 80 81     ....~..~.~|.....
     8d1:	7f 82 7f 7b 85 7f 81 84 7f 81 80 80 7c 81 7e 7f     ...{........|.~.
     8e1:	83 7b 81 83 82 82 80 81 81 81 79 80 82 7e 82 7e     .{........y..~.~
     8f1:	7f 84 82 7d 81 82 7d 81 7b 7c 84 80 7d 81 81 80     ...}..}.{|..}...
     901:	83 81 7c 81 81 7f 82 7f 80 84 81 7d 80 82 7f 7e     ..|........}...~
     911:	80 81 7f 7e 7f 80 81 7e 7f 82 82 81 7e 81 82 7f     ...~...~....~...
     921:	80 7f 80 81 80 80 82 82 7f 80 80 80 81 7f 7e 80     ..............~.
     931:	82 7f 80 81 81 81 7f 80 80 7f 7f 7f 81 80 81 81     ................
     941:	81 80 7e 80 7f 7e 81 81 80 81 81 80 80 80 7f 80     ..~..~..........
     951:	7f 80 80 7f 7f 80 81 80 80 7f 80 81 80 80 7f 7f     ................
     961:	80 81 80 80 80 80 81 80 80 80 81 81 80 80 80 7f     ................
     971:	7f 80 80 80 81 80 7f 80 81 80 80 7f 7f 81 81 80     ................
     981:	7f 7f 80 81 81 80 80 81 81 80 80 81 7f 80 80 80     ................
     991:	80 80 80 80 80 80 80 7f 7f 7f 80 80 7f 80 80 80     ................
     9a1:	7f 7e 80 80 81 80 80 80 81 80 81 81 80 81 81 80     .~..............
     9b1:	80 80 81 81 80 80 80 81 80 80 7f 80 80 81 80 7f     ................
     9c1:	7f 7f 7f 80 80 80 80 80 7f 80 80 80 80 80 7f 7f     ................
     9d1:	80 81 80 80 80 80 80 80 81 80 80 80 80 80 80 80     ................
     9e1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     9f1:	80 80 80 80 7f 7f 80 80 80 80 80 80 80 81 80 80     ................
     a01:	80 80 81 80 80 80 80 80 80 80 81 80 80 80 80 80     ................
     a11:	7f 7f 7f 80 80 80 80 80 7f 7f 80 81 81 80 80 80     ................
     a21:	80 81 81 81 80 80 81 81 81 81 80 80 80 80 80 80     ................
     a31:	80 80 80 7f 80 80 7f 7f 7f 7f 7f 7f 7f 80 80 80     ................
     a41:	80 80 80 80 80 80 80 80 80 81 81 81 81 81 81 81     ................
     a51:	81 81 81 81 80 80 80 81 81 80 80 80 7f 7f 80 80     ................
     a61:	7f 7f 7f 7f 7f 7f 7f 7f 7f 7f 7f 7f 7f 80 80 80     ................
     a71:	81 81 81 81 81 80 81 81 81 82 81 80 80 81 81 81     ................
     a81:	81 81 80 80 80 80 80 80 7f 7f 7f 7f 7f 7f 7f 7f     ................
     a91:	7f 7f 7f 7e 7e 7f 7f 7f 7f 80 80 80 80 81 82 82     ...~~...........
     aa1:	82 82 82 82 82 82 82 82 82 81 81 81 81 81 81 80     ................
     ab1:	7f 7d 7d 7d 7d 7c 7c 7c 7c 7d 7d 7d 7d 7d 7e 7f     .}}}}||||}}}}}~.
     ac1:	80 81 81 82 82 83 84 84 84 84 84 85 85 85 85 84     ................
     ad1:	83 83 83 83 82 81 80 7e 7c 7c 7c 7b 7a 79 77 76     .......~|||{zywv
     ae1:	77 79 79 79 7a 7c 7e 81 84 85 86 86 87 87 89 8a     wyyyz|~.........
     af1:	8b 8b 8a 89 8a 8b 8b 8b 89 85 82 81 80 7f 7b 75     ..............{u
     b01:	6f 6b 68 65 62 5d 59 5c 69 7b 8a 91 92 8f 8c 8d     okheb]Y\i{......
     b11:	92 96 92 89 81 7d 7f 88 93 9a 9b 98 95 93 91 90     .....}..........
     b21:	8d 85 7b 73 6e 6b 69 66 5f 54 4b 4b 58 6f 84 92     ..{snkif_TKKXo..
     b31:	99 98 91 8c 8e 90 8d 88 83 7b 75 79 85 8f 97 9b     .........{uy....
     b41:	9a 94 90 90 91 90 8b 83 78 70 6f 73 77 77 71 63     ........xposwwqc
     b51:	55 4c 48 53 6d 87 94 98 95 91 8f 94 98 93 87 7b     ULHSm..........{
     b61:	73 73 7e 8d 96 96 93 91 91 95 9a 99 8e 81 78 73     ss~...........xs
     b71:	75 7a 7c 78 70 68 5e 58 54 50 55 69 81 90 97 98     uz|xph^XTPUi....
     b81:	95 91 91 92 8c 81 77 73 75 7f 8c 94 94 91 91 93     ......wsu.......
     b91:	95 96 92 88 7d 78 79 7b 7d 7e 7b 76 72 6e 67 5e     ....}xy{}~{vrng^
     ba1:	54 4a 51 6c 8a 99 9a 95 92 92 97 9a 8f 7c 6f 6f     TJQl.........|oo
     bb1:	79 87 93 95 8e 8a 90 99 9c 98 8d 7f 76 77 7e 81     y...........vw~.
     bc1:	7c 77 75 77 7a 79 6f 5e 52 48 4b 62 82 93 90 8b     |wuwzyo^RHKb....
     bd1:	8e 97 9c 9c 8f 7a 6b 6e 7d 88 8c 8b 8a 8b 94 9f     .....zkn}.......
     be1:	a0 94 87 80 7e 80 82 80 7a 76 7b 83 85 80 76 6b     ....~...zv{...vk
     bf1:	61 5b 52 4d 5a 77 8e 93 92 93 98 99 98 90 7e 6f     a[RMZw........~o
     c01:	6d 78 82 87 88 8a 8d 94 9b 9c 92 87 81 81 81 80     mx..............
     c11:	7c 78 76 7c 84 86 81 79 72 6b 64 5a 4c 49 61 84     |xv|...yrkdZLIa.
     c21:	96 93 8d 91 9a 9e 98 89 75 6a 71 80 88 86 85 8b     ........ujq.....
     c31:	94 9c 9f 97 8a 82 83 86 81 79 75 76 7c 84 88 85     .........yuv|...
     c41:	7d 78 76 72 66 59 4b 43 54 78 96 95 89 8a 9b a4     }xvrfYKCTx......
     c51:	9c 89 74 6a 6d 7c 85 83 80 89 98 a1 9e 95 8d 87     ..tjm|..........
     c61:	86 87 82 78 73 79 83 87 86 84 84 83 82 7c 70 62     ...xsy.......|pb
     c71:	57 53 4d 52 6a 8b 98 92 8f 99 a2 9a 89 78 6e 6d     WSMRj........xnm
     c81:	74 7f 83 83 89 96 9f 9d 95 8e 89 85 80 7d 79 76     t............}yv
     c91:	79 80 86 86 85 85 86 82 7b 73 6a 62 5b 55 4d 50     y.......{sjb[UMP
     ca1:	6a 8e 9e 95 8c 94 a1 9d 89 75 6c 6e 77 82 86 85     j........ulnw...
     cb1:	8a 99 a4 a0 91 88 88 88 82 7b 78 79 7e 85 89 88     .........{xy~...
     cc1:	84 84 86 84 7b 71 6a 66 63 5e 56 4e 56 76 98 9f     ....{qjfc^VNVv..
     cd1:	8e 86 92 a0 96 7d 6c 6b 73 7c 83 86 88 90 9c a2     .....}lks|......
     ce1:	99 8a 84 87 87 80 78 78 7e 85 89 89 88 86 88 88     ......xx~.......
     cf1:	83 79 70 6e 6d 6a 63 5d 57 57 6b 8b 9e 94 85 89     .ypnmjc]WWk.....
     d01:	99 9c 85 6f 6c 76 7d 7e 82 88 8f 96 9b 98 8c 83     ...olv}~........
     d11:	84 87 83 79 76 7e 86 88 85 85 88 88 85 80 7a 74     ...yv~........zt
     d21:	70 70 6d 69 64 61 5c 5a 6d 8c 9f 93 84 88 9a 9c     ppmida\Zm.......
     d31:	85 70 6f 7a 81 82 83 88 90 97 9a 94 89 83 86 88     .poz............
     d41:	82 79 7a 83 89 86 83 84 88 87 82 7c 78 75 72 6f     .yz........|xuro
     d51:	6a 68 65 62 59 58 6f 92 9f 8d 7f 8b 9f 9b 7e 6c     jhebYXo.......~l
     d61:	71 7f 83 7f 80 8a 93 99 98 91 88 86 8a 89 80 77     q..............w
     d71:	7c 86 8b 86 84 87 8b 89 81 7b 78 76 74 70 6b 66     |........{xvtpkf
     d81:	64 62 5b 5a 71 92 9c 8a 7f 8d 9f 97 7b 6c 74 80     db[Zq.......{lt.
     d91:	80 7d 7f 88 92 97 95 8d 85 86 8b 87 7d 78 80 88     .}..........}x..
     da1:	88 82 82 88 8a 86 80 7c 79 76 72 6e 6a 67 64 5f     .......|yvrnjgd_
     db1:	57 5e 7b 97 97 85 83 97 a2 90 77 71 7c 83 7f 7c     W^{.......wq|..|
     dc1:	81 8b 94 96 92 8b 89 8d 8c 83 7b 7d 84 85 81 80     ..........{}....
     dd1:	85 89 88 84 81 7d 79 75 70 6b 67 64 60 57 54 68     .....}yupkgd`WTh
     de1:	88 97 8a 81 8f a3 9c 82 75 7b 83 80 79 7a 83 8e     ........u{..yz..
     df1:	95 93 8c 8b 92 93 8a 7e 7e 84 86 81 7e 81 86 89     .......~~...~...
     e01:	87 83 7e 7d 7b 76 6d 68 67 64 5b 53 5d 7a 90 8b     ..~}{vmhgd[S]z..
     e11:	80 89 9d a0 8d 7d 7c 83 82 7b 76 7a 86 8f 8f 8a     .....}|..{vz....
     e21:	8a 92 95 8e 83 81 85 85 80 7d 7e 83 86 85 82 7f     .........}~.....
     e31:	7f 7f 7b 73 6d 6c 69 62 59 5a 6d 83 86 7f 82 93     ..{smlibYZm.....
     e41:	9e 95 87 83 87 88 82 7a 78 80 89 8a 86 86 8e 93     .......zx.......
     e51:	90 89 86 87 86 83 7f 7d 7e 81 83 81 7e 7f 81 7e     .......}~...~..~
     e61:	78 74 73 71 6c 67 63 67 73 7d 7d 7b 82 8e 92 8c     xtsqlgcgs}}{....
     e71:	88 89 8c 89 82 7e 7f 82 84 83 81 84 89 8b 89 86     .....~..........
     e81:	87 87 86 82 80 7f 7f 80 80 7e 7e 7f 80 7e 7c 7c     .........~~..~||
     e91:	7c 7b 79 78 78 78 78 79 7a 7c 7d 7e 7e 80 81 81     |{yxxxxyz|}~~...
     ea1:	81 81 82 82 81 81 81 81 81 81 81 81 82 82 82 82     ................
     eb1:	82 82 82 82 82 82 82 82 81 81 80 80 80 7f 7f 7f     ................
     ec1:	7f 7f 7f 7f 7f 7f 7f 7f 7f 80 80 80 80 80 80 80     ................
     ed1:	81 81 81 81 81 81 81 81 81 81 81 81 81 81 81 81     ................
     ee1:	81 81 80 80 80 80 80 80 80 7f 7f 7f 7f 7f 7f 7f     ................
     ef1:	7f 7f 7f 7f 7f 7f 7f 7f 7f 80 80 80 80 80 80 80     ................
     f01:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     f11:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     f21:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     f31:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     f41:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     f51:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     f61:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     f71:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     f81:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     f91:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     fa1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     fb1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     fc1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     fd1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     fe1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
     ff1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1001:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 83 84     ................
    1011:	81 7e 7e 7f 7f 7f 7f 7f 80 80 81 81 81 80 81 81     .~~.............
    1021:	81 8c 7c 72 85 83 77 80 85 7c 7b 7f 8f 82 75 8f     ..|r..w..|{...u.
    1031:	85 74 84 86 76 7c 83 7f 82 7f 7d 82 83 7e 80 83     .t..v|....}..~..
    1041:	7d 7e 82 7e 7d 81 80 7d 81 80 7e 80 80 7f 7f 81     }~.~}..}..~.....
    1051:	81 81 7f 7f 80 82 84 7f 7f 81 7e 7f 82 7f 7e 81     ..........~...~.
    1061:	80 7f 81 81 7f 81 80 83 87 80 80 82 7f 7e 7f 7e     .............~.~
    1071:	7d 7f 7f 7f 80 80 80 81 81 7f 80 80 7f 7f 7e 7f     }.............~.
    1081:	7f 7f 80 7f 80 80 81 81 81 81 81 81 81 82 81 82     ................
    1091:	82 81 81 81 81 81 81 81 81 80 80 80 7f 7f 7f 7e     ...............~
    10a1:	7e 7e 7d 7e 7d 7c 7d 7b 7b 7d 7b 7c 7e 7c 7f 80     ~~}~}|}{{}{|~|..
    10b1:	80 82 82 83 85 84 85 86 85 86 86 85 86 86 85 86     ................
    10c1:	85 85 85 83 83 83 80 81 7f 7d 7d 7a 79 78 75 75     .........}}zyxuu
    10d1:	73 70 71 70 6f 72 71 74 79 79 7f 84 86 8c 8e 8f     spqporqtyy......
    10e1:	93 92 92 92 90 8f 8e 8b 8c 8b 8a 8b 8b 8a 8b 88     ................
    10f1:	87 85 81 7d 78 72 6c 66 5f 5b 55 54 57 58 62 69     ...}xrlf_[UTWXbi
    1101:	70 7f 85 8e 99 98 9d 9d 97 97 90 8b 89 84 83 85     p...............
    1111:	86 8b 91 93 98 9a 99 99 94 8f 8a 83 7d 77 73 6f     ............}wso
    1121:	6c 6c 6a 68 67 61 5e 5d 5d 5e 63 69 6d 78 7f 87     lljhga^]]^cimx..
    1131:	93 96 9a 9e 99 98 95 8d 8b 86 81 83 83 84 8a 8c     ................
    1141:	90 94 94 94 94 8f 8b 89 81 7f 7c 77 77 74 72 73     ..........|wwtrs
    1151:	71 6f 6c 66 61 5e 5c 5b 60 65 6c 76 7e 88 92 96     qolfa^\[`elv~...
    1161:	9c 9c 9a 98 92 8d 88 83 81 80 82 85 89 8e 92 95     ................
    1171:	98 96 96 92 8d 8a 83 7f 7c 76 76 73 71 73 71 6f     ........|vvsqsqo
    1181:	6d 67 62 5f 5b 5b 5e 61 6a 71 7b 85 8d 95 99 9b     mgb_[[^ajq{.....
    1191:	9b 97 95 8f 8b 88 84 84 85 87 8c 8f 93 96 97 97     ................
    11a1:	95 92 8d 88 83 7e 7a 76 73 71 70 6f 6e 6d 6a 66     .....~zvsqponmjf
    11b1:	60 5d 5b 5b 60 64 6b 75 7c 87 8f 95 9a 9b 99 97     `][[`dku|.......
    11c1:	93 8f 8b 87 86 86 87 8a 8d 90 94 96 96 96 93 8f     ................
    11d1:	8c 86 81 7f 7a 78 77 73 74 73 6f 71 6d 68 66 5f     ....zxwstsoqmhf_
    11e1:	5d 5d 5d 63 69 70 79 81 8a 8f 94 97 95 96 92 8d     ]]]cipy.........
    11f1:	8d 87 86 87 85 8a 8c 8e 93 94 94 95 93 91 8e 8a     ................
    1201:	85 82 7f 7b 7b 79 77 78 74 73 74 6d 6b 68 5e 5f     ...{{ywxtstmkh^_
    1211:	5b 5a 62 64 6e 77 7d 88 8d 91 96 94 93 92 8d 8b     [Zbdnw}.........
    1221:	88 86 87 86 89 8d 8f 93 95 96 97 94 92 8f 8a 87     ................
    1231:	83 7f 7e 7b 7a 7a 79 78 76 74 72 6e 6a 65 60 5e     ..~{zzyxvtrnje`^
    1241:	5b 5e 62 66 70 77 7f 88 8c 90 93 92 92 90 8c 8b     [^bfpw..........
    1251:	88 87 88 88 8a 8d 8f 93 95 96 96 94 92 8f 8a 87     ................
    1261:	83 7f 7e 7c 7b 7b 79 79 78 75 73 6f 6b 66 61 5e     ..~|{{yyxusokfa^
    1271:	5b 5b 5f 65 6b 75 7c 83 8b 8e 91 93 90 90 8e 8a     [[_eku|.........
    1281:	8a 87 87 89 8a 8d 91 92 95 97 96 96 93 8f 8c 88     ................
    1291:	84 81 7e 7d 7b 7a 7b 79 79 79 76 73 70 6a 65 61     ..~}{z{yyyvspjea
    12a1:	5c 5c 5c 60 68 6d 77 7f 84 8d 8f 91 93 8f 8e 8c     \\\`hmw.........
    12b1:	88 88 87 86 89 8a 8d 91 93 96 97 96 95 92 8f 8c     ................
    12c1:	87 84 81 7e 7d 7c 7b 7c 7b 7a 79 78 74 71 6c 66     ...~}|{|{zyxtqlf
    12d1:	64 5f 5e 5f 60 67 6c 73 7b 80 87 8b 8d 90 8e 8e     d_^_`gls{.......
    12e1:	8c 8a 89 87 88 89 89 8d 8e 91 94 94 95 94 91 90     ................
    12f1:	8c 89 87 82 81 7f 7d 7f 7d 7c 7c 7a 79 78 74 72     ......}.}||zyxtr
    1301:	6e 69 67 63 62 62 63 67 6c 71 78 7e 82 88 8a 8b     nigcbbcglqx~....
    1311:	8d 8b 8b 8a 87 88 88 87 8b 8b 8d 91 91 94 94 93     ................
    1321:	93 90 8e 8c 88 86 83 81 80 7f 7e 7d 7c 7b 7a 79     ..........~}|{zy
    1331:	77 75 72 6e 6a 66 63 62 62 64 68 6c 72 78 7d 82     wurnjfcbbdhlrx}.
    1341:	86 89 8b 8c 8b 8b 8a 89 89 88 89 8a 8c 8e 90 92     ................
    1351:	93 93 93 92 90 8e 8b 88 85 83 81 80 7f 7f 7e 7d     ..............~}
    1361:	7c 7b 7a 78 76 73 6f 6c 69 65 64 64 64 68 6b 70     |{zxvsoliedddhkp
    1371:	76 7a 80 84 86 89 8a 8a 8b 89 89 89 88 89 8a 8b     vz..............
    1381:	8e 8f 90 92 92 93 92 90 8f 8c 89 87 84 82 81 80     ................
    1391:	7f 7e 7e 7d 7b 7a 79 77 75 72 6e 6b 68 66 64 64     .~~}{zywurnkhfdd
    13a1:	66 6a 6d 72 77 7b 80 83 86 89 89 8a 89 89 89 88     fjmrw{..........
    13b1:	89 8a 8a 8d 8d 8f 91 91 92 91 90 90 8d 8b 89 87     ................
    13c1:	85 83 82 81 80 80 7f 7d 7c 7b 79 78 75 73 70 6c     .......}|{yxuspl
    13d1:	6a 67 66 66 67 69 6c 70 74 78 7d 80 84 86 88 89     jgffgilptx}.....
    13e1:	8a 8a 8a 8a 8a 8b 8b 8c 8d 8e 8f 90 90 90 90 8f     ................
    13f1:	8e 8c 8a 88 86 84 83 82 81 80 7f 7e 7d 7b 7a 78     ...........~}{zx
    1401:	76 74 72 6f 6c 69 68 67 67 68 6b 6e 72 76 7a 7e     vtrolihgghknrvz~
    1411:	82 85 87 89 8a 8a 8a 8a 8a 8b 8b 8c 8c 8d 8f 8f     ................
    1421:	90 90 90 8f 8e 8d 8b 89 87 85 83 82 81 80 80 7f     ................
    1431:	7e 7c 7b 7a 78 76 73 70 6d 6b 68 67 66 67 6a 6d     ~|{zxvspmkhgfgjm
    1441:	70 74 79 7d 81 84 86 88 89 89 89 89 89 8a 8a 8b     pty}............
    1451:	8c 8d 8e 8f 8f 90 90 8f 8e 8d 8b 89 87 86 84 82     ................
    1461:	81 81 80 80 7f 7e 7d 7b 7a 77 75 73 6f 6d 6b 68     .....~}{zwusomkh
    1471:	67 67 68 6b 6e 72 76 7a 7e 82 84 86 88 88 89 89     gghknrvz~.......
    1481:	89 89 89 8a 8b 8c 8d 8e 8f 8f 90 90 8f 8e 8c 8a     ................
    1491:	89 87 85 83 82 81 81 80 80 7f 7e 7d 7b 79 77 75     ..........~}{ywu
    14a1:	72 70 6d 6b 6a 6a 69 6a 6c 70 73 76 7a 7d 80 83     rpmkjjijlpsvz}..
    14b1:	85 86 87 88 88 89 89 89 8a 8b 8c 8c 8d 8e 8e 8f     ................
    14c1:	8e 8e 8d 8b 8a 88 87 85 84 83 82 81 80 80 7f 7e     ...............~
    14d1:	7d 7b 7a 78 76 74 72 70 6e 6c 6b 6a 6b 6c 6e 71     }{zxvtrpnlkjklnq
    14e1:	75 78 7c 80 83 85 86 87 88 89 89 89 89 89 8a 8b     ux|.............
    14f1:	8b 8c 8d 8e 8e 8e 8e 8d 8c 8a 89 87 86 84 83 82     ................
    1501:	81 81 80 80 7f 7e 7c 7b 79 78 75 73 71 6f 6d 6c     .....~|{yxusqoml
    1511:	6b 6b 6c 6e 70 73 77 7a 7d 80 83 85 86 87 88 88     kklnpswz}.......
    1521:	88 89 89 89 8a 8b 8c 8d 8e 8e 8e 8e 8d 8d 8b 8a     ................
    1531:	88 87 85 84 82 81 81 80 7f 7e 7d 7c 7b 79 77 75     .........~}|{ywu
    1541:	73 71 6f 6d 6c 6c 6c 6d 6e 71 74 77 7b 7e 81 83     sqomlllmnqtw{~..
    1551:	85 86 87 88 88 88 88 89 89 8a 8b 8c 8d 8e 8e 8e     ................
    1561:	8e 8d 8c 8b 89 88 86 84 83 81 80 80 7f 7e 7d 7c     .............~}|
    1571:	7b 7a 79 77 75 72 71 6f 6e 6d 6d 6d 6e 6f 72 76     {zywurqonmmmnorv
    1581:	79 7c 7f 82 84 86 87 87 88 89 89 89 89 8a 8a 8b     y|..............
    1591:	8c 8d 8e 8e 8e 8d 8c 8b 89 88 86 84 83 81 80 7f     ................
    15a1:	7f 7e 7d 7c 7b 7a 79 78 76 74 73 71 70 70 6f 6f     .~}|{zyxvtsqppoo
    15b1:	70 71 72 74 77 7a 7d 80 82 84 86 87 88 89 8a 8a     pqrtwz}.........
    15c1:	8a 8b 8b 8c 8c 8d 8d 8d 8d 8c 8c 8b 89 88 86 84     ................
    15d1:	82 81 7f 7e 7d 7c 7b 7a 79 78 77 76 74 73 72 71     ...~}|{zyxwvtsrq
    15e1:	71 70 71 71 72 74 76 78 7b 7d 80 82 84 86 87 88     qpqqrtvx{}......
    15f1:	89 8a 8a 8b 8b 8b 8b 8c 8c 8c 8c 8c 8b 8b 89 88     ................
    1601:	87 85 83 81 80 7f 7e 7d 7c 7b 7b 7b 7a 79 77 76     ......~}|{{{zywv
    1611:	75 74 72 72 72 72 72 73 74 75 78 7a 7c 7e 80 82     utrrrrrstuxz|~..
    1621:	84 85 87 87 88 89 8a 8a 8b 8b 8c 8c 8c 8c 8c 8c     ................
    1631:	8b 8a 89 87 85 84 82 81 7f 7e 7d 7c 7b 7a 79 78     .........~}|{zyx
    1641:	78 77 76 75 74 74 73 73 73 73 74 75 77 79 7b 7e     xwvuttsssstuwy{~
    1651:	80 82 84 85 86 87 88 88 89 89 89 89 89 8a 8a 8a     ................
    1661:	8a 8a 8a 89 88 87 86 84 83 81 80 7f 7e 7d 7c 7c     ............~}||
    1671:	7b 7b 7a 79 79 78 77 77 76 76 76 76 76 77 77 78     {{zyyxwwvvvvvwwx
    1681:	7a 7b 7d 7e 80 81 82 83 84 85 86 86 87 87 88 88     z{}~............
    1691:	88 89 89 89 89 88 88 88 87 86 85 84 83 82 81 80     ................
    16a1:	7f 7e 7d 7c 7b 7b 7b 7a 79 79 78 78 77 77 77 77     .~}|{{{zyyxxwwww
    16b1:	78 78 78 78 7a 7b 7c 7e 7f 81 82 83 84 84 85 86     xxxxz{|~........
    16c1:	86 86 87 87 87 88 88 88 88 88 87 87 86 85 85 83     ................
    16d1:	82 81 80 7f 7f 7e 7d 7d 7d 7c 7c 7c 7c 7c 7c 7b     .....~}}}||||||{
    16e1:	7a 7a 79 79 79 79 79 7a 7a 7b 7d 7e 7f 80 81 82     zzyyyyyzz{}~....
    16f1:	82 82 83 83 83 83 84 84 84 85 85 85 85 86 85 85     ................
    1701:	85 84 83 83 82 82 81 80 80 80 7f 7f 7f 7f 7e 7e     ..............~~
    1711:	7e 7e 7e 7d 7d 7c 7c 7b 7b 7b 7b 7b 7b 7c 7c 7d     ~~~}}||{{{{{{||}
    1721:	7e 7f 80 80 80 80 81 81 81 81 82 82 82 83 83 84     ~...............
    1731:	84 85 85 85 85 84 84 83 82 82 81 81 80 80 80 80     ................
    1741:	80 80 80 80 80 7f 7f 7e 7e 7d 7d 7d 7d 7d 7d 7d     .......~~}}}}}}}
    1751:	7d 7d 7e 7e 7f 7f 80 80 80 80 80 80 80 80 80 80     }}~~............
    1761:	80 81 81 81 81 81 82 82 82 82 82 82 81 81 81 81     ................
    1771:	80 80 81 81 81 81 81 81 81 80 80 80 80 80 80 7f     ................
    1781:	7f 7e 7e 7e 7e 7e 7f 7f 7f 7f 7f 7f 7f 7f 7f 80     .~~~~~..........
    1791:	80 80 80 80 80 80 80 81 81 81 81 81 81 81 81 81     ................
    17a1:	80 80 80 80 80 80 80 80 80 81 81 81 80 80 80 80     ................
    17b1:	80 7f 80 80 80 80 80 80 80 80 7f 7f 80 80 80 80     ................
    17c1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    17d1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    17e1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    17f1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1801:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1811:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1821:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1831:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1841:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1851:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1861:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1871:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1881:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1891:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    18a1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    18b1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    18c1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    18d1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    18e1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    18f1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1901:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1911:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1921:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1931:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1941:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1951:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1961:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1971:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1981:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1991:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    19a1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    19b1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    19c1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    19d1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    19e1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    19f1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1a01:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1a11:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1a21:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1a31:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1a41:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1a51:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1a61:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1a71:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1a81:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1a91:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1aa1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1ab1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1ac1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1ad1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1ae1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1af1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1b01:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1b11:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1b21:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1b31:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1b41:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1b51:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1b61:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1b71:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1b81:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1b91:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1ba1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1bb1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1bc1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1bd1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1be1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1bf1:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1c01:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1c11:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1c21:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1c31:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
    1c41:	80 80 80 80 80 80 80 80 80 80 80 80 80 80 80 80     ................
	...

00001c52 <__ctors_end>:
    1c52:	11 24       	eor	r1, r1
    1c54:	1f be       	out	0x3f, r1	; 63
    1c56:	cf e5       	ldi	r28, 0x5F	; 95
    1c58:	d8 e0       	ldi	r29, 0x08	; 8
    1c5a:	de bf       	out	0x3e, r29	; 62
    1c5c:	cd bf       	out	0x3d, r28	; 61

00001c5e <__do_copy_data>:
    1c5e:	11 e0       	ldi	r17, 0x01	; 1
    1c60:	a0 e6       	ldi	r26, 0x60	; 96
    1c62:	b0 e0       	ldi	r27, 0x00	; 0
    1c64:	e6 ec       	ldi	r30, 0xC6	; 198
    1c66:	f0 e4       	ldi	r31, 0x40	; 64
    1c68:	02 c0       	rjmp	.+4      	; 0x1c6e <.do_copy_data_start>

00001c6a <.do_copy_data_loop>:
    1c6a:	05 90       	lpm	r0, Z+
    1c6c:	0d 92       	st	X+, r0

00001c6e <.do_copy_data_start>:
    1c6e:	a8 35       	cpi	r26, 0x58	; 88
    1c70:	b1 07       	cpc	r27, r17
    1c72:	d9 f7       	brne	.-10     	; 0x1c6a <.do_copy_data_loop>

00001c74 <__do_clear_bss>:
    1c74:	13 e0       	ldi	r17, 0x03	; 3
    1c76:	a8 e5       	ldi	r26, 0x58	; 88
    1c78:	b1 e0       	ldi	r27, 0x01	; 1
    1c7a:	01 c0       	rjmp	.+2      	; 0x1c7e <.do_clear_bss_start>

00001c7c <.do_clear_bss_loop>:
    1c7c:	1d 92       	st	X+, r1

00001c7e <.do_clear_bss_start>:
    1c7e:	aa 3a       	cpi	r26, 0xAA	; 170
    1c80:	b1 07       	cpc	r27, r17
    1c82:	e1 f7       	brne	.-8      	; 0x1c7c <.do_clear_bss_loop>
    1c84:	0e 94 7c 0f 	call	0x1ef8	; 0x1ef8 <main>
    1c88:	0c 94 61 20 	jmp	0x40c2	; 0x40c2 <_exit>

00001c8c <__bad_interrupt>:
    1c8c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00001c90 <init_ports>:



void init_ports(void)
{
	PORTA = 0xFF;
    1c90:	9f ef       	ldi	r25, 0xFF	; 255
    1c92:	9b bb       	out	0x1b, r25	; 27
	DDRA  = 0xFF;	//DAC out
    1c94:	9a bb       	out	0x1a, r25	; 26


	
	PORTB = 0xEF;//0b11110011;
    1c96:	8f ee       	ldi	r24, 0xEF	; 239
    1c98:	88 bb       	out	0x18, r24	; 24
	DDRB  = 0xBF;//0b10101110; //MISO line i/p, rest o/p
    1c9a:	8f eb       	ldi	r24, 0xBF	; 191
    1c9c:	87 bb       	out	0x17, r24	; 23

	PORTC = 0x00;	// LCD - control & JTAG
    1c9e:	15 ba       	out	0x15, r1	; 21
	DDRC  = 0x0F;	// SW1 - PC6;	SW2 - PC7
    1ca0:	8f e0       	ldi	r24, 0x0F	; 15
    1ca2:	84 bb       	out	0x14, r24	; 20



	PORTD = 0x00;	// LCD - DATA
    1ca4:	12 ba       	out	0x12, r1	; 18
	DDRD = 0xFF;
    1ca6:	91 bb       	out	0x11, r25	; 17

};
    1ca8:	08 95       	ret

00001caa <LCD_clear>:
	return 0;
};


void LCD_clear(void)
{
    1caa:	0f 93       	push	r16
    1cac:	1f 93       	push	r17

	LCD_DisplayString_F(1,1,"                ");
    1cae:	00 e6       	ldi	r16, 0x60	; 96
    1cb0:	10 e0       	ldi	r17, 0x00	; 0
    1cb2:	81 e0       	ldi	r24, 0x01	; 1
    1cb4:	61 e0       	ldi	r22, 0x01	; 1
    1cb6:	a8 01       	movw	r20, r16
    1cb8:	0e 94 41 1c 	call	0x3882	; 0x3882 <LCD_DisplayString_F>

	LCD_DisplayString_F(2,1,"                ");
    1cbc:	82 e0       	ldi	r24, 0x02	; 2
    1cbe:	61 e0       	ldi	r22, 0x01	; 1
    1cc0:	a8 01       	movw	r20, r16
    1cc2:	0e 94 41 1c 	call	0x3882	; 0x3882 <LCD_DisplayString_F>

};
    1cc6:	1f 91       	pop	r17
    1cc8:	0f 91       	pop	r16
    1cca:	08 95       	ret

00001ccc <PLAY_SONG>:



unsigned char PLAY_SONG (unsigned char *fileName)
{
    1ccc:	2f 92       	push	r2
    1cce:	3f 92       	push	r3
    1cd0:	4f 92       	push	r4
    1cd2:	5f 92       	push	r5
    1cd4:	6f 92       	push	r6
    1cd6:	7f 92       	push	r7
    1cd8:	9f 92       	push	r9
    1cda:	af 92       	push	r10
    1cdc:	bf 92       	push	r11
    1cde:	cf 92       	push	r12
    1ce0:	df 92       	push	r13
    1ce2:	ef 92       	push	r14
    1ce4:	ff 92       	push	r15
    1ce6:	0f 93       	push	r16
    1ce8:	1f 93       	push	r17
    1cea:	df 93       	push	r29
    1cec:	cf 93       	push	r28
    1cee:	00 d0       	rcall	.+0      	; 0x1cf0 <PLAY_SONG+0x24>
    1cf0:	00 d0       	rcall	.+0      	; 0x1cf2 <PLAY_SONG+0x26>
    1cf2:	00 d0       	rcall	.+0      	; 0x1cf4 <PLAY_SONG+0x28>
    1cf4:	cd b7       	in	r28, 0x3d	; 61
    1cf6:	de b7       	in	r29, 0x3e	; 62
    1cf8:	bc 01       	movw	r22, r24
		unsigned long cluster, byteCounter = 0, fileSize, firstSector;
		unsigned int k;
		unsigned char j, error;

		
		dir = findFiles (GET_FILE, fileName); //get the file location
    1cfa:	81 e0       	ldi	r24, 0x01	; 1
    1cfc:	0e 94 a8 15 	call	0x2b50	; 0x2b50 <findFiles>
    1d00:	9c 01       	movw	r18, r24
		if(dir == 0)
    1d02:	00 97       	sbiw	r24, 0x00	; 0
    1d04:	69 f4       	brne	.+26     	; 0x1d20 <PLAY_SONG+0x54>
		{
			LCD_clear();
    1d06:	0e 94 55 0e 	call	0x1caa	; 0x1caa <LCD_clear>

			LCD_DisplayString_F(1,1,"FILE NOT FOUND");
    1d0a:	81 e0       	ldi	r24, 0x01	; 1
    1d0c:	61 e0       	ldi	r22, 0x01	; 1
    1d0e:	41 e7       	ldi	r20, 0x71	; 113
    1d10:	50 e0       	ldi	r21, 0x00	; 0
    1d12:	0e 94 41 1c 	call	0x3882	; 0x3882 <LCD_DisplayString_F>

			LCD_DisplayString_F(2,1," ????????  ");
    1d16:	82 e0       	ldi	r24, 0x02	; 2
    1d18:	61 e0       	ldi	r22, 0x01	; 1
    1d1a:	40 e8       	ldi	r20, 0x80	; 128
    1d1c:	50 e0       	ldi	r21, 0x00	; 0
    1d1e:	c6 c0       	rjmp	.+396    	; 0x1eac <PLAY_SONG+0x1e0>
		  	return (0);
		 }

		

		cluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    1d20:	dc 01       	movw	r26, r24
    1d22:	54 96       	adiw	r26, 0x14	; 20
    1d24:	8d 91       	ld	r24, X+
    1d26:	9c 91       	ld	r25, X
    1d28:	55 97       	sbiw	r26, 0x15	; 21
    1d2a:	a0 e0       	ldi	r26, 0x00	; 0
    1d2c:	b0 e0       	ldi	r27, 0x00	; 0
    1d2e:	8c 01       	movw	r16, r24
    1d30:	ff 24       	eor	r15, r15
    1d32:	ee 24       	eor	r14, r14
    1d34:	f9 01       	movw	r30, r18
    1d36:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d38:	93 8d       	ldd	r25, Z+27	; 0x1b
    1d3a:	a0 e0       	ldi	r26, 0x00	; 0
    1d3c:	b0 e0       	ldi	r27, 0x00	; 0
    1d3e:	e8 2a       	or	r14, r24
    1d40:	f9 2a       	or	r15, r25
    1d42:	0a 2b       	or	r16, r26
    1d44:	1b 2b       	or	r17, r27

		fileSize = dir->fileSize;
    1d46:	d9 01       	movw	r26, r18
    1d48:	5c 96       	adiw	r26, 0x1c	; 28
    1d4a:	8d 91       	ld	r24, X+
    1d4c:	9d 91       	ld	r25, X+
    1d4e:	0d 90       	ld	r0, X+
    1d50:	bc 91       	ld	r27, X
    1d52:	a0 2d       	mov	r26, r0
    1d54:	89 83       	std	Y+1, r24	; 0x01
    1d56:	9a 83       	std	Y+2, r25	; 0x02
    1d58:	ab 83       	std	Y+3, r26	; 0x03
    1d5a:	bc 83       	std	Y+4, r27	; 0x04
    1d5c:	aa 24       	eor	r10, r10
    1d5e:	bb 24       	eor	r11, r11
    1d60:	65 01       	movw	r12, r10
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1d62:	80 e6       	ldi	r24, 0x60	; 96
    1d64:	28 2e       	mov	r2, r24
    1d66:	8a ee       	ldi	r24, 0xEA	; 234
    1d68:	38 2e       	mov	r3, r24

		
		while(1)
		{
		  firstSector = getFirstSector (cluster);
    1d6a:	c8 01       	movw	r24, r16
    1d6c:	b7 01       	movw	r22, r14
    1d6e:	0e 94 8f 10 	call	0x211e	; 0x211e <getFirstSector>
    1d72:	2b 01       	movw	r4, r22
    1d74:	3c 01       	movw	r6, r24
    1d76:	99 24       	eor	r9, r9
    1d78:	72 c0       	rjmp	.+228    	; 0x1e5e <PLAY_SONG+0x192>

		  for(j=0; j<sectorPerCluster; j++)
		  {
		    SD_readSingleBlock(firstSector + j);
    1d7a:	c3 01       	movw	r24, r6
    1d7c:	b2 01       	movw	r22, r4
    1d7e:	69 0d       	add	r22, r9
    1d80:	71 1d       	adc	r23, r1
    1d82:	81 1d       	adc	r24, r1
    1d84:	91 1d       	adc	r25, r1
    1d86:	0e 94 71 1d 	call	0x3ae2	; 0x3ae2 <SD_readSingleBlock>
    1d8a:	1e 82       	std	Y+6, r1	; 0x06
    1d8c:	1d 82       	std	Y+5, r1	; 0x05
		    {
				// Sending to UART
		     	// transmitByte(buffer[k]);

			  	// Sending to DAC
				PORTA = buffer[k];
    1d8e:	ed 81       	ldd	r30, Y+5	; 0x05
    1d90:	fe 81       	ldd	r31, Y+6	; 0x06
    1d92:	ed 58       	subi	r30, 0x8D	; 141
    1d94:	fe 4f       	sbci	r31, 0xFE	; 254
    1d96:	80 81       	ld	r24, Z
    1d98:	8b bb       	out	0x1b, r24	; 27

				if(KEY1_PRESSED)
    1d9a:	9e 99       	sbic	0x13, 6	; 19
    1d9c:	31 c0       	rjmp	.+98     	; 0x1e00 <PLAY_SONG+0x134>
    1d9e:	84 ef       	ldi	r24, 0xF4	; 244
    1da0:	91 e0       	ldi	r25, 0x01	; 1
    1da2:	ec e2       	ldi	r30, 0x2C	; 44
    1da4:	f1 e0       	ldi	r31, 0x01	; 1
    1da6:	31 97       	sbiw	r30, 0x01	; 1
    1da8:	f1 f7       	brne	.-4      	; 0x1da6 <PLAY_SONG+0xda>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1daa:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1dac:	d1 f7       	brne	.-12     	; 0x1da2 <PLAY_SONG+0xd6>
				{
					// PAUSE/CONTINUE

					_delay_ms(50);
					while(KEY1_PRESSED);
    1dae:	9e 9b       	sbis	0x13, 6	; 19
    1db0:	fe cf       	rjmp	.-4      	; 0x1dae <PLAY_SONG+0xe2>

					LCD_DisplayString_F(2,1,"Paused...       ");
    1db2:	82 e0       	ldi	r24, 0x02	; 2
    1db4:	61 e0       	ldi	r22, 0x01	; 1
    1db6:	4c e8       	ldi	r20, 0x8C	; 140
    1db8:	50 e0       	ldi	r21, 0x00	; 0
    1dba:	0e 94 41 1c 	call	0x3882	; 0x3882 <LCD_DisplayString_F>
    1dbe:	0e c0       	rjmp	.+28     	; 0x1ddc <PLAY_SONG+0x110>
					while(KEY1_OPEN)
					{	// iF STOP PRESSED
						
						if(KEY2_PRESSED)
    1dc0:	9f 99       	sbic	0x13, 7	; 19
    1dc2:	0c c0       	rjmp	.+24     	; 0x1ddc <PLAY_SONG+0x110>
    1dc4:	8c e2       	ldi	r24, 0x2C	; 44
    1dc6:	91 e0       	ldi	r25, 0x01	; 1
    1dc8:	2c e2       	ldi	r18, 0x2C	; 44
    1dca:	31 e0       	ldi	r19, 0x01	; 1
    1dcc:	f9 01       	movw	r30, r18
    1dce:	31 97       	sbiw	r30, 0x01	; 1
    1dd0:	f1 f7       	brne	.-4      	; 0x1dce <PLAY_SONG+0x102>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1dd2:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1dd4:	d9 f7       	brne	.-10     	; 0x1dcc <PLAY_SONG+0x100>
						{
							_delay_ms(30);

							while(KEY2_PRESSED);
    1dd6:	9f 9b       	sbis	0x13, 7	; 19
    1dd8:	fe cf       	rjmp	.-4      	; 0x1dd6 <PLAY_SONG+0x10a>
    1dda:	1f c0       	rjmp	.+62     	; 0x1e1a <PLAY_SONG+0x14e>

					_delay_ms(50);
					while(KEY1_PRESSED);

					LCD_DisplayString_F(2,1,"Paused...       ");
					while(KEY1_OPEN)
    1ddc:	9e 99       	sbic	0x13, 6	; 19
    1dde:	f0 cf       	rjmp	.-32     	; 0x1dc0 <PLAY_SONG+0xf4>
    1de0:	c1 01       	movw	r24, r2
    1de2:	01 97       	sbiw	r24, 0x01	; 1
    1de4:	f1 f7       	brne	.-4      	; 0x1de2 <PLAY_SONG+0x116>

					}

					_delay_ms(20);

					while(KEY1_PRESSED);
    1de6:	9e 9b       	sbis	0x13, 6	; 19
    1de8:	fe cf       	rjmp	.-4      	; 0x1de6 <PLAY_SONG+0x11a>
    1dea:	c1 01       	movw	r24, r2
    1dec:	01 97       	sbiw	r24, 0x01	; 1
    1dee:	f1 f7       	brne	.-4      	; 0x1dec <PLAY_SONG+0x120>
					_delay_ms(20);

					while(KEY1_PRESSED);
    1df0:	9e 9b       	sbis	0x13, 6	; 19
    1df2:	fe cf       	rjmp	.-4      	; 0x1df0 <PLAY_SONG+0x124>
					LCD_DisplayString_F(2,1,"Playing...      ");
    1df4:	82 e0       	ldi	r24, 0x02	; 2
    1df6:	61 e0       	ldi	r22, 0x01	; 1
    1df8:	4d e9       	ldi	r20, 0x9D	; 157
    1dfa:	50 e0       	ldi	r21, 0x00	; 0
    1dfc:	0e 94 41 1c 	call	0x3882	; 0x3882 <LCD_DisplayString_F>
				}

				if(KEY2_PRESSED)
    1e00:	9f 99       	sbic	0x13, 7	; 19
    1e02:	11 c0       	rjmp	.+34     	; 0x1e26 <PLAY_SONG+0x15a>
    1e04:	84 ef       	ldi	r24, 0xF4	; 244
    1e06:	91 e0       	ldi	r25, 0x01	; 1
    1e08:	2c e2       	ldi	r18, 0x2C	; 44
    1e0a:	31 e0       	ldi	r19, 0x01	; 1
    1e0c:	f9 01       	movw	r30, r18
    1e0e:	31 97       	sbiw	r30, 0x01	; 1
    1e10:	f1 f7       	brne	.-4      	; 0x1e0e <PLAY_SONG+0x142>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1e12:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1e14:	d9 f7       	brne	.-10     	; 0x1e0c <PLAY_SONG+0x140>
				{
					// STOP and LIST NEXT
					
					_delay_ms(50);

					while(KEY2_PRESSED);
    1e16:	9f 9b       	sbis	0x13, 7	; 19
    1e18:	fe cf       	rjmp	.-4      	; 0x1e16 <PLAY_SONG+0x14a>

					LCD_clear();
    1e1a:	0e 94 55 0e 	call	0x1caa	; 0x1caa <LCD_clear>
					STOPPED = 1;
    1e1e:	81 e0       	ldi	r24, 0x01	; 1
    1e20:	80 93 58 01 	sts	0x0158, r24
    1e24:	45 c0       	rjmp	.+138    	; 0x1eb0 <PLAY_SONG+0x1e4>
    1e26:	87 e7       	ldi	r24, 0x77	; 119
    1e28:	91 e0       	ldi	r25, 0x01	; 1
    1e2a:	01 97       	sbiw	r24, 0x01	; 1
    1e2c:	f1 f7       	brne	.-4      	; 0x1e2a <PLAY_SONG+0x15e>

				}
	
				_delay_ms(.125);

		      if ((byteCounter++) >= fileSize ) return 0;
    1e2e:	89 81       	ldd	r24, Y+1	; 0x01
    1e30:	9a 81       	ldd	r25, Y+2	; 0x02
    1e32:	ab 81       	ldd	r26, Y+3	; 0x03
    1e34:	bc 81       	ldd	r27, Y+4	; 0x04
    1e36:	a8 16       	cp	r10, r24
    1e38:	b9 06       	cpc	r11, r25
    1e3a:	ca 06       	cpc	r12, r26
    1e3c:	db 06       	cpc	r13, r27
    1e3e:	c0 f5       	brcc	.+112    	; 0x1eb0 <PLAY_SONG+0x1e4>
    1e40:	08 94       	sec
    1e42:	a1 1c       	adc	r10, r1
    1e44:	b1 1c       	adc	r11, r1
    1e46:	c1 1c       	adc	r12, r1
    1e48:	d1 1c       	adc	r13, r1

		  for(j=0; j<sectorPerCluster; j++)
		  {
		    SD_readSingleBlock(firstSector + j);
    
			for(k=0; k<512; k++)
    1e4a:	ad 81       	ldd	r26, Y+5	; 0x05
    1e4c:	be 81       	ldd	r27, Y+6	; 0x06
    1e4e:	11 96       	adiw	r26, 0x01	; 1
    1e50:	be 83       	std	Y+6, r27	; 0x06
    1e52:	ad 83       	std	Y+5, r26	; 0x05
    1e54:	a0 50       	subi	r26, 0x00	; 0
    1e56:	b2 40       	sbci	r27, 0x02	; 2
    1e58:	09 f0       	breq	.+2      	; 0x1e5c <PLAY_SONG+0x190>
    1e5a:	99 cf       	rjmp	.-206    	; 0x1d8e <PLAY_SONG+0xc2>
		
		while(1)
		{
		  firstSector = getFirstSector (cluster);

		  for(j=0; j<sectorPerCluster; j++)
    1e5c:	93 94       	inc	r9
    1e5e:	20 91 73 03 	lds	r18, 0x0373
    1e62:	30 91 74 03 	lds	r19, 0x0374
    1e66:	89 2d       	mov	r24, r9
    1e68:	90 e0       	ldi	r25, 0x00	; 0
    1e6a:	82 17       	cp	r24, r18
    1e6c:	93 07       	cpc	r25, r19
    1e6e:	08 f4       	brcc	.+2      	; 0x1e72 <PLAY_SONG+0x1a6>
    1e70:	84 cf       	rjmp	.-248    	; 0x1d7a <PLAY_SONG+0xae>
				_delay_ms(.125);

		      if ((byteCounter++) >= fileSize ) return 0;
		    }
		  }
		  cluster = getSetNextCluster (cluster, GET, 0);
    1e72:	c8 01       	movw	r24, r16
    1e74:	b7 01       	movw	r22, r14
    1e76:	40 e0       	ldi	r20, 0x00	; 0
    1e78:	00 e0       	ldi	r16, 0x00	; 0
    1e7a:	10 e0       	ldi	r17, 0x00	; 0
    1e7c:	20 e0       	ldi	r18, 0x00	; 0
    1e7e:	30 e0       	ldi	r19, 0x00	; 0
    1e80:	0e 94 2b 15 	call	0x2a56	; 0x2a56 <getSetNextCluster>
    1e84:	7b 01       	movw	r14, r22
    1e86:	8c 01       	movw	r16, r24
		  if(cluster == 0)
    1e88:	61 15       	cp	r22, r1
    1e8a:	71 05       	cpc	r23, r1
    1e8c:	81 05       	cpc	r24, r1
    1e8e:	91 05       	cpc	r25, r1
    1e90:	09 f0       	breq	.+2      	; 0x1e94 <PLAY_SONG+0x1c8>
    1e92:	6b cf       	rjmp	.-298    	; 0x1d6a <PLAY_SONG+0x9e>
		   {
		   		LCD_clear();
    1e94:	0e 94 55 0e 	call	0x1caa	; 0x1caa <LCD_clear>
		   		LCD_DisplayString_F(1,1,"  ERROR:CLUSTER ");
    1e98:	81 e0       	ldi	r24, 0x01	; 1
    1e9a:	61 e0       	ldi	r22, 0x01	; 1
    1e9c:	4e ea       	ldi	r20, 0xAE	; 174
    1e9e:	50 e0       	ldi	r21, 0x00	; 0
    1ea0:	0e 94 41 1c 	call	0x3882	; 0x3882 <LCD_DisplayString_F>

				LCD_DisplayString_F(2,1,"   ???????    ");
    1ea4:	82 e0       	ldi	r24, 0x02	; 2
    1ea6:	61 e0       	ldi	r22, 0x01	; 1
    1ea8:	4f eb       	ldi	r20, 0xBF	; 191
    1eaa:	50 e0       	ldi	r21, 0x00	; 0
    1eac:	0e 94 41 1c 	call	0x3882	; 0x3882 <LCD_DisplayString_F>
				return 0;
		   }
		}
		return 0;
};
    1eb0:	80 e0       	ldi	r24, 0x00	; 0
    1eb2:	26 96       	adiw	r28, 0x06	; 6
    1eb4:	0f b6       	in	r0, 0x3f	; 63
    1eb6:	f8 94       	cli
    1eb8:	de bf       	out	0x3e, r29	; 62
    1eba:	0f be       	out	0x3f, r0	; 63
    1ebc:	cd bf       	out	0x3d, r28	; 61
    1ebe:	cf 91       	pop	r28
    1ec0:	df 91       	pop	r29
    1ec2:	1f 91       	pop	r17
    1ec4:	0f 91       	pop	r16
    1ec6:	ff 90       	pop	r15
    1ec8:	ef 90       	pop	r14
    1eca:	df 90       	pop	r13
    1ecc:	cf 90       	pop	r12
    1ece:	bf 90       	pop	r11
    1ed0:	af 90       	pop	r10
    1ed2:	9f 90       	pop	r9
    1ed4:	7f 90       	pop	r7
    1ed6:	6f 90       	pop	r6
    1ed8:	5f 90       	pop	r5
    1eda:	4f 90       	pop	r4
    1edc:	3f 90       	pop	r3
    1ede:	2f 90       	pop	r2
    1ee0:	08 95       	ret

00001ee2 <init_devices>:


//call this routine to initialize all peripherals
void init_devices(void)
{
	 cli();  //all interrupts disabled
    1ee2:	f8 94       	cli
	 init_ports();
    1ee4:	0e 94 48 0e 	call	0x1c90	; 0x1c90 <init_ports>
	 init_spi();
    1ee8:	0e 94 1c 1e 	call	0x3c38	; 0x3c38 <init_spi>

	 LCD_init();
    1eec:	0e 94 63 1c 	call	0x38c6	; 0x38c6 <LCD_init>



	 MCUCR = 0x00;	//MCU power management
    1ef0:	15 be       	out	0x35, r1	; 53
	 GICR  = 0x00;	//General Interrupt control Reg.
    1ef2:	1b be       	out	0x3b, r1	; 59

	 TIMSK = 0x00; //timer interrupt sources
    1ef4:	19 be       	out	0x39, r1	; 57
 
};
    1ef6:	08 95       	ret

00001ef8 <main>:


//========================= Main ====================================

int main()
{
    1ef8:	2f 92       	push	r2
    1efa:	3f 92       	push	r3
    1efc:	4f 92       	push	r4
    1efe:	5f 92       	push	r5
    1f00:	6f 92       	push	r6
    1f02:	7f 92       	push	r7
    1f04:	8f 92       	push	r8
    1f06:	9f 92       	push	r9
    1f08:	af 92       	push	r10
    1f0a:	bf 92       	push	r11
    1f0c:	cf 92       	push	r12
    1f0e:	df 92       	push	r13
    1f10:	ef 92       	push	r14
    1f12:	ff 92       	push	r15
    1f14:	0f 93       	push	r16
    1f16:	1f 93       	push	r17
    1f18:	cf 93       	push	r28
    1f1a:	df 93       	push	r29
    1f1c:	88 ee       	ldi	r24, 0xE8	; 232
    1f1e:	93 e0       	ldi	r25, 0x03	; 3
    1f20:	2c e2       	ldi	r18, 0x2C	; 44
    1f22:	31 e0       	ldi	r19, 0x01	; 1
    1f24:	f9 01       	movw	r30, r18
    1f26:	31 97       	sbiw	r30, 0x01	; 1
    1f28:	f1 f7       	brne	.-4      	; 0x1f26 <main+0x2e>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1f2a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1f2c:	d9 f7       	brne	.-10     	; 0x1f24 <main+0x2c>
	unsigned int i;
	unsigned char fileName[13];

	_delay_ms(100);  //delay for VCC stabilization

	init_devices();
    1f2e:	0e 94 71 0f 	call	0x1ee2	; 0x1ee2 <init_devices>




	LCD_DisplayString_F(1,1," *AUDIO PLAYER* ");
    1f32:	81 e0       	ldi	r24, 0x01	; 1
    1f34:	61 e0       	ldi	r22, 0x01	; 1
    1f36:	4e ec       	ldi	r20, 0xCE	; 206
    1f38:	50 e0       	ldi	r21, 0x00	; 0
    1f3a:	0e 94 41 1c 	call	0x3882	; 0x3882 <LCD_DisplayString_F>

	LCD_DisplayString_F(2,1,"EMBEDDED PROJECT");
    1f3e:	82 e0       	ldi	r24, 0x02	; 2
    1f40:	61 e0       	ldi	r22, 0x01	; 1
    1f42:	4f ed       	ldi	r20, 0xDF	; 223
    1f44:	50 e0       	ldi	r21, 0x00	; 0
    1f46:	0e 94 41 1c 	call	0x3882	; 0x3882 <LCD_DisplayString_F>

	

	cardType = 0;
    1f4a:	10 92 84 03 	sts	0x0384, r1
    1f4e:	c0 e0       	ldi	r28, 0x00	; 0
    1f50:	d0 e0       	ldi	r29, 0x00	; 0

	for (i=0; i<10; i++)
	{
		error = SD_init();
    1f52:	0e 94 a2 1d 	call	0x3b44	; 0x3b44 <SD_init>
		if(!error) break;
    1f56:	88 23       	and	r24, r24
    1f58:	61 f0       	breq	.+24     	; 0x1f72 <main+0x7a>

	

	cardType = 0;

	for (i=0; i<10; i++)
    1f5a:	21 96       	adiw	r28, 0x01	; 1
    1f5c:	ca 30       	cpi	r28, 0x0A	; 10
    1f5e:	d1 05       	cpc	r29, r1
    1f60:	c1 f7       	brne	.-16     	; 0x1f52 <main+0x5a>
		if(!error) break;
	}

	if(error)
	{
		if(error == 1) LCD_DisplayString_F(1,1," SDcard ND ");
    1f62:	81 30       	cpi	r24, 0x01	; 1
    1f64:	29 f4       	brne	.+10     	; 0x1f70 <main+0x78>
    1f66:	61 e0       	ldi	r22, 0x01	; 1
    1f68:	40 ef       	ldi	r20, 0xF0	; 240
    1f6a:	50 e0       	ldi	r21, 0x00	; 0
    1f6c:	0e 94 41 1c 	call	0x3882	; 0x3882 <LCD_DisplayString_F>
    1f70:	ff cf       	rjmp	.-2      	; 0x1f70 <main+0x78>

		while(1);  //wait here forever if error in SD init 
	}


	SPI_HIGH_SPEED_6M;	//SCK - 6 MHz
    1f72:	80 e5       	ldi	r24, 0x50	; 80
    1f74:	8d b9       	out	0x0d, r24	; 13
    1f76:	70 9a       	sbi	0x0e, 0	; 14
    1f78:	88 eb       	ldi	r24, 0xB8	; 184
    1f7a:	9b e0       	ldi	r25, 0x0B	; 11
    1f7c:	01 97       	sbiw	r24, 0x01	; 1
    1f7e:	f1 f7       	brne	.-4      	; 0x1f7c <main+0x84>
	_delay_ms(1);		//some delay


	FAT32_active = 1;
	error = getBootSectorData (); //read boot sector and keep necessary data in global variables
    1f80:	0e 94 45 14 	call	0x288a	; 0x288a <getBootSectorData>
    1f84:	20 e2       	ldi	r18, 0x20	; 32
    1f86:	3e e4       	ldi	r19, 0x4E	; 78
    1f88:	5c e2       	ldi	r21, 0x2C	; 44
    1f8a:	25 2e       	mov	r2, r21
    1f8c:	51 e0       	ldi	r21, 0x01	; 1
    1f8e:	35 2e       	mov	r3, r21
    1f90:	05 c0       	rjmp	.+10     	; 0x1f9c <main+0xa4>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1f92:	c1 01       	movw	r24, r2
    1f94:	01 97       	sbiw	r24, 0x01	; 1
    1f96:	f1 f7       	brne	.-4      	; 0x1f94 <main+0x9c>
    1f98:	21 50       	subi	r18, 0x01	; 1
    1f9a:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1f9c:	21 15       	cp	r18, r1
    1f9e:	31 05       	cpc	r19, r1
    1fa0:	c1 f7       	brne	.-16     	; 0x1f92 <main+0x9a>
	while(1)
	{

		_delay_ms(2000);

		LCD_clear();
    1fa2:	0e 94 55 0e 	call	0x1caa	; 0x1caa <LCD_clear>
		unsigned int i;
		unsigned char j;


RESTART:
		cluster = rootCluster; //root cluster
    1fa6:	a0 90 6b 01 	lds	r10, 0x016B
    1faa:	b0 90 6c 01 	lds	r11, 0x016C
    1fae:	c0 90 6d 01 	lds	r12, 0x016D
    1fb2:	d0 90 6e 01 	lds	r13, 0x016E

		while(1)
		{
			firstSector = getFirstSector (cluster);
    1fb6:	c6 01       	movw	r24, r12
    1fb8:	b5 01       	movw	r22, r10
    1fba:	0e 94 8f 10 	call	0x211e	; 0x211e <getFirstSector>
    1fbe:	2b 01       	movw	r4, r22
    1fc0:	3c 01       	movw	r6, r24
    1fc2:	ee 24       	eor	r14, r14
    1fc4:	ff 24       	eor	r15, r15
    1fc6:	87 01       	movw	r16, r14
    1fc8:	79 c0       	rjmp	.+242    	; 0x20bc <main+0x1c4>

			for(sector = 0; sector < sectorPerCluster; sector++)
			{
				SD_readSingleBlock (firstSector + sector);
    1fca:	c8 01       	movw	r24, r16
    1fcc:	b7 01       	movw	r22, r14
    1fce:	64 0d       	add	r22, r4
    1fd0:	75 1d       	adc	r23, r5
    1fd2:	86 1d       	adc	r24, r6
    1fd4:	97 1d       	adc	r25, r7
    1fd6:	0e 94 71 1d 	call	0x3ae2	; 0x3ae2 <SD_readSingleBlock>
    1fda:	88 24       	eor	r8, r8
    1fdc:	99 24       	eor	r9, r9
    1fde:	61 c0       	rjmp	.+194    	; 0x20a2 <main+0x1aa>
	

				for(i=0; i<bytesPerSector; i+=32)
    1fe0:	e4 01       	movw	r28, r8
    1fe2:	cd 58       	subi	r28, 0x8D	; 141
    1fe4:	de 4f       	sbci	r29, 0xFE	; 254
				{
					dir = (struct dir_Structure *) &buffer[i];

					if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    1fe6:	88 81       	ld	r24, Y
    1fe8:	88 23       	and	r24, r24
    1fea:	09 f4       	brne	.+2      	; 0x1fee <main+0xf6>
    1fec:	62 c0       	rjmp	.+196    	; 0x20b2 <main+0x1ba>
					{
					
						break;   
					}
					if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
    1fee:	85 3e       	cpi	r24, 0xE5	; 229
    1ff0:	09 f4       	brne	.+2      	; 0x1ff4 <main+0xfc>
    1ff2:	53 c0       	rjmp	.+166    	; 0x209a <main+0x1a2>
    1ff4:	8b 85       	ldd	r24, Y+11	; 0x0b
    1ff6:	8f 30       	cpi	r24, 0x0F	; 15
    1ff8:	09 f4       	brne	.+2      	; 0x1ffc <main+0x104>
    1ffa:	4f c0       	rjmp	.+158    	; 0x209a <main+0x1a2>
    1ffc:	20 e0       	ldi	r18, 0x00	; 0
    1ffe:	30 e0       	ldi	r19, 0x00	; 0
					{
					
						for(j=0; j<11; j++)
						{
							CURR_FILE[j] = dir->name[j];
    2000:	f9 01       	movw	r30, r18
    2002:	eb 57       	subi	r30, 0x7B	; 123
    2004:	fc 4f       	sbci	r31, 0xFC	; 252
    2006:	de 01       	movw	r26, r28
    2008:	a2 0f       	add	r26, r18
    200a:	b3 1f       	adc	r27, r19
    200c:	8c 91       	ld	r24, X
    200e:	80 83       	st	Z, r24
    2010:	2f 5f       	subi	r18, 0xFF	; 255
    2012:	3f 4f       	sbci	r19, 0xFF	; 255
						break;   
					}
					if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
					{
					
						for(j=0; j<11; j++)
    2014:	2b 30       	cpi	r18, 0x0B	; 11
    2016:	31 05       	cpc	r19, r1
    2018:	99 f7       	brne	.-26     	; 0x2000 <main+0x108>

						// Get KEY options HERE
						
					
				//	LCD_clear();
					LCD_DisplayString_F(1,1,CURR_FILE);
    201a:	81 e0       	ldi	r24, 0x01	; 1
    201c:	61 e0       	ldi	r22, 0x01	; 1
    201e:	45 e8       	ldi	r20, 0x85	; 133
    2020:	53 e0       	ldi	r21, 0x03	; 3
    2022:	0e 94 41 1c 	call	0x3882	; 0x3882 <LCD_DisplayString_F>
					LCD_DisplayString_F(2,1,"Play List...    ");
    2026:	82 e0       	ldi	r24, 0x02	; 2
    2028:	61 e0       	ldi	r22, 0x01	; 1
    202a:	4c ef       	ldi	r20, 0xFC	; 252
    202c:	50 e0       	ldi	r21, 0x00	; 0
    202e:	0e 94 41 1c 	call	0x3882	; 0x3882 <LCD_DisplayString_F>

						while(1)
						{

							if(KEY1_PRESSED/*option == '1'*/)
    2032:	9e 99       	sbic	0x13, 6	; 19
    2034:	25 c0       	rjmp	.+74     	; 0x2080 <main+0x188>
    2036:	88 ee       	ldi	r24, 0xE8	; 232
    2038:	93 e0       	ldi	r25, 0x03	; 3
    203a:	f1 01       	movw	r30, r2
    203c:	31 97       	sbiw	r30, 0x01	; 1
    203e:	f1 f7       	brne	.-4      	; 0x203c <main+0x144>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2040:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2042:	d9 f7       	brne	.-10     	; 0x203a <main+0x142>
							{
								_delay_ms(100);

								while(KEY1_PRESSED);
    2044:	9e 9b       	sbis	0x13, 6	; 19
    2046:	fe cf       	rjmp	.-4      	; 0x2044 <main+0x14c>
								// PLAY CURR_FILE (NEW)

								
								LCD_clear();
    2048:	0e 94 55 0e 	call	0x1caa	; 0x1caa <LCD_clear>
								LCD_DisplayString_F(1,1,CURR_FILE);
    204c:	81 e0       	ldi	r24, 0x01	; 1
    204e:	61 e0       	ldi	r22, 0x01	; 1
    2050:	45 e8       	ldi	r20, 0x85	; 133
    2052:	53 e0       	ldi	r21, 0x03	; 3
    2054:	0e 94 41 1c 	call	0x3882	; 0x3882 <LCD_DisplayString_F>
								LCD_DisplayString_F(2,1,"Playing...      ");
    2058:	82 e0       	ldi	r24, 0x02	; 2
    205a:	61 e0       	ldi	r22, 0x01	; 1
    205c:	4d e9       	ldi	r20, 0x9D	; 157
    205e:	50 e0       	ldi	r21, 0x00	; 0
    2060:	0e 94 41 1c 	call	0x3882	; 0x3882 <LCD_DisplayString_F>

								STOPPED = 0;
    2064:	10 92 58 01 	sts	0x0158, r1

								PLAY_SONG(CURR_FILE);
    2068:	85 e8       	ldi	r24, 0x85	; 133
    206a:	93 e0       	ldi	r25, 0x03	; 3
    206c:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <PLAY_SONG>

								LCD_clear();
    2070:	0e 94 55 0e 	call	0x1caa	; 0x1caa <LCD_clear>

								if(STOPPED)
    2074:	80 91 58 01 	lds	r24, 0x0158
    2078:	88 23       	and	r24, r24
    207a:	09 f0       	breq	.+2      	; 0x207e <main+0x186>
    207c:	94 cf       	rjmp	.-216    	; 0x1fa6 <main+0xae>
    207e:	0d c0       	rjmp	.+26     	; 0x209a <main+0x1a2>
										
								
								break;
							}

							if(KEY2_PRESSED/*option =='2'*/)
    2080:	9f 99       	sbic	0x13, 7	; 19
    2082:	d7 cf       	rjmp	.-82     	; 0x2032 <main+0x13a>
    2084:	88 ee       	ldi	r24, 0xE8	; 232
    2086:	93 e0       	ldi	r25, 0x03	; 3
    2088:	f1 01       	movw	r30, r2
    208a:	31 97       	sbiw	r30, 0x01	; 1
    208c:	f1 f7       	brne	.-4      	; 0x208a <main+0x192>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    208e:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2090:	d9 f7       	brne	.-10     	; 0x2088 <main+0x190>
							{
								_delay_ms(100);
								while(KEY2_PRESSED);
    2092:	9f 9b       	sbis	0x13, 7	; 19
    2094:	fe cf       	rjmp	.-4      	; 0x2092 <main+0x19a>
								LCD_clear();
    2096:	0e 94 55 0e 	call	0x1caa	; 0x1caa <LCD_clear>
			for(sector = 0; sector < sectorPerCluster; sector++)
			{
				SD_readSingleBlock (firstSector + sector);
	

				for(i=0; i<bytesPerSector; i+=32)
    209a:	80 e2       	ldi	r24, 0x20	; 32
    209c:	90 e0       	ldi	r25, 0x00	; 0
    209e:	88 0e       	add	r8, r24
    20a0:	99 1e       	adc	r9, r25
    20a2:	80 91 65 01 	lds	r24, 0x0165
    20a6:	90 91 66 01 	lds	r25, 0x0166
    20aa:	88 16       	cp	r8, r24
    20ac:	99 06       	cpc	r9, r25
    20ae:	08 f4       	brcc	.+2      	; 0x20b2 <main+0x1ba>
    20b0:	97 cf       	rjmp	.-210    	; 0x1fe0 <main+0xe8>

		while(1)
		{
			firstSector = getFirstSector (cluster);

			for(sector = 0; sector < sectorPerCluster; sector++)
    20b2:	08 94       	sec
    20b4:	e1 1c       	adc	r14, r1
    20b6:	f1 1c       	adc	r15, r1
    20b8:	01 1d       	adc	r16, r1
    20ba:	11 1d       	adc	r17, r1
    20bc:	80 91 73 03 	lds	r24, 0x0373
    20c0:	90 91 74 03 	lds	r25, 0x0374
    20c4:	a0 e0       	ldi	r26, 0x00	; 0
    20c6:	b0 e0       	ldi	r27, 0x00	; 0
    20c8:	e8 16       	cp	r14, r24
    20ca:	f9 06       	cpc	r15, r25
    20cc:	0a 07       	cpc	r16, r26
    20ce:	1b 07       	cpc	r17, r27
    20d0:	08 f4       	brcc	.+2      	; 0x20d4 <main+0x1dc>
    20d2:	7b cf       	rjmp	.-266    	; 0x1fca <main+0xd2>
				}
			}

		

			if(!STOPPED)
    20d4:	80 91 58 01 	lds	r24, 0x0158
    20d8:	88 23       	and	r24, r24
    20da:	09 f0       	breq	.+2      	; 0x20de <main+0x1e6>
    20dc:	6c cf       	rjmp	.-296    	; 0x1fb6 <main+0xbe>
			{		
				if(cluster > 0x0ffffff6)
    20de:	97 ef       	ldi	r25, 0xF7	; 247
    20e0:	a9 16       	cp	r10, r25
    20e2:	9f ef       	ldi	r25, 0xFF	; 255
    20e4:	b9 06       	cpc	r11, r25
    20e6:	9f ef       	ldi	r25, 0xFF	; 255
    20e8:	c9 06       	cpc	r12, r25
    20ea:	9f e0       	ldi	r25, 0x0F	; 15
    20ec:	d9 06       	cpc	r13, r25
    20ee:	a0 f4       	brcc	.+40     	; 0x2118 <main+0x220>
				{ break;} 
				if(cluster == 0) 
    20f0:	a1 14       	cp	r10, r1
    20f2:	b1 04       	cpc	r11, r1
    20f4:	c1 04       	cpc	r12, r1
    20f6:	d1 04       	cpc	r13, r1
    20f8:	09 f0       	breq	.+2      	; 0x20fc <main+0x204>
    20fa:	5d cf       	rjmp	.-326    	; 0x1fb6 <main+0xbe>
				{
					LCD_clear();
    20fc:	0e 94 55 0e 	call	0x1caa	; 0x1caa <LCD_clear>
					LCD_DisplayString_F(1,1," Cluster ERROR  ");
    2100:	81 e0       	ldi	r24, 0x01	; 1
    2102:	61 e0       	ldi	r22, 0x01	; 1
    2104:	4d e0       	ldi	r20, 0x0D	; 13
    2106:	51 e0       	ldi	r21, 0x01	; 1
    2108:	0e 94 41 1c 	call	0x3882	; 0x3882 <LCD_DisplayString_F>
					LCD_DisplayString_F(2,1,"  ???????????  ");
    210c:	82 e0       	ldi	r24, 0x02	; 2
    210e:	61 e0       	ldi	r22, 0x01	; 1
    2110:	4e e1       	ldi	r20, 0x1E	; 30
    2112:	51 e0       	ldi	r21, 0x01	; 1
    2114:	0e 94 41 1c 	call	0x3882	; 0x3882 <LCD_DisplayString_F>
    2118:	20 e2       	ldi	r18, 0x20	; 32
    211a:	3e e4       	ldi	r19, 0x4E	; 78
    211c:	3a cf       	rjmp	.-396    	; 0x1f92 <main+0x9a>

0000211e <getFirstSector>:
//Function: to calculate first sector address of any given cluster
//Arguments: cluster number for which first sector is to be found
//return: first sector address
//***************************************************************************
unsigned long getFirstSector(unsigned long clusterNumber)
{
    211e:	ef 92       	push	r14
    2120:	ff 92       	push	r15
    2122:	0f 93       	push	r16
    2124:	1f 93       	push	r17
  return (((clusterNumber - 2) * sectorPerCluster) + firstDataSector);
    2126:	20 91 73 03 	lds	r18, 0x0373
    212a:	30 91 74 03 	lds	r19, 0x0374
    212e:	e0 90 5d 01 	lds	r14, 0x015D
    2132:	f0 90 5e 01 	lds	r15, 0x015E
    2136:	00 91 5f 01 	lds	r16, 0x015F
    213a:	10 91 60 01 	lds	r17, 0x0160
    213e:	62 50       	subi	r22, 0x02	; 2
    2140:	70 40       	sbci	r23, 0x00	; 0
    2142:	80 40       	sbci	r24, 0x00	; 0
    2144:	90 40       	sbci	r25, 0x00	; 0
    2146:	40 e0       	ldi	r20, 0x00	; 0
    2148:	50 e0       	ldi	r21, 0x00	; 0
    214a:	0e 94 ac 1e 	call	0x3d58	; 0x3d58 <__mulsi3>
    214e:	9b 01       	movw	r18, r22
    2150:	ac 01       	movw	r20, r24
    2152:	2e 0d       	add	r18, r14
    2154:	3f 1d       	adc	r19, r15
    2156:	40 1f       	adc	r20, r16
    2158:	51 1f       	adc	r21, r17
}
    215a:	b9 01       	movw	r22, r18
    215c:	ca 01       	movw	r24, r20
    215e:	1f 91       	pop	r17
    2160:	0f 91       	pop	r16
    2162:	ff 90       	pop	r15
    2164:	ef 90       	pop	r14
    2166:	08 95       	ret

00002168 <displayMemory>:
//Arguments: 1. unsigned char flag. If flag is HIGH, memory will be displayed in KBytes, else in Bytes. 
//			 2. unsigned long memory value
//return: none
//************************************************************
void displayMemory (unsigned char flag, unsigned long memory)
{
    2168:	8f 92       	push	r8
    216a:	9f 92       	push	r9
    216c:	af 92       	push	r10
    216e:	bf 92       	push	r11
    2170:	cf 92       	push	r12
    2172:	df 92       	push	r13
    2174:	ef 92       	push	r14
    2176:	ff 92       	push	r15
    2178:	0f 93       	push	r16
    217a:	df 93       	push	r29
    217c:	cf 93       	push	r28
    217e:	cd b7       	in	r28, 0x3d	; 61
    2180:	de b7       	in	r29, 0x3e	; 62
    2182:	64 97       	sbiw	r28, 0x14	; 20
    2184:	0f b6       	in	r0, 0x3f	; 63
    2186:	f8 94       	cli
    2188:	de bf       	out	0x3e, r29	; 62
    218a:	0f be       	out	0x3f, r0	; 63
    218c:	cd bf       	out	0x3d, r28	; 61
    218e:	98 2e       	mov	r9, r24
    2190:	6a 01       	movw	r12, r20
    2192:	7b 01       	movw	r14, r22
  unsigned char memoryString[] = "              Bytes"; //19 character long string for memory display
    2194:	de 01       	movw	r26, r28
    2196:	11 96       	adiw	r26, 0x01	; 1
    2198:	ee e2       	ldi	r30, 0x2E	; 46
    219a:	f1 e0       	ldi	r31, 0x01	; 1
    219c:	84 e1       	ldi	r24, 0x14	; 20
    219e:	01 90       	ld	r0, Z+
    21a0:	0d 92       	st	X+, r0
    21a2:	81 50       	subi	r24, 0x01	; 1
    21a4:	e1 f7       	brne	.-8      	; 0x219e <displayMemory+0x36>
    21a6:	0c e0       	ldi	r16, 0x0C	; 12
  unsigned char i;
  for(i=12; i>0; i--) //converting freeMemory into ASCII string
  {
    if(i==5 || i==9) 
	{
	   memoryString[i-1] = ',';  
    21a8:	8c e2       	ldi	r24, 0x2C	; 44
    21aa:	88 2e       	mov	r8, r24
{
  unsigned char memoryString[] = "              Bytes"; //19 character long string for memory display
  unsigned char i;
  for(i=12; i>0; i--) //converting freeMemory into ASCII string
  {
    if(i==5 || i==9) 
    21ac:	05 30       	cpi	r16, 0x05	; 5
    21ae:	11 f0       	breq	.+4      	; 0x21b4 <displayMemory+0x4c>
    21b0:	09 30       	cpi	r16, 0x09	; 9
    21b2:	29 f4       	brne	.+10     	; 0x21be <displayMemory+0x56>
	{
	   memoryString[i-1] = ',';  
    21b4:	fe 01       	movw	r30, r28
    21b6:	e0 0f       	add	r30, r16
    21b8:	f1 1d       	adc	r31, r1
    21ba:	80 82       	st	Z, r8
	   i--;
    21bc:	01 50       	subi	r16, 0x01	; 1
	}
    memoryString[i-1] = (memory % 10) | 0x30;
    21be:	5e 01       	movw	r10, r28
    21c0:	a0 0e       	add	r10, r16
    21c2:	b1 1c       	adc	r11, r1
    21c4:	c7 01       	movw	r24, r14
    21c6:	b6 01       	movw	r22, r12
    21c8:	2a e0       	ldi	r18, 0x0A	; 10
    21ca:	30 e0       	ldi	r19, 0x00	; 0
    21cc:	40 e0       	ldi	r20, 0x00	; 0
    21ce:	50 e0       	ldi	r21, 0x00	; 0
    21d0:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <__udivmodsi4>
    21d4:	60 63       	ori	r22, 0x30	; 48
    21d6:	f5 01       	movw	r30, r10
    21d8:	60 83       	st	Z, r22
    memory /= 10;
    21da:	c7 01       	movw	r24, r14
    21dc:	b6 01       	movw	r22, r12
    21de:	2a e0       	ldi	r18, 0x0A	; 10
    21e0:	30 e0       	ldi	r19, 0x00	; 0
    21e2:	40 e0       	ldi	r20, 0x00	; 0
    21e4:	50 e0       	ldi	r21, 0x00	; 0
    21e6:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <__udivmodsi4>
    21ea:	c9 01       	movw	r24, r18
    21ec:	da 01       	movw	r26, r20
    21ee:	6c 01       	movw	r12, r24
    21f0:	7d 01       	movw	r14, r26
	if(memory == 0) break;
    21f2:	c1 14       	cp	r12, r1
    21f4:	d1 04       	cpc	r13, r1
    21f6:	e1 04       	cpc	r14, r1
    21f8:	f1 04       	cpc	r15, r1
    21fa:	11 f0       	breq	.+4      	; 0x2200 <displayMemory+0x98>
//************************************************************
void displayMemory (unsigned char flag, unsigned long memory)
{
  unsigned char memoryString[] = "              Bytes"; //19 character long string for memory display
  unsigned char i;
  for(i=12; i>0; i--) //converting freeMemory into ASCII string
    21fc:	01 50       	subi	r16, 0x01	; 1
    21fe:	b1 f6       	brne	.-84     	; 0x21ac <displayMemory+0x44>
	}
    memoryString[i-1] = (memory % 10) | 0x30;
    memory /= 10;
	if(memory == 0) break;
  }
  if(flag == HIGH)  memoryString[13] = 'K';
    2200:	f1 e0       	ldi	r31, 0x01	; 1
    2202:	9f 16       	cp	r9, r31
    2204:	11 f4       	brne	.+4      	; 0x220a <displayMemory+0xa2>
    2206:	8b e4       	ldi	r24, 0x4B	; 75
    2208:	8e 87       	std	Y+14, r24	; 0x0e
  transmitString(memoryString);
    220a:	ce 01       	movw	r24, r28
    220c:	01 96       	adiw	r24, 0x01	; 1
    220e:	0e 94 4d 1e 	call	0x3c9a	; 0x3c9a <transmitString>
}
    2212:	64 96       	adiw	r28, 0x14	; 20
    2214:	0f b6       	in	r0, 0x3f	; 63
    2216:	f8 94       	cli
    2218:	de bf       	out	0x3e, r29	; 62
    221a:	0f be       	out	0x3f, r0	; 63
    221c:	cd bf       	out	0x3d, r28	; 61
    221e:	cf 91       	pop	r28
    2220:	df 91       	pop	r29
    2222:	0f 91       	pop	r16
    2224:	ff 90       	pop	r15
    2226:	ef 90       	pop	r14
    2228:	df 90       	pop	r13
    222a:	cf 90       	pop	r12
    222c:	bf 90       	pop	r11
    222e:	af 90       	pop	r10
    2230:	9f 90       	pop	r9
    2232:	8f 90       	pop	r8
    2234:	08 95       	ret

00002236 <convertFileName>:
//Function: to convert normal short file name into FAT format
//Arguments: pointer to the file name
//return: 0, if successful else 1.
//***************************************************************************
unsigned char convertFileName (unsigned char *fileName)
{
    2236:	0f 93       	push	r16
    2238:	1f 93       	push	r17
    223a:	df 93       	push	r29
    223c:	cf 93       	push	r28
    223e:	cd b7       	in	r28, 0x3d	; 61
    2240:	de b7       	in	r29, 0x3e	; 62
    2242:	2b 97       	sbiw	r28, 0x0b	; 11
    2244:	0f b6       	in	r0, 0x3f	; 63
    2246:	f8 94       	cli
    2248:	de bf       	out	0x3e, r29	; 62
    224a:	0f be       	out	0x3f, r0	; 63
    224c:	cd bf       	out	0x3d, r28	; 61
    224e:	8c 01       	movw	r16, r24
    2250:	58 2f       	mov	r21, r24
    2252:	a1 2f       	mov	r26, r17
    2254:	fc 01       	movw	r30, r24
    2256:	40 e0       	ldi	r20, 0x00	; 0
	unsigned char fileNameFAT[11];
	unsigned char j, k;

	for(j=0; j<12; j++)
	if(fileName[j] == '.') break;
    2258:	80 81       	ld	r24, Z
    225a:	8e 32       	cpi	r24, 0x2E	; 46
    225c:	19 f4       	brne	.+6      	; 0x2264 <convertFileName+0x2e>

	if(j>8) {transmitString_F(PSTR("Invalid fileName..")); return 1;}
    225e:	49 30       	cpi	r20, 0x09	; 9
    2260:	30 f0       	brcs	.+12     	; 0x226e <convertFileName+0x38>
    2262:	0e c0       	rjmp	.+28     	; 0x2280 <convertFileName+0x4a>
unsigned char convertFileName (unsigned char *fileName)
{
	unsigned char fileNameFAT[11];
	unsigned char j, k;

	for(j=0; j<12; j++)
    2264:	4f 5f       	subi	r20, 0xFF	; 255
    2266:	31 96       	adiw	r30, 0x01	; 1
    2268:	4c 30       	cpi	r20, 0x0C	; 12
    226a:	b1 f7       	brne	.-20     	; 0x2258 <convertFileName+0x22>
    226c:	09 c0       	rjmp	.+18     	; 0x2280 <convertFileName+0x4a>
    226e:	be 01       	movw	r22, r28
    2270:	6f 5f       	subi	r22, 0xFF	; 255
    2272:	7f 4f       	sbci	r23, 0xFF	; 255
    2274:	85 2f       	mov	r24, r21
    2276:	9a 2f       	mov	r25, r26
    2278:	9c 01       	movw	r18, r24
    227a:	f9 01       	movw	r30, r18
    227c:	db 01       	movw	r26, r22
    227e:	08 c0       	rjmp	.+16     	; 0x2290 <convertFileName+0x5a>
	if(fileName[j] == '.') break;

	if(j>8) {transmitString_F(PSTR("Invalid fileName..")); return 1;}
    2280:	88 e3       	ldi	r24, 0x38	; 56
    2282:	91 e0       	ldi	r25, 0x01	; 1
    2284:	0e 94 43 1e 	call	0x3c86	; 0x3c86 <transmitString_F>
    2288:	81 e0       	ldi	r24, 0x01	; 1
    228a:	52 c0       	rjmp	.+164    	; 0x2330 <convertFileName+0xfa>

	for(k=0; k<j; k++) //setting file name
	  fileNameFAT[k] = fileName[k];
    228c:	81 91       	ld	r24, Z+
    228e:	8d 93       	st	X+, r24
	for(j=0; j<12; j++)
	if(fileName[j] == '.') break;

	if(j>8) {transmitString_F(PSTR("Invalid fileName..")); return 1;}

	for(k=0; k<j; k++) //setting file name
    2290:	8e 2f       	mov	r24, r30
    2292:	85 1b       	sub	r24, r21
    2294:	84 17       	cp	r24, r20
    2296:	d0 f3       	brcs	.-12     	; 0x228c <convertFileName+0x56>
    2298:	84 2f       	mov	r24, r20
	  fileNameFAT[k] = fileName[k];

	for(k=j; k<=7; k++) //filling file name trail with blanks
	  fileNameFAT[k] = ' ';
    229a:	9e 01       	movw	r18, r28
    229c:	2f 5f       	subi	r18, 0xFF	; 255
    229e:	3f 4f       	sbci	r19, 0xFF	; 255
    22a0:	90 e2       	ldi	r25, 0x20	; 32
    22a2:	05 c0       	rjmp	.+10     	; 0x22ae <convertFileName+0x78>
    22a4:	f9 01       	movw	r30, r18
    22a6:	e8 0f       	add	r30, r24
    22a8:	f1 1d       	adc	r31, r1
    22aa:	90 83       	st	Z, r25
	if(j>8) {transmitString_F(PSTR("Invalid fileName..")); return 1;}

	for(k=0; k<j; k++) //setting file name
	  fileNameFAT[k] = fileName[k];

	for(k=j; k<=7; k++) //filling file name trail with blanks
    22ac:	8f 5f       	subi	r24, 0xFF	; 255
    22ae:	88 30       	cpi	r24, 0x08	; 8
    22b0:	c9 f7       	brne	.-14     	; 0x22a4 <convertFileName+0x6e>
	  fileNameFAT[k] = ' ';

	j++;
    22b2:	24 2f       	mov	r18, r20
    22b4:	2f 5f       	subi	r18, 0xFF	; 255
	{
	  if(fileName[j] != 0)
	    fileNameFAT[k] = fileName[j++];
	  else //filling extension trail with blanks
	    while(k<11)
	      fileNameFAT[k++] = ' ';
    22b6:	ae 01       	movw	r20, r28
    22b8:	4f 5f       	subi	r20, 0xFF	; 255
    22ba:	5f 4f       	sbci	r21, 0xFF	; 255
    22bc:	30 e2       	ldi	r19, 0x20	; 32
	  fileNameFAT[k] = ' ';

	j++;
	for(k=8; k<11; k++) //setting file extention
	{
	  if(fileName[j] != 0)
    22be:	f8 01       	movw	r30, r16
    22c0:	e2 0f       	add	r30, r18
    22c2:	f1 1d       	adc	r31, r1
    22c4:	90 81       	ld	r25, Z
    22c6:	99 23       	and	r25, r25
    22c8:	59 f0       	breq	.+22     	; 0x22e0 <convertFileName+0xaa>
	    fileNameFAT[k] = fileName[j++];
    22ca:	fa 01       	movw	r30, r20
    22cc:	e8 0f       	add	r30, r24
    22ce:	f1 1d       	adc	r31, r1
    22d0:	90 83       	st	Z, r25
    22d2:	2f 5f       	subi	r18, 0xFF	; 255
    22d4:	07 c0       	rjmp	.+14     	; 0x22e4 <convertFileName+0xae>
	  else //filling extension trail with blanks
	    while(k<11)
	      fileNameFAT[k++] = ' ';
    22d6:	fa 01       	movw	r30, r20
    22d8:	e8 0f       	add	r30, r24
    22da:	f1 1d       	adc	r31, r1
    22dc:	30 83       	st	Z, r19
    22de:	8f 5f       	subi	r24, 0xFF	; 255
	for(k=8; k<11; k++) //setting file extention
	{
	  if(fileName[j] != 0)
	    fileNameFAT[k] = fileName[j++];
	  else //filling extension trail with blanks
	    while(k<11)
    22e0:	8b 30       	cpi	r24, 0x0B	; 11
    22e2:	c8 f3       	brcs	.-14     	; 0x22d6 <convertFileName+0xa0>

	for(k=j; k<=7; k++) //filling file name trail with blanks
	  fileNameFAT[k] = ' ';

	j++;
	for(k=8; k<11; k++) //setting file extention
    22e4:	8f 5f       	subi	r24, 0xFF	; 255
    22e6:	8b 30       	cpi	r24, 0x0B	; 11
    22e8:	50 f3       	brcs	.-44     	; 0x22be <convertFileName+0x88>
	  else //filling extension trail with blanks
	    while(k<11)
	      fileNameFAT[k++] = ' ';
	}

	for(j=0; j<11; j++) //converting small letters to caps
    22ea:	9e 01       	movw	r18, r28
    22ec:	24 5f       	subi	r18, 0xF4	; 244
    22ee:	3f 4f       	sbci	r19, 0xFF	; 255
	  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
    22f0:	fb 01       	movw	r30, r22
    22f2:	90 81       	ld	r25, Z
    22f4:	89 2f       	mov	r24, r25
    22f6:	81 56       	subi	r24, 0x61	; 97
    22f8:	8a 31       	cpi	r24, 0x1A	; 26
    22fa:	10 f4       	brcc	.+4      	; 0x2300 <convertFileName+0xca>
	    fileNameFAT[j] -= 0x20;
    22fc:	90 52       	subi	r25, 0x20	; 32
    22fe:	90 83       	st	Z, r25
    2300:	6f 5f       	subi	r22, 0xFF	; 255
    2302:	7f 4f       	sbci	r23, 0xFF	; 255
	  else //filling extension trail with blanks
	    while(k<11)
	      fileNameFAT[k++] = ' ';
	}

	for(j=0; j<11; j++) //converting small letters to caps
    2304:	62 17       	cp	r22, r18
    2306:	73 07       	cpc	r23, r19
    2308:	99 f7       	brne	.-26     	; 0x22f0 <convertFileName+0xba>
    230a:	20 e0       	ldi	r18, 0x00	; 0
    230c:	30 e0       	ldi	r19, 0x00	; 0
	  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
	    fileNameFAT[j] -= 0x20;

	for(j=0; j<11; j++)
	  fileName[j] = fileNameFAT[j];
    230e:	ae 01       	movw	r20, r28
    2310:	4f 5f       	subi	r20, 0xFF	; 255
    2312:	5f 4f       	sbci	r21, 0xFF	; 255
    2314:	f8 01       	movw	r30, r16
    2316:	e2 0f       	add	r30, r18
    2318:	f3 1f       	adc	r31, r19
    231a:	da 01       	movw	r26, r20
    231c:	a2 0f       	add	r26, r18
    231e:	b3 1f       	adc	r27, r19
    2320:	8c 91       	ld	r24, X
    2322:	80 83       	st	Z, r24
    2324:	2f 5f       	subi	r18, 0xFF	; 255
    2326:	3f 4f       	sbci	r19, 0xFF	; 255

	for(j=0; j<11; j++) //converting small letters to caps
	  if((fileNameFAT[j] >= 0x61) && (fileNameFAT[j] <= 0x7a))
	    fileNameFAT[j] -= 0x20;

	for(j=0; j<11; j++)
    2328:	2b 30       	cpi	r18, 0x0B	; 11
    232a:	31 05       	cpc	r19, r1
    232c:	99 f7       	brne	.-26     	; 0x2314 <convertFileName+0xde>
    232e:	80 e0       	ldi	r24, 0x00	; 0
	  fileName[j] = fileNameFAT[j];

	return 0;
}
    2330:	2b 96       	adiw	r28, 0x0b	; 11
    2332:	0f b6       	in	r0, 0x3f	; 63
    2334:	f8 94       	cli
    2336:	de bf       	out	0x3e, r29	; 62
    2338:	0f be       	out	0x3f, r0	; 63
    233a:	cd bf       	out	0x3d, r28	; 61
    233c:	cf 91       	pop	r28
    233e:	df 91       	pop	r29
    2340:	1f 91       	pop	r17
    2342:	0f 91       	pop	r16
    2344:	08 95       	ret

00002346 <searchNextFreeCluster>:
//          starting from a specified cluster
//Arguments: Starting cluster
//return: the next free cluster
//****************************************************************
unsigned long searchNextFreeCluster (unsigned long startCluster)
{
    2346:	6f 92       	push	r6
    2348:	7f 92       	push	r7
    234a:	8f 92       	push	r8
    234c:	9f 92       	push	r9
    234e:	af 92       	push	r10
    2350:	bf 92       	push	r11
    2352:	cf 92       	push	r12
    2354:	df 92       	push	r13
    2356:	ef 92       	push	r14
    2358:	ff 92       	push	r15
    235a:	0f 93       	push	r16
    235c:	1f 93       	push	r17
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    235e:	60 78       	andi	r22, 0x80	; 128
    2360:	3b 01       	movw	r6, r22
    2362:	4c 01       	movw	r8, r24
    2364:	22 e0       	ldi	r18, 0x02	; 2
    2366:	66 0c       	add	r6, r6
    2368:	77 1c       	adc	r7, r7
    236a:	88 1c       	adc	r8, r8
    236c:	99 1c       	adc	r9, r9
    236e:	2a 95       	dec	r18
    2370:	d1 f7       	brne	.-12     	; 0x2366 <searchNextFreeCluster+0x20>
    2372:	5b 01       	movw	r10, r22
    2374:	6c 01       	movw	r12, r24
    2376:	50 c0       	rjmp	.+160    	; 0x2418 <searchNextFreeCluster+0xd2>
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
    2378:	e0 90 7e 03 	lds	r14, 0x037E
    237c:	f0 90 7f 03 	lds	r15, 0x037F
    2380:	20 91 65 01 	lds	r18, 0x0165
    2384:	30 91 66 01 	lds	r19, 0x0166
      SD_readSingleBlock(sector);
    2388:	00 e0       	ldi	r16, 0x00	; 0
    238a:	10 e0       	ldi	r17, 0x00	; 0
    238c:	80 91 75 03 	lds	r24, 0x0375
    2390:	90 91 76 03 	lds	r25, 0x0376
    2394:	a0 91 77 03 	lds	r26, 0x0377
    2398:	b0 91 78 03 	lds	r27, 0x0378
    239c:	e8 0e       	add	r14, r24
    239e:	f9 1e       	adc	r15, r25
    23a0:	0a 1f       	adc	r16, r26
    23a2:	1b 1f       	adc	r17, r27
    23a4:	40 e0       	ldi	r20, 0x00	; 0
    23a6:	50 e0       	ldi	r21, 0x00	; 0
    23a8:	c4 01       	movw	r24, r8
    23aa:	b3 01       	movw	r22, r6
    23ac:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <__udivmodsi4>
    23b0:	e2 0e       	add	r14, r18
    23b2:	f3 1e       	adc	r15, r19
    23b4:	04 1f       	adc	r16, r20
    23b6:	15 1f       	adc	r17, r21
    23b8:	c8 01       	movw	r24, r16
    23ba:	b7 01       	movw	r22, r14
    23bc:	0e 94 71 1d 	call	0x3ae2	; 0x3ae2 <SD_readSingleBlock>
    23c0:	60 e0       	ldi	r22, 0x00	; 0
      for(i=0; i<128; i++)
      {
       	 value = (unsigned long *) &buffer[i*4];
         if(((*value) & 0x0fffffff) == 0)
    23c2:	e6 2f       	mov	r30, r22
    23c4:	f0 e0       	ldi	r31, 0x00	; 0
    23c6:	ee 0f       	add	r30, r30
    23c8:	ff 1f       	adc	r31, r31
    23ca:	ee 0f       	add	r30, r30
    23cc:	ff 1f       	adc	r31, r31
    23ce:	ed 58       	subi	r30, 0x8D	; 141
    23d0:	fe 4f       	sbci	r31, 0xFE	; 254
    23d2:	80 81       	ld	r24, Z
    23d4:	91 81       	ldd	r25, Z+1	; 0x01
    23d6:	a2 81       	ldd	r26, Z+2	; 0x02
    23d8:	b3 81       	ldd	r27, Z+3	; 0x03
    23da:	bf 70       	andi	r27, 0x0F	; 15
    23dc:	00 97       	sbiw	r24, 0x00	; 0
    23de:	a1 05       	cpc	r26, r1
    23e0:	b1 05       	cpc	r27, r1
    23e2:	39 f4       	brne	.+14     	; 0x23f2 <searchNextFreeCluster+0xac>
            return(cluster+i);
    23e4:	a6 01       	movw	r20, r12
    23e6:	95 01       	movw	r18, r10
    23e8:	26 0f       	add	r18, r22
    23ea:	31 1d       	adc	r19, r1
    23ec:	41 1d       	adc	r20, r1
    23ee:	51 1d       	adc	r21, r1
    23f0:	25 c0       	rjmp	.+74     	; 0x243c <searchNextFreeCluster+0xf6>
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);
      SD_readSingleBlock(sector);
      for(i=0; i<128; i++)
    23f2:	6f 5f       	subi	r22, 0xFF	; 255
    23f4:	60 38       	cpi	r22, 0x80	; 128
    23f6:	29 f7       	brne	.-54     	; 0x23c2 <searchNextFreeCluster+0x7c>
{
  unsigned long cluster, *value, sector;
  unsigned char i;
    
	startCluster -=  (startCluster % 128);   //to start with the first file in a FAT sector
    for(cluster =startCluster; cluster <totalClusters; cluster+=128) 
    23f8:	80 e8       	ldi	r24, 0x80	; 128
    23fa:	90 e0       	ldi	r25, 0x00	; 0
    23fc:	a0 e0       	ldi	r26, 0x00	; 0
    23fe:	b0 e0       	ldi	r27, 0x00	; 0
    2400:	a8 0e       	add	r10, r24
    2402:	b9 1e       	adc	r11, r25
    2404:	ca 1e       	adc	r12, r26
    2406:	db 1e       	adc	r13, r27
    2408:	80 e0       	ldi	r24, 0x00	; 0
    240a:	92 e0       	ldi	r25, 0x02	; 2
    240c:	a0 e0       	ldi	r26, 0x00	; 0
    240e:	b0 e0       	ldi	r27, 0x00	; 0
    2410:	68 0e       	add	r6, r24
    2412:	79 1e       	adc	r7, r25
    2414:	8a 1e       	adc	r8, r26
    2416:	9b 1e       	adc	r9, r27
    2418:	80 91 67 01 	lds	r24, 0x0167
    241c:	90 91 68 01 	lds	r25, 0x0168
    2420:	a0 91 69 01 	lds	r26, 0x0169
    2424:	b0 91 6a 01 	lds	r27, 0x016A
    2428:	a8 16       	cp	r10, r24
    242a:	b9 06       	cpc	r11, r25
    242c:	ca 06       	cpc	r12, r26
    242e:	db 06       	cpc	r13, r27
    2430:	08 f4       	brcc	.+2      	; 0x2434 <searchNextFreeCluster+0xee>
    2432:	a2 cf       	rjmp	.-188    	; 0x2378 <searchNextFreeCluster+0x32>
    2434:	20 e0       	ldi	r18, 0x00	; 0
    2436:	30 e0       	ldi	r19, 0x00	; 0
    2438:	40 e0       	ldi	r20, 0x00	; 0
    243a:	50 e0       	ldi	r21, 0x00	; 0
            return(cluster+i);
      }  
    } 

 return 0;
}
    243c:	b9 01       	movw	r22, r18
    243e:	ca 01       	movw	r24, r20
    2440:	1f 91       	pop	r17
    2442:	0f 91       	pop	r16
    2444:	ff 90       	pop	r15
    2446:	ef 90       	pop	r14
    2448:	df 90       	pop	r13
    244a:	cf 90       	pop	r12
    244c:	bf 90       	pop	r11
    244e:	af 90       	pop	r10
    2450:	9f 90       	pop	r9
    2452:	8f 90       	pop	r8
    2454:	7f 90       	pop	r7
    2456:	6f 90       	pop	r6
    2458:	08 95       	ret

0000245a <getSetFreeCluster>:
//return: next free cluster, if arg1 is NEXT_FREE & arg2 is GET
//        total number of free clusters, if arg1 is TOTAL_FREE & arg2 is GET
//		  0xffffffff, if any error or if arg2 is SET
//********************************************************************************************
unsigned long getSetFreeCluster(unsigned char totOrNext, unsigned char get_set, unsigned long FSEntry)
{
    245a:	cf 92       	push	r12
    245c:	df 92       	push	r13
    245e:	ef 92       	push	r14
    2460:	ff 92       	push	r15
    2462:	0f 93       	push	r16
    2464:	1f 93       	push	r17
    2466:	d8 2e       	mov	r13, r24
    2468:	c6 2e       	mov	r12, r22
    246a:	79 01       	movw	r14, r18
    246c:	8a 01       	movw	r16, r20
	struct FSInfo_Structure *FS = (struct FSInfo_Structure *) &buffer;
	unsigned char error;

	SD_readSingleBlock(unusedSectors + 1);
    246e:	60 91 75 03 	lds	r22, 0x0375
    2472:	70 91 76 03 	lds	r23, 0x0376
    2476:	80 91 77 03 	lds	r24, 0x0377
    247a:	90 91 78 03 	lds	r25, 0x0378
    247e:	6f 5f       	subi	r22, 0xFF	; 255
    2480:	7f 4f       	sbci	r23, 0xFF	; 255
    2482:	8f 4f       	sbci	r24, 0xFF	; 255
    2484:	9f 4f       	sbci	r25, 0xFF	; 255
    2486:	0e 94 71 1d 	call	0x3ae2	; 0x3ae2 <SD_readSingleBlock>

	if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
    248a:	80 91 73 01 	lds	r24, 0x0173
    248e:	90 91 74 01 	lds	r25, 0x0174
    2492:	a0 91 75 01 	lds	r26, 0x0175
    2496:	b0 91 76 01 	lds	r27, 0x0176
    249a:	82 55       	subi	r24, 0x52	; 82
    249c:	92 45       	sbci	r25, 0x52	; 82
    249e:	a1 46       	sbci	r26, 0x61	; 97
    24a0:	b1 44       	sbci	r27, 0x41	; 65
    24a2:	09 f0       	breq	.+2      	; 0x24a6 <getSetFreeCluster+0x4c>
    24a4:	54 c0       	rjmp	.+168    	; 0x254e <getSetFreeCluster+0xf4>
    24a6:	80 91 57 03 	lds	r24, 0x0357
    24aa:	90 91 58 03 	lds	r25, 0x0358
    24ae:	a0 91 59 03 	lds	r26, 0x0359
    24b2:	b0 91 5a 03 	lds	r27, 0x035A
    24b6:	82 57       	subi	r24, 0x72	; 114
    24b8:	92 47       	sbci	r25, 0x72	; 114
    24ba:	a1 44       	sbci	r26, 0x41	; 65
    24bc:	b1 46       	sbci	r27, 0x61	; 97
    24be:	09 f0       	breq	.+2      	; 0x24c2 <getSetFreeCluster+0x68>
    24c0:	46 c0       	rjmp	.+140    	; 0x254e <getSetFreeCluster+0xf4>
    24c2:	80 91 6f 03 	lds	r24, 0x036F
    24c6:	90 91 70 03 	lds	r25, 0x0370
    24ca:	a0 91 71 03 	lds	r26, 0x0371
    24ce:	b0 91 72 03 	lds	r27, 0x0372
    24d2:	80 50       	subi	r24, 0x00	; 0
    24d4:	90 40       	sbci	r25, 0x00	; 0
    24d6:	a5 45       	sbci	r26, 0x55	; 85
    24d8:	ba 4a       	sbci	r27, 0xAA	; 170
    24da:	c9 f5       	brne	.+114    	; 0x254e <getSetFreeCluster+0xf4>
	  return 0xffffffff;

	 if(get_set == GET)
    24dc:	cc 20       	and	r12, r12
    24de:	a9 f4       	brne	.+42     	; 0x250a <getSetFreeCluster+0xb0>
	 {
	   if(totOrNext == TOTAL_FREE)
    24e0:	81 e0       	ldi	r24, 0x01	; 1
    24e2:	d8 16       	cp	r13, r24
    24e4:	49 f4       	brne	.+18     	; 0x24f8 <getSetFreeCluster+0x9e>
	      return(FS->freeClusterCount);
    24e6:	20 91 5b 03 	lds	r18, 0x035B
    24ea:	30 91 5c 03 	lds	r19, 0x035C
    24ee:	40 91 5d 03 	lds	r20, 0x035D
    24f2:	50 91 5e 03 	lds	r21, 0x035E
    24f6:	2f c0       	rjmp	.+94     	; 0x2556 <getSetFreeCluster+0xfc>
	   else // when totOrNext = NEXT_FREE
	      return(FS->nextFreeCluster);
    24f8:	20 91 5f 03 	lds	r18, 0x035F
    24fc:	30 91 60 03 	lds	r19, 0x0360
    2500:	40 91 61 03 	lds	r20, 0x0361
    2504:	50 91 62 03 	lds	r21, 0x0362
    2508:	26 c0       	rjmp	.+76     	; 0x2556 <getSetFreeCluster+0xfc>
	 }
	 else
	 {
	   if(totOrNext == TOTAL_FREE)
    250a:	21 e0       	ldi	r18, 0x01	; 1
    250c:	d2 16       	cp	r13, r18
    250e:	49 f4       	brne	.+18     	; 0x2522 <getSetFreeCluster+0xc8>
	      FS->freeClusterCount = FSEntry;
    2510:	e0 92 5b 03 	sts	0x035B, r14
    2514:	f0 92 5c 03 	sts	0x035C, r15
    2518:	00 93 5d 03 	sts	0x035D, r16
    251c:	10 93 5e 03 	sts	0x035E, r17
    2520:	08 c0       	rjmp	.+16     	; 0x2532 <getSetFreeCluster+0xd8>
	   else // when totOrNext = NEXT_FREE
		  FS->nextFreeCluster = FSEntry;
    2522:	e0 92 5f 03 	sts	0x035F, r14
    2526:	f0 92 60 03 	sts	0x0360, r15
    252a:	00 93 61 03 	sts	0x0361, r16
    252e:	10 93 62 03 	sts	0x0362, r17
 
	   error = SD_writeSingleBlock(unusedSectors + 1);	//update FSinfo
    2532:	60 91 75 03 	lds	r22, 0x0375
    2536:	70 91 76 03 	lds	r23, 0x0376
    253a:	80 91 77 03 	lds	r24, 0x0377
    253e:	90 91 78 03 	lds	r25, 0x0378
    2542:	6f 5f       	subi	r22, 0xFF	; 255
    2544:	7f 4f       	sbci	r23, 0xFF	; 255
    2546:	8f 4f       	sbci	r24, 0xFF	; 255
    2548:	9f 4f       	sbci	r25, 0xFF	; 255
    254a:	0e 94 23 1d 	call	0x3a46	; 0x3a46 <SD_writeSingleBlock>
	 }
	 return 0xffffffff;
    254e:	2f ef       	ldi	r18, 0xFF	; 255
    2550:	3f ef       	ldi	r19, 0xFF	; 255
    2552:	4f ef       	ldi	r20, 0xFF	; 255
    2554:	5f ef       	ldi	r21, 0xFF	; 255
}
    2556:	b9 01       	movw	r22, r18
    2558:	ca 01       	movw	r24, r20
    255a:	1f 91       	pop	r17
    255c:	0f 91       	pop	r16
    255e:	ff 90       	pop	r15
    2560:	ef 90       	pop	r14
    2562:	df 90       	pop	r13
    2564:	cf 90       	pop	r12
    2566:	08 95       	ret

00002568 <freeMemoryUpdate>:
//			to ADD or REMOVE clusters occupied by the file
//Arguments: #1.flag ADD or REMOVE #2.file size in Bytes
//return: none
//********************************************************************
void freeMemoryUpdate (unsigned char flag, unsigned long size)
{
    2568:	df 92       	push	r13
    256a:	ef 92       	push	r14
    256c:	ff 92       	push	r15
    256e:	0f 93       	push	r16
    2570:	1f 93       	push	r17
    2572:	d8 2e       	mov	r13, r24
    2574:	db 01       	movw	r26, r22
    2576:	ca 01       	movw	r24, r20
    2578:	e9 e0       	ldi	r30, 0x09	; 9
    257a:	b6 95       	lsr	r27
    257c:	a7 95       	ror	r26
    257e:	97 95       	ror	r25
    2580:	87 95       	ror	r24
    2582:	ea 95       	dec	r30
    2584:	d1 f7       	brne	.-12     	; 0x257a <freeMemoryUpdate+0x12>
  unsigned long freeClusters;
  //convert file size into number of clusters occupied
  if((size % 512) == 0) size = size / 512;
    2586:	51 70       	andi	r21, 0x01	; 1
    2588:	60 70       	andi	r22, 0x00	; 0
    258a:	70 70       	andi	r23, 0x00	; 0
    258c:	41 15       	cp	r20, r1
    258e:	51 05       	cpc	r21, r1
    2590:	61 05       	cpc	r22, r1
    2592:	71 05       	cpc	r23, r1
    2594:	19 f4       	brne	.+6      	; 0x259c <freeMemoryUpdate+0x34>
    2596:	ac 01       	movw	r20, r24
    2598:	bd 01       	movw	r22, r26
    259a:	06 c0       	rjmp	.+12     	; 0x25a8 <freeMemoryUpdate+0x40>
  else size = (size / 512) +1;
    259c:	ac 01       	movw	r20, r24
    259e:	bd 01       	movw	r22, r26
    25a0:	4f 5f       	subi	r20, 0xFF	; 255
    25a2:	5f 4f       	sbci	r21, 0xFF	; 255
    25a4:	6f 4f       	sbci	r22, 0xFF	; 255
    25a6:	7f 4f       	sbci	r23, 0xFF	; 255
    25a8:	db 01       	movw	r26, r22
    25aa:	ca 01       	movw	r24, r20
    25ac:	33 e0       	ldi	r19, 0x03	; 3
    25ae:	b6 95       	lsr	r27
    25b0:	a7 95       	ror	r26
    25b2:	97 95       	ror	r25
    25b4:	87 95       	ror	r24
    25b6:	3a 95       	dec	r19
    25b8:	d1 f7       	brne	.-12     	; 0x25ae <freeMemoryUpdate+0x46>
  if((size % 8) == 0) size = size / 8;
    25ba:	47 70       	andi	r20, 0x07	; 7
    25bc:	50 70       	andi	r21, 0x00	; 0
    25be:	60 70       	andi	r22, 0x00	; 0
    25c0:	70 70       	andi	r23, 0x00	; 0
    25c2:	41 15       	cp	r20, r1
    25c4:	51 05       	cpc	r21, r1
    25c6:	61 05       	cpc	r22, r1
    25c8:	71 05       	cpc	r23, r1
    25ca:	19 f4       	brne	.+6      	; 0x25d2 <freeMemoryUpdate+0x6a>
    25cc:	7c 01       	movw	r14, r24
    25ce:	8d 01       	movw	r16, r26
    25d0:	07 c0       	rjmp	.+14     	; 0x25e0 <freeMemoryUpdate+0x78>
  else size = (size / 8) +1;
    25d2:	7c 01       	movw	r14, r24
    25d4:	8d 01       	movw	r16, r26
    25d6:	08 94       	sec
    25d8:	e1 1c       	adc	r14, r1
    25da:	f1 1c       	adc	r15, r1
    25dc:	01 1d       	adc	r16, r1
    25de:	11 1d       	adc	r17, r1

  if(freeClusterCountUpdated)
    25e0:	80 91 90 03 	lds	r24, 0x0390
    25e4:	88 23       	and	r24, r24
    25e6:	d9 f0       	breq	.+54     	; 0x261e <freeMemoryUpdate+0xb6>
  {
	freeClusters = getSetFreeCluster (TOTAL_FREE, GET, 0);
    25e8:	81 e0       	ldi	r24, 0x01	; 1
    25ea:	60 e0       	ldi	r22, 0x00	; 0
    25ec:	20 e0       	ldi	r18, 0x00	; 0
    25ee:	30 e0       	ldi	r19, 0x00	; 0
    25f0:	40 e0       	ldi	r20, 0x00	; 0
    25f2:	50 e0       	ldi	r21, 0x00	; 0
    25f4:	0e 94 2d 12 	call	0x245a	; 0x245a <getSetFreeCluster>
	if(flag == ADD)
    25f8:	dd 20       	and	r13, r13
    25fa:	39 f4       	brne	.+14     	; 0x260a <freeMemoryUpdate+0xa2>
  	   freeClusters = freeClusters + size;
    25fc:	9b 01       	movw	r18, r22
    25fe:	ac 01       	movw	r20, r24
    2600:	2e 0d       	add	r18, r14
    2602:	3f 1d       	adc	r19, r15
    2604:	40 1f       	adc	r20, r16
    2606:	51 1f       	adc	r21, r17
    2608:	06 c0       	rjmp	.+12     	; 0x2616 <freeMemoryUpdate+0xae>
	else  //when flag = REMOVE
	   freeClusters = freeClusters - size;
    260a:	9b 01       	movw	r18, r22
    260c:	ac 01       	movw	r20, r24
    260e:	2e 19       	sub	r18, r14
    2610:	3f 09       	sbc	r19, r15
    2612:	40 0b       	sbc	r20, r16
    2614:	51 0b       	sbc	r21, r17
	getSetFreeCluster (TOTAL_FREE, SET, freeClusters);
    2616:	81 e0       	ldi	r24, 0x01	; 1
    2618:	61 e0       	ldi	r22, 0x01	; 1
    261a:	0e 94 2d 12 	call	0x245a	; 0x245a <getSetFreeCluster>
  }
}
    261e:	1f 91       	pop	r17
    2620:	0f 91       	pop	r16
    2622:	ff 90       	pop	r15
    2624:	ef 90       	pop	r14
    2626:	df 90       	pop	r13
    2628:	08 95       	ret

0000262a <memoryStatistics>:
//it tries to read from SD whether a free cluster count is stored, if it is stored
//then it will return immediately. Otherwise it will count the total number of
//free clusters, which takes time
//****************************************************************************
void memoryStatistics (void)
{
    262a:	2f 92       	push	r2
    262c:	3f 92       	push	r3
    262e:	4f 92       	push	r4
    2630:	5f 92       	push	r5
    2632:	6f 92       	push	r6
    2634:	7f 92       	push	r7
    2636:	8f 92       	push	r8
    2638:	9f 92       	push	r9
    263a:	af 92       	push	r10
    263c:	bf 92       	push	r11
    263e:	cf 92       	push	r12
    2640:	df 92       	push	r13
    2642:	ef 92       	push	r14
    2644:	ff 92       	push	r15
    2646:	0f 93       	push	r16
    2648:	1f 93       	push	r17
unsigned long totalMemory, freeMemory;
unsigned long sector, *value;
unsigned int i;


totalMemory = totalClusters * sectorPerCluster / 1024;
    264a:	20 91 67 01 	lds	r18, 0x0167
    264e:	30 91 68 01 	lds	r19, 0x0168
    2652:	40 91 69 01 	lds	r20, 0x0169
    2656:	50 91 6a 01 	lds	r21, 0x016A
    265a:	60 91 73 03 	lds	r22, 0x0373
    265e:	70 91 74 03 	lds	r23, 0x0374
    2662:	80 e0       	ldi	r24, 0x00	; 0
    2664:	90 e0       	ldi	r25, 0x00	; 0
    2666:	0e 94 ac 1e 	call	0x3d58	; 0x3d58 <__mulsi3>
    266a:	5b 01       	movw	r10, r22
    266c:	6c 01       	movw	r12, r24
    266e:	1a e0       	ldi	r17, 0x0A	; 10
    2670:	d6 94       	lsr	r13
    2672:	c7 94       	ror	r12
    2674:	b7 94       	ror	r11
    2676:	a7 94       	ror	r10
    2678:	1a 95       	dec	r17
    267a:	d1 f7       	brne	.-12     	; 0x2670 <memoryStatistics+0x46>
totalMemory *= bytesPerSector;
    267c:	e0 90 65 01 	lds	r14, 0x0165
    2680:	f0 90 66 01 	lds	r15, 0x0166

TX_NEWLINE;
    2684:	8d e0       	ldi	r24, 0x0D	; 13
    2686:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <transmitByte>
    268a:	8a e0       	ldi	r24, 0x0A	; 10
    268c:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <transmitByte>
TX_NEWLINE;
    2690:	8d e0       	ldi	r24, 0x0D	; 13
    2692:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <transmitByte>
    2696:	8a e0       	ldi	r24, 0x0A	; 10
    2698:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <transmitByte>
transmitString_F(PSTR("Total Memory: "));
    269c:	83 e6       	ldi	r24, 0x63	; 99
    269e:	90 e0       	ldi	r25, 0x00	; 0
    26a0:	0e 94 43 1e 	call	0x3c86	; 0x3c86 <transmitString_F>

displayMemory (HIGH, totalMemory);
    26a4:	00 e0       	ldi	r16, 0x00	; 0
    26a6:	10 e0       	ldi	r17, 0x00	; 0
    26a8:	c6 01       	movw	r24, r12
    26aa:	b5 01       	movw	r22, r10
    26ac:	a8 01       	movw	r20, r16
    26ae:	97 01       	movw	r18, r14
    26b0:	0e 94 ac 1e 	call	0x3d58	; 0x3d58 <__mulsi3>
    26b4:	ab 01       	movw	r20, r22
    26b6:	bc 01       	movw	r22, r24
    26b8:	81 e0       	ldi	r24, 0x01	; 1
    26ba:	0e 94 b4 10 	call	0x2168	; 0x2168 <displayMemory>

freeClusters = getSetFreeCluster (TOTAL_FREE, GET, 0);
    26be:	81 e0       	ldi	r24, 0x01	; 1
    26c0:	60 e0       	ldi	r22, 0x00	; 0
    26c2:	20 e0       	ldi	r18, 0x00	; 0
    26c4:	30 e0       	ldi	r19, 0x00	; 0
    26c6:	40 e0       	ldi	r20, 0x00	; 0
    26c8:	50 e0       	ldi	r21, 0x00	; 0
    26ca:	0e 94 2d 12 	call	0x245a	; 0x245a <getSetFreeCluster>
    26ce:	3b 01       	movw	r6, r22
    26d0:	4c 01       	movw	r8, r24
//freeClusters = 0xffffffff;    

if(freeClusters > totalClusters)
    26d2:	80 91 67 01 	lds	r24, 0x0167
    26d6:	90 91 68 01 	lds	r25, 0x0168
    26da:	a0 91 69 01 	lds	r26, 0x0169
    26de:	b0 91 6a 01 	lds	r27, 0x016A
    26e2:	86 15       	cp	r24, r6
    26e4:	97 05       	cpc	r25, r7
    26e6:	a8 05       	cpc	r26, r8
    26e8:	b9 05       	cpc	r27, r9
    26ea:	08 f0       	brcs	.+2      	; 0x26ee <memoryStatistics+0xc4>
    26ec:	7c c0       	rjmp	.+248    	; 0x27e6 <memoryStatistics+0x1bc>
{
   freeClusterCountUpdated = 0;
    26ee:	10 92 90 03 	sts	0x0390, r1
   freeClusters = 0;
   totalClusterCount = 0;
   cluster = rootCluster;    
    26f2:	a0 90 6b 01 	lds	r10, 0x016B
    26f6:	b0 90 6c 01 	lds	r11, 0x016C
    26fa:	c0 90 6d 01 	lds	r12, 0x016D
    26fe:	d0 90 6e 01 	lds	r13, 0x016E
    2702:	b2 e0       	ldi	r27, 0x02	; 2
    2704:	aa 0c       	add	r10, r10
    2706:	bb 1c       	adc	r11, r11
    2708:	cc 1c       	adc	r12, r12
    270a:	dd 1c       	adc	r13, r13
    270c:	ba 95       	dec	r27
    270e:	d1 f7       	brne	.-12     	; 0x2704 <memoryStatistics+0xda>
    2710:	66 24       	eor	r6, r6
    2712:	77 24       	eor	r7, r7
    2714:	43 01       	movw	r8, r6
    2716:	22 24       	eor	r2, r2
    2718:	33 24       	eor	r3, r3
    271a:	21 01       	movw	r4, r2
    while(1)
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector) ;
    271c:	e0 90 7e 03 	lds	r14, 0x037E
    2720:	f0 90 7f 03 	lds	r15, 0x037F
    2724:	20 91 65 01 	lds	r18, 0x0165
    2728:	30 91 66 01 	lds	r19, 0x0166
      SD_readSingleBlock(sector);
    272c:	00 e0       	ldi	r16, 0x00	; 0
    272e:	10 e0       	ldi	r17, 0x00	; 0
    2730:	80 91 75 03 	lds	r24, 0x0375
    2734:	90 91 76 03 	lds	r25, 0x0376
    2738:	a0 91 77 03 	lds	r26, 0x0377
    273c:	b0 91 78 03 	lds	r27, 0x0378
    2740:	e8 0e       	add	r14, r24
    2742:	f9 1e       	adc	r15, r25
    2744:	0a 1f       	adc	r16, r26
    2746:	1b 1f       	adc	r17, r27
    2748:	40 e0       	ldi	r20, 0x00	; 0
    274a:	50 e0       	ldi	r21, 0x00	; 0
    274c:	c6 01       	movw	r24, r12
    274e:	b5 01       	movw	r22, r10
    2750:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <__udivmodsi4>
    2754:	e2 0e       	add	r14, r18
    2756:	f3 1e       	adc	r15, r19
    2758:	04 1f       	adc	r16, r20
    275a:	15 1f       	adc	r17, r21
    275c:	c8 01       	movw	r24, r16
    275e:	b7 01       	movw	r22, r14
    2760:	0e 94 71 1d 	call	0x3ae2	; 0x3ae2 <SD_readSingleBlock>
    2764:	a2 01       	movw	r20, r4
    2766:	91 01       	movw	r18, r2
    2768:	60 e0       	ldi	r22, 0x00	; 0
    276a:	70 e0       	ldi	r23, 0x00	; 0
      for(i=0; i<128; i++)
      {
           value = (unsigned long *) &buffer[i*4];
         if(((*value)& 0x0fffffff) == 0)
    276c:	fb 01       	movw	r30, r22
    276e:	ed 58       	subi	r30, 0x8D	; 141
    2770:	fe 4f       	sbci	r31, 0xFE	; 254
    2772:	80 81       	ld	r24, Z
    2774:	91 81       	ldd	r25, Z+1	; 0x01
    2776:	a2 81       	ldd	r26, Z+2	; 0x02
    2778:	b3 81       	ldd	r27, Z+3	; 0x03
    277a:	bf 70       	andi	r27, 0x0F	; 15
    277c:	00 97       	sbiw	r24, 0x00	; 0
    277e:	a1 05       	cpc	r26, r1
    2780:	b1 05       	cpc	r27, r1
    2782:	29 f4       	brne	.+10     	; 0x278e <memoryStatistics+0x164>
            freeClusters++;;
    2784:	08 94       	sec
    2786:	61 1c       	adc	r6, r1
    2788:	71 1c       	adc	r7, r1
    278a:	81 1c       	adc	r8, r1
    278c:	91 1c       	adc	r9, r1
        
         totalClusterCount++;
    278e:	2f 5f       	subi	r18, 0xFF	; 255
    2790:	3f 4f       	sbci	r19, 0xFF	; 255
    2792:	4f 4f       	sbci	r20, 0xFF	; 255
    2794:	5f 4f       	sbci	r21, 0xFF	; 255
         if(totalClusterCount == (totalClusters+2)) break;
    2796:	80 91 67 01 	lds	r24, 0x0167
    279a:	90 91 68 01 	lds	r25, 0x0168
    279e:	a0 91 69 01 	lds	r26, 0x0169
    27a2:	b0 91 6a 01 	lds	r27, 0x016A
    27a6:	02 96       	adiw	r24, 0x02	; 2
    27a8:	a1 1d       	adc	r26, r1
    27aa:	b1 1d       	adc	r27, r1
    27ac:	28 17       	cp	r18, r24
    27ae:	39 07       	cpc	r19, r25
    27b0:	4a 07       	cpc	r20, r26
    27b2:	5b 07       	cpc	r21, r27
    27b4:	c1 f0       	breq	.+48     	; 0x27e6 <memoryStatistics+0x1bc>
    27b6:	c9 01       	movw	r24, r18
    27b8:	82 19       	sub	r24, r2
    27ba:	93 09       	sbc	r25, r3
    27bc:	6c 5f       	subi	r22, 0xFC	; 252
    27be:	7f 4f       	sbci	r23, 0xFF	; 255
   cluster = rootCluster;    
    while(1)
    {
      sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector) ;
      SD_readSingleBlock(sector);
      for(i=0; i<128; i++)
    27c0:	02 e0       	ldi	r16, 0x02	; 2
    27c2:	60 30       	cpi	r22, 0x00	; 0
    27c4:	70 07       	cpc	r23, r16
    27c6:	91 f6       	brne	.-92     	; 0x276c <memoryStatistics+0x142>
    27c8:	e1 2c       	mov	r14, r1
    27ca:	a2 e0       	ldi	r26, 0x02	; 2
    27cc:	fa 2e       	mov	r15, r26
    27ce:	01 2d       	mov	r16, r1
    27d0:	11 2d       	mov	r17, r1
    27d2:	ae 0c       	add	r10, r14
    27d4:	bf 1c       	adc	r11, r15
    27d6:	c0 1e       	adc	r12, r16
    27d8:	d1 1e       	adc	r13, r17
            freeClusters++;;
        
         totalClusterCount++;
         if(totalClusterCount == (totalClusters+2)) break;
      }  
      if(i < 128) break;
    27da:	80 38       	cpi	r24, 0x80	; 128
    27dc:	91 05       	cpc	r25, r1
    27de:	18 f0       	brcs	.+6      	; 0x27e6 <memoryStatistics+0x1bc>
    27e0:	19 01       	movw	r2, r18
    27e2:	2a 01       	movw	r4, r20
    27e4:	9b cf       	rjmp	.-202    	; 0x271c <memoryStatistics+0xf2>
      cluster+=128;
    } 
}

if(!freeClusterCountUpdated)
    27e6:	80 91 90 03 	lds	r24, 0x0390
    27ea:	88 23       	and	r24, r24
    27ec:	31 f4       	brne	.+12     	; 0x27fa <memoryStatistics+0x1d0>
  getSetFreeCluster (TOTAL_FREE, SET, freeClusters); //update FSinfo next free cluster entry
    27ee:	81 e0       	ldi	r24, 0x01	; 1
    27f0:	61 e0       	ldi	r22, 0x01	; 1
    27f2:	a4 01       	movw	r20, r8
    27f4:	93 01       	movw	r18, r6
    27f6:	0e 94 2d 12 	call	0x245a	; 0x245a <getSetFreeCluster>
freeClusterCountUpdated = 1;  //set flag
    27fa:	81 e0       	ldi	r24, 0x01	; 1
    27fc:	80 93 90 03 	sts	0x0390, r24
freeMemory = freeClusters * sectorPerCluster / 1024;
    2800:	20 91 73 03 	lds	r18, 0x0373
    2804:	30 91 74 03 	lds	r19, 0x0374
    2808:	40 e0       	ldi	r20, 0x00	; 0
    280a:	50 e0       	ldi	r21, 0x00	; 0
    280c:	c4 01       	movw	r24, r8
    280e:	b3 01       	movw	r22, r6
    2810:	0e 94 ac 1e 	call	0x3d58	; 0x3d58 <__mulsi3>
    2814:	5b 01       	movw	r10, r22
    2816:	6c 01       	movw	r12, r24
    2818:	fa e0       	ldi	r31, 0x0A	; 10
    281a:	d6 94       	lsr	r13
    281c:	c7 94       	ror	r12
    281e:	b7 94       	ror	r11
    2820:	a7 94       	ror	r10
    2822:	fa 95       	dec	r31
    2824:	d1 f7       	brne	.-12     	; 0x281a <memoryStatistics+0x1f0>
freeMemory *= bytesPerSector ;
    2826:	e0 90 65 01 	lds	r14, 0x0165
    282a:	f0 90 66 01 	lds	r15, 0x0166
TX_NEWLINE;
    282e:	8d e0       	ldi	r24, 0x0D	; 13
    2830:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <transmitByte>
    2834:	8a e0       	ldi	r24, 0x0A	; 10
    2836:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <transmitByte>
transmitString_F(PSTR(" Free Memory: "));
    283a:	84 e5       	ldi	r24, 0x54	; 84
    283c:	90 e0       	ldi	r25, 0x00	; 0
    283e:	0e 94 43 1e 	call	0x3c86	; 0x3c86 <transmitString_F>
displayMemory (HIGH, freeMemory);
    2842:	00 e0       	ldi	r16, 0x00	; 0
    2844:	10 e0       	ldi	r17, 0x00	; 0
    2846:	c6 01       	movw	r24, r12
    2848:	b5 01       	movw	r22, r10
    284a:	a8 01       	movw	r20, r16
    284c:	97 01       	movw	r18, r14
    284e:	0e 94 ac 1e 	call	0x3d58	; 0x3d58 <__mulsi3>
    2852:	ab 01       	movw	r20, r22
    2854:	bc 01       	movw	r22, r24
    2856:	81 e0       	ldi	r24, 0x01	; 1
    2858:	0e 94 b4 10 	call	0x2168	; 0x2168 <displayMemory>
TX_NEWLINE; 
    285c:	8d e0       	ldi	r24, 0x0D	; 13
    285e:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <transmitByte>
    2862:	8a e0       	ldi	r24, 0x0A	; 10
    2864:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <transmitByte>
}
    2868:	1f 91       	pop	r17
    286a:	0f 91       	pop	r16
    286c:	ff 90       	pop	r15
    286e:	ef 90       	pop	r14
    2870:	df 90       	pop	r13
    2872:	cf 90       	pop	r12
    2874:	bf 90       	pop	r11
    2876:	af 90       	pop	r10
    2878:	9f 90       	pop	r9
    287a:	8f 90       	pop	r8
    287c:	7f 90       	pop	r7
    287e:	6f 90       	pop	r6
    2880:	5f 90       	pop	r5
    2882:	4f 90       	pop	r4
    2884:	3f 90       	pop	r3
    2886:	2f 90       	pop	r2
    2888:	08 95       	ret

0000288a <getBootSectorData>:
//parameters like bytesPerSector, sectorsPerCluster etc.
//Arguments: none
//return: none
//***************************************************************************
unsigned char getBootSectorData (void)
{
    288a:	6f 92       	push	r6
    288c:	7f 92       	push	r7
    288e:	8f 92       	push	r8
    2890:	9f 92       	push	r9
    2892:	af 92       	push	r10
    2894:	bf 92       	push	r11
    2896:	cf 92       	push	r12
    2898:	df 92       	push	r13
    289a:	ef 92       	push	r14
    289c:	ff 92       	push	r15
    289e:	0f 93       	push	r16
    28a0:	1f 93       	push	r17
	struct BS_Structure *bpb; //mapping the buffer onto the structure
	struct MBRinfo_Structure *mbr;
	struct partitionInfo_Structure *partition;
	unsigned long dataSectors;

	unusedSectors = 0;
    28a2:	10 92 75 03 	sts	0x0375, r1
    28a6:	10 92 76 03 	sts	0x0376, r1
    28aa:	10 92 77 03 	sts	0x0377, r1
    28ae:	10 92 78 03 	sts	0x0378, r1

	SD_readSingleBlock(0);
    28b2:	60 e0       	ldi	r22, 0x00	; 0
    28b4:	70 e0       	ldi	r23, 0x00	; 0
    28b6:	80 e0       	ldi	r24, 0x00	; 0
    28b8:	90 e0       	ldi	r25, 0x00	; 0
    28ba:	0e 94 71 1d 	call	0x3ae2	; 0x3ae2 <SD_readSingleBlock>
	bpb = (struct BS_Structure *)buffer;

	if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
    28be:	80 91 73 01 	lds	r24, 0x0173
    28c2:	89 3e       	cpi	r24, 0xE9	; 233
    28c4:	19 f1       	breq	.+70     	; 0x290c <getBootSectorData+0x82>
    28c6:	8b 3e       	cpi	r24, 0xEB	; 235
    28c8:	09 f1       	breq	.+66     	; 0x290c <getBootSectorData+0x82>
	{
	  mbr = (struct MBRinfo_Structure *) buffer;       //if it is not boot sector, it must be MBR
  
	  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    28ca:	80 91 71 03 	lds	r24, 0x0371
    28ce:	90 91 72 03 	lds	r25, 0x0372
    28d2:	85 55       	subi	r24, 0x55	; 85
    28d4:	9a 4a       	sbci	r25, 0xAA	; 170
    28d6:	09 f0       	breq	.+2      	; 0x28da <getBootSectorData+0x50>
    28d8:	b0 c0       	rjmp	.+352    	; 0x2a3a <getBootSectorData+0x1b0>
  	
	  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
	  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
    28da:	60 91 39 03 	lds	r22, 0x0339
    28de:	70 91 3a 03 	lds	r23, 0x033A
    28e2:	80 91 3b 03 	lds	r24, 0x033B
    28e6:	90 91 3c 03 	lds	r25, 0x033C
    28ea:	60 93 75 03 	sts	0x0375, r22
    28ee:	70 93 76 03 	sts	0x0376, r23
    28f2:	80 93 77 03 	sts	0x0377, r24
    28f6:	90 93 78 03 	sts	0x0378, r25
  
	  SD_readSingleBlock(partition->firstSector);//read the bpb sector
    28fa:	0e 94 71 1d 	call	0x3ae2	; 0x3ae2 <SD_readSingleBlock>
	  bpb = (struct BS_Structure *)buffer;
	  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    28fe:	80 91 73 01 	lds	r24, 0x0173
    2902:	89 3e       	cpi	r24, 0xE9	; 233
    2904:	19 f0       	breq	.+6      	; 0x290c <getBootSectorData+0x82>
    2906:	8b 3e       	cpi	r24, 0xEB	; 235
    2908:	09 f0       	breq	.+2      	; 0x290c <getBootSectorData+0x82>
    290a:	97 c0       	rjmp	.+302    	; 0x2a3a <getBootSectorData+0x1b0>
	}

	bytesPerSector = bpb->bytesPerSector;
    290c:	80 91 7e 01 	lds	r24, 0x017E
    2910:	90 91 7f 01 	lds	r25, 0x017F
    2914:	90 93 66 01 	sts	0x0166, r25
    2918:	80 93 65 01 	sts	0x0165, r24
	//transmitHex(INT, bytesPerSector); transmitByte(' ');
	sectorPerCluster = bpb->sectorPerCluster;
    291c:	80 91 80 01 	lds	r24, 0x0180
    2920:	90 e0       	ldi	r25, 0x00	; 0
    2922:	90 93 74 03 	sts	0x0374, r25
    2926:	80 93 73 03 	sts	0x0373, r24
	//transmitHex(INT, sectorPerCluster); transmitByte(' ');
	reservedSectorCount = bpb->reservedSectorCount;
    292a:	a0 90 81 01 	lds	r10, 0x0181
    292e:	b0 90 82 01 	lds	r11, 0x0182
    2932:	b0 92 7f 03 	sts	0x037F, r11
    2936:	a0 92 7e 03 	sts	0x037E, r10
	rootCluster = bpb->rootCluster;// + (sector / sectorPerCluster) +1;
    293a:	80 91 9f 01 	lds	r24, 0x019F
    293e:	90 91 a0 01 	lds	r25, 0x01A0
    2942:	a0 91 a1 01 	lds	r26, 0x01A1
    2946:	b0 91 a2 01 	lds	r27, 0x01A2
    294a:	80 93 6b 01 	sts	0x016B, r24
    294e:	90 93 6c 01 	sts	0x016C, r25
    2952:	a0 93 6d 01 	sts	0x016D, r26
    2956:	b0 93 6e 01 	sts	0x016E, r27
	firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);
    295a:	e0 90 7e 03 	lds	r14, 0x037E
    295e:	f0 90 7f 03 	lds	r15, 0x037F
    2962:	60 91 83 01 	lds	r22, 0x0183
    2966:	70 e0       	ldi	r23, 0x00	; 0
    2968:	80 e0       	ldi	r24, 0x00	; 0
    296a:	90 e0       	ldi	r25, 0x00	; 0
    296c:	20 91 97 01 	lds	r18, 0x0197
    2970:	30 91 98 01 	lds	r19, 0x0198
    2974:	40 91 99 01 	lds	r20, 0x0199
    2978:	50 91 9a 01 	lds	r21, 0x019A
    297c:	0e 94 ac 1e 	call	0x3d58	; 0x3d58 <__mulsi3>
    2980:	3b 01       	movw	r6, r22
    2982:	4c 01       	movw	r8, r24
    2984:	00 e0       	ldi	r16, 0x00	; 0
    2986:	10 e0       	ldi	r17, 0x00	; 0
    2988:	80 91 8f 01 	lds	r24, 0x018F
    298c:	90 91 90 01 	lds	r25, 0x0190
    2990:	a0 91 91 01 	lds	r26, 0x0191
    2994:	b0 91 92 01 	lds	r27, 0x0192
    2998:	e8 0e       	add	r14, r24
    299a:	f9 1e       	adc	r15, r25
    299c:	0a 1f       	adc	r16, r26
    299e:	1b 1f       	adc	r17, r27
    29a0:	e6 0c       	add	r14, r6
    29a2:	f7 1c       	adc	r15, r7
    29a4:	08 1d       	adc	r16, r8
    29a6:	19 1d       	adc	r17, r9
    29a8:	e0 92 5d 01 	sts	0x015D, r14
    29ac:	f0 92 5e 01 	sts	0x015E, r15
    29b0:	00 93 5f 01 	sts	0x015F, r16
    29b4:	10 93 60 01 	sts	0x0160, r17

	dataSectors = bpb->totalSectors_F32
	              - bpb->reservedSectorCount
	              - ( bpb->numberofFATs * bpb->FATsize_F32);
	totalClusters = dataSectors / sectorPerCluster;
    29b8:	20 91 73 03 	lds	r18, 0x0373
    29bc:	30 91 74 03 	lds	r19, 0x0374
    29c0:	cc 24       	eor	r12, r12
    29c2:	dd 24       	eor	r13, r13
    29c4:	60 91 93 01 	lds	r22, 0x0193
    29c8:	70 91 94 01 	lds	r23, 0x0194
    29cc:	80 91 95 01 	lds	r24, 0x0195
    29d0:	90 91 96 01 	lds	r25, 0x0196
    29d4:	6a 19       	sub	r22, r10
    29d6:	7b 09       	sbc	r23, r11
    29d8:	8c 09       	sbc	r24, r12
    29da:	9d 09       	sbc	r25, r13
    29dc:	66 19       	sub	r22, r6
    29de:	77 09       	sbc	r23, r7
    29e0:	88 09       	sbc	r24, r8
    29e2:	99 09       	sbc	r25, r9
    29e4:	40 e0       	ldi	r20, 0x00	; 0
    29e6:	50 e0       	ldi	r21, 0x00	; 0
    29e8:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <__udivmodsi4>
    29ec:	c9 01       	movw	r24, r18
    29ee:	da 01       	movw	r26, r20
    29f0:	80 93 67 01 	sts	0x0167, r24
    29f4:	90 93 68 01 	sts	0x0168, r25
    29f8:	a0 93 69 01 	sts	0x0169, r26
    29fc:	b0 93 6a 01 	sts	0x016A, r27
	//transmitHex(LONG, totalClusters); transmitByte(' ');

	if((getSetFreeCluster (TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
    2a00:	81 e0       	ldi	r24, 0x01	; 1
    2a02:	60 e0       	ldi	r22, 0x00	; 0
    2a04:	20 e0       	ldi	r18, 0x00	; 0
    2a06:	30 e0       	ldi	r19, 0x00	; 0
    2a08:	40 e0       	ldi	r20, 0x00	; 0
    2a0a:	50 e0       	ldi	r21, 0x00	; 0
    2a0c:	0e 94 2d 12 	call	0x245a	; 0x245a <getSetFreeCluster>
    2a10:	20 91 67 01 	lds	r18, 0x0167
    2a14:	30 91 68 01 	lds	r19, 0x0168
    2a18:	40 91 69 01 	lds	r20, 0x0169
    2a1c:	50 91 6a 01 	lds	r21, 0x016A
    2a20:	26 17       	cp	r18, r22
    2a22:	37 07       	cpc	r19, r23
    2a24:	48 07       	cpc	r20, r24
    2a26:	59 07       	cpc	r21, r25
    2a28:	18 f4       	brcc	.+6      	; 0x2a30 <getBootSectorData+0x1a6>
	     freeClusterCountUpdated = 0;
    2a2a:	10 92 90 03 	sts	0x0390, r1
    2a2e:	03 c0       	rjmp	.+6      	; 0x2a36 <getBootSectorData+0x1ac>
	else
		 freeClusterCountUpdated = 1;
    2a30:	81 e0       	ldi	r24, 0x01	; 1
    2a32:	80 93 90 03 	sts	0x0390, r24
    2a36:	80 e0       	ldi	r24, 0x00	; 0
    2a38:	01 c0       	rjmp	.+2      	; 0x2a3c <getBootSectorData+0x1b2>
    2a3a:	81 e0       	ldi	r24, 0x01	; 1
	return 0;
}
    2a3c:	1f 91       	pop	r17
    2a3e:	0f 91       	pop	r16
    2a40:	ff 90       	pop	r15
    2a42:	ef 90       	pop	r14
    2a44:	df 90       	pop	r13
    2a46:	cf 90       	pop	r12
    2a48:	bf 90       	pop	r11
    2a4a:	af 90       	pop	r10
    2a4c:	9f 90       	pop	r9
    2a4e:	8f 90       	pop	r8
    2a50:	7f 90       	pop	r7
    2a52:	6f 90       	pop	r6
    2a54:	08 95       	ret

00002a56 <getSetNextCluster>:
//return: next cluster number, if if argument#2 = GET, else 0
//****************************************************************************
unsigned long getSetNextCluster (unsigned long clusterNumber,
                                 unsigned char get_set,
                                 unsigned long clusterEntry)
{
    2a56:	4f 92       	push	r4
    2a58:	5f 92       	push	r5
    2a5a:	6f 92       	push	r6
    2a5c:	7f 92       	push	r7
    2a5e:	8f 92       	push	r8
    2a60:	9f 92       	push	r9
    2a62:	af 92       	push	r10
    2a64:	bf 92       	push	r11
    2a66:	cf 92       	push	r12
    2a68:	df 92       	push	r13
    2a6a:	ef 92       	push	r14
    2a6c:	ff 92       	push	r15
    2a6e:	0f 93       	push	r16
    2a70:	1f 93       	push	r17
    2a72:	cf 93       	push	r28
    2a74:	df 93       	push	r29
    2a76:	5b 01       	movw	r10, r22
    2a78:	6c 01       	movw	r12, r24
    2a7a:	84 2e       	mov	r8, r20
    2a7c:	28 01       	movw	r4, r16
    2a7e:	39 01       	movw	r6, r18
	unsigned long *FATEntryValue;
	unsigned long FATEntrySector;
	unsigned char retry = 0;

	//get sector number of the cluster entry in the FAT
	FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;
    2a80:	80 91 7e 03 	lds	r24, 0x037E
    2a84:	90 91 7f 03 	lds	r25, 0x037F
    2a88:	02 e0       	ldi	r16, 0x02	; 2
    2a8a:	aa 0c       	add	r10, r10
    2a8c:	bb 1c       	adc	r11, r11
    2a8e:	cc 1c       	adc	r12, r12
    2a90:	dd 1c       	adc	r13, r13
    2a92:	0a 95       	dec	r16
    2a94:	d1 f7       	brne	.-12     	; 0x2a8a <getSetNextCluster+0x34>
    2a96:	20 91 65 01 	lds	r18, 0x0165
    2a9a:	30 91 66 01 	lds	r19, 0x0166
    2a9e:	7c 01       	movw	r14, r24
    2aa0:	00 e0       	ldi	r16, 0x00	; 0
    2aa2:	10 e0       	ldi	r17, 0x00	; 0
    2aa4:	80 91 75 03 	lds	r24, 0x0375
    2aa8:	90 91 76 03 	lds	r25, 0x0376
    2aac:	a0 91 77 03 	lds	r26, 0x0377
    2ab0:	b0 91 78 03 	lds	r27, 0x0378
    2ab4:	e8 0e       	add	r14, r24
    2ab6:	f9 1e       	adc	r15, r25
    2ab8:	0a 1f       	adc	r16, r26
    2aba:	1b 1f       	adc	r17, r27
    2abc:	40 e0       	ldi	r20, 0x00	; 0
    2abe:	50 e0       	ldi	r21, 0x00	; 0
    2ac0:	c6 01       	movw	r24, r12
    2ac2:	b5 01       	movw	r22, r10
    2ac4:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <__udivmodsi4>
    2ac8:	e2 0e       	add	r14, r18
    2aca:	f3 1e       	adc	r15, r19
    2acc:	04 1f       	adc	r16, r20
    2ace:	15 1f       	adc	r17, r21

	//get the offset address in that sector number
	FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);
    2ad0:	c0 91 65 01 	lds	r28, 0x0165
    2ad4:	d0 91 66 01 	lds	r29, 0x0166
    2ad8:	99 24       	eor	r9, r9

	//read the sector into a buffer
	while(retry <10)
	{ if(!SD_readSingleBlock(FATEntrySector)) break; retry++;}
    2ada:	c8 01       	movw	r24, r16
    2adc:	b7 01       	movw	r22, r14
    2ade:	0e 94 71 1d 	call	0x3ae2	; 0x3ae2 <SD_readSingleBlock>
    2ae2:	88 23       	and	r24, r24
    2ae4:	21 f0       	breq	.+8      	; 0x2aee <getSetNextCluster+0x98>
    2ae6:	93 94       	inc	r9

	//get the offset address in that sector number
	FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);

	//read the sector into a buffer
	while(retry <10)
    2ae8:	8a e0       	ldi	r24, 0x0A	; 10
    2aea:	98 16       	cp	r9, r24
    2aec:	b1 f7       	brne	.-20     	; 0x2ada <getSetNextCluster+0x84>
	{ if(!SD_readSingleBlock(FATEntrySector)) break; retry++;}

	//get the cluster address from the buffer
	FATEntryValue = (unsigned long *) &buffer[FATEntryOffset];
    2aee:	9e 01       	movw	r18, r28
    2af0:	40 e0       	ldi	r20, 0x00	; 0
    2af2:	50 e0       	ldi	r21, 0x00	; 0
    2af4:	c6 01       	movw	r24, r12
    2af6:	b5 01       	movw	r22, r10
    2af8:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <__udivmodsi4>
    2afc:	fb 01       	movw	r30, r22
    2afe:	ed 58       	subi	r30, 0x8D	; 141
    2b00:	fe 4f       	sbci	r31, 0xFE	; 254

	if(get_set == GET)
    2b02:	88 20       	and	r8, r8
    2b04:	31 f4       	brne	.+12     	; 0x2b12 <getSetNextCluster+0xbc>
	  return ((*FATEntryValue) & 0x0fffffff);
    2b06:	20 81       	ld	r18, Z
    2b08:	31 81       	ldd	r19, Z+1	; 0x01
    2b0a:	42 81       	ldd	r20, Z+2	; 0x02
    2b0c:	53 81       	ldd	r21, Z+3	; 0x03
    2b0e:	5f 70       	andi	r21, 0x0F	; 15
    2b10:	0c c0       	rjmp	.+24     	; 0x2b2a <getSetNextCluster+0xd4>


	*FATEntryValue = clusterEntry;   //for setting new value in cluster entry in FAT
    2b12:	40 82       	st	Z, r4
    2b14:	51 82       	std	Z+1, r5	; 0x01
    2b16:	62 82       	std	Z+2, r6	; 0x02
    2b18:	73 82       	std	Z+3, r7	; 0x03

	SD_writeSingleBlock(FATEntrySector);
    2b1a:	c8 01       	movw	r24, r16
    2b1c:	b7 01       	movw	r22, r14
    2b1e:	0e 94 23 1d 	call	0x3a46	; 0x3a46 <SD_writeSingleBlock>
    2b22:	20 e0       	ldi	r18, 0x00	; 0
    2b24:	30 e0       	ldi	r19, 0x00	; 0
    2b26:	40 e0       	ldi	r20, 0x00	; 0
    2b28:	50 e0       	ldi	r21, 0x00	; 0

	return (0);
}
    2b2a:	b9 01       	movw	r22, r18
    2b2c:	ca 01       	movw	r24, r20
    2b2e:	df 91       	pop	r29
    2b30:	cf 91       	pop	r28
    2b32:	1f 91       	pop	r17
    2b34:	0f 91       	pop	r16
    2b36:	ff 90       	pop	r15
    2b38:	ef 90       	pop	r14
    2b3a:	df 90       	pop	r13
    2b3c:	cf 90       	pop	r12
    2b3e:	bf 90       	pop	r11
    2b40:	af 90       	pop	r10
    2b42:	9f 90       	pop	r9
    2b44:	8f 90       	pop	r8
    2b46:	7f 90       	pop	r7
    2b48:	6f 90       	pop	r6
    2b4a:	5f 90       	pop	r5
    2b4c:	4f 90       	pop	r4
    2b4e:	08 95       	ret

00002b50 <findFiles>:
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
{
    2b50:	2f 92       	push	r2
    2b52:	3f 92       	push	r3
    2b54:	4f 92       	push	r4
    2b56:	5f 92       	push	r5
    2b58:	6f 92       	push	r6
    2b5a:	7f 92       	push	r7
    2b5c:	8f 92       	push	r8
    2b5e:	9f 92       	push	r9
    2b60:	af 92       	push	r10
    2b62:	bf 92       	push	r11
    2b64:	cf 92       	push	r12
    2b66:	df 92       	push	r13
    2b68:	ef 92       	push	r14
    2b6a:	ff 92       	push	r15
    2b6c:	0f 93       	push	r16
    2b6e:	1f 93       	push	r17
    2b70:	df 93       	push	r29
    2b72:	cf 93       	push	r28
    2b74:	cd b7       	in	r28, 0x3d	; 61
    2b76:	de b7       	in	r29, 0x3e	; 62
    2b78:	2a 97       	sbiw	r28, 0x0a	; 10
    2b7a:	0f b6       	in	r0, 0x3f	; 63
    2b7c:	f8 94       	cli
    2b7e:	de bf       	out	0x3e, r29	; 62
    2b80:	0f be       	out	0x3f, r0	; 63
    2b82:	cd bf       	out	0x3d, r28	; 61
    2b84:	8d 83       	std	Y+5, r24	; 0x05
    2b86:	7f 83       	std	Y+7, r23	; 0x07
    2b88:	6e 83       	std	Y+6, r22	; 0x06
unsigned long cluster, sector, firstSector, firstCluster, nextCluster;
struct dir_Structure *dir;
unsigned int i;
unsigned char j;

cluster = rootCluster; //root cluster
    2b8a:	a0 90 6b 01 	lds	r10, 0x016B
    2b8e:	b0 90 6c 01 	lds	r11, 0x016C
    2b92:	c0 90 6d 01 	lds	r12, 0x016D
    2b96:	d0 90 6e 01 	lds	r13, 0x016E
		      transmitString_F(PSTR("File does not exist!"));
		  return 0;   
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
    2b9a:	81 50       	subi	r24, 0x01	; 1
    2b9c:	88 87       	std	Y+8, r24	; 0x08
//Arguments: cluster number for which first sector is to be found
//return: first sector address
//***************************************************************************
unsigned long getFirstSector(unsigned long clusterNumber)
{
  return (((clusterNumber - 2) * sectorPerCluster) + firstDataSector);
    2b9e:	20 91 73 03 	lds	r18, 0x0373
    2ba2:	30 91 74 03 	lds	r19, 0x0374
    2ba6:	e0 90 5d 01 	lds	r14, 0x015D
    2baa:	f0 90 5e 01 	lds	r15, 0x015E
    2bae:	00 91 5f 01 	lds	r16, 0x015F
    2bb2:	10 91 60 01 	lds	r17, 0x0160
    2bb6:	c6 01       	movw	r24, r12
    2bb8:	b5 01       	movw	r22, r10
    2bba:	62 50       	subi	r22, 0x02	; 2
    2bbc:	70 40       	sbci	r23, 0x00	; 0
    2bbe:	80 40       	sbci	r24, 0x00	; 0
    2bc0:	90 40       	sbci	r25, 0x00	; 0
    2bc2:	40 e0       	ldi	r20, 0x00	; 0
    2bc4:	50 e0       	ldi	r21, 0x00	; 0
    2bc6:	0e 94 ac 1e 	call	0x3d58	; 0x3d58 <__mulsi3>
    2bca:	1b 01       	movw	r2, r22
    2bcc:	2c 01       	movw	r4, r24
    2bce:	2e 0c       	add	r2, r14
    2bd0:	3f 1c       	adc	r3, r15
    2bd2:	40 1e       	adc	r4, r16
    2bd4:	51 1e       	adc	r5, r17
    2bd6:	66 24       	eor	r6, r6
    2bd8:	77 24       	eor	r7, r7
    2bda:	43 01       	movw	r8, r6
    2bdc:	60 c1       	rjmp	.+704    	; 0x2e9e <findFiles+0x34e>

while(1)
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    2bde:	d4 01       	movw	r26, r8
    2be0:	c3 01       	movw	r24, r6
    2be2:	82 0d       	add	r24, r2
    2be4:	93 1d       	adc	r25, r3
    2be6:	a4 1d       	adc	r26, r4
    2be8:	b5 1d       	adc	r27, r5
    2bea:	89 83       	std	Y+1, r24	; 0x01
    2bec:	9a 83       	std	Y+2, r25	; 0x02
    2bee:	ab 83       	std	Y+3, r26	; 0x03
    2bf0:	bc 83       	std	Y+4, r27	; 0x04
   {
     SD_readSingleBlock (firstSector + sector);
    2bf2:	bc 01       	movw	r22, r24
    2bf4:	cd 01       	movw	r24, r26
    2bf6:	0e 94 71 1d 	call	0x3ae2	; 0x3ae2 <SD_readSingleBlock>
    2bfa:	40 e2       	ldi	r20, 0x20	; 32
    2bfc:	e4 2e       	mov	r14, r20
    2bfe:	f1 2c       	mov	r15, r1
    2c00:	3e c1       	rjmp	.+636    	; 0x2e7e <findFiles+0x32e>
	

     for(i=0; i<bytesPerSector; i+=32)
    2c02:	8a 01       	movw	r16, r20
    2c04:	0d 58       	subi	r16, 0x8D	; 141
    2c06:	1e 4f       	sbci	r17, 0xFE	; 254
     {
	    dir = (struct dir_Structure *) &buffer[i];

        if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    2c08:	f7 01       	movw	r30, r14
    2c0a:	ed 58       	subi	r30, 0x8D	; 141
    2c0c:	fe 4f       	sbci	r31, 0xFE	; 254
    2c0e:	b0 97       	sbiw	r30, 0x20	; 32
    2c10:	80 81       	ld	r24, Z
    2c12:	b0 96       	adiw	r30, 0x20	; 32
    2c14:	88 23       	and	r24, r24
    2c16:	41 f4       	brne	.+16     	; 0x2c28 <findFiles+0xd8>
		{
		  if((flag == GET_FILE) || (flag == DELETE))
    2c18:	9d 81       	ldd	r25, Y+5	; 0x05
    2c1a:	91 50       	subi	r25, 0x01	; 1
    2c1c:	92 30       	cpi	r25, 0x02	; 2
    2c1e:	08 f0       	brcs	.+2      	; 0x2c22 <findFiles+0xd2>
    2c20:	68 c1       	rjmp	.+720    	; 0x2ef2 <findFiles+0x3a2>
		      transmitString_F(PSTR("File does not exist!"));
    2c22:	8c ea       	ldi	r24, 0xAC	; 172
    2c24:	91 e0       	ldi	r25, 0x01	; 1
    2c26:	63 c1       	rjmp	.+710    	; 0x2eee <findFiles+0x39e>
		  return 0;   
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
    2c28:	85 3e       	cpi	r24, 0xE5	; 229
    2c2a:	09 f4       	brne	.+2      	; 0x2c2e <findFiles+0xde>
    2c2c:	24 c1       	rjmp	.+584    	; 0x2e76 <findFiles+0x326>
    2c2e:	75 97       	sbiw	r30, 0x15	; 21
    2c30:	80 81       	ld	r24, Z
    2c32:	8f 30       	cpi	r24, 0x0F	; 15
    2c34:	09 f4       	brne	.+2      	; 0x2c38 <findFiles+0xe8>
    2c36:	1f c1       	rjmp	.+574    	; 0x2e76 <findFiles+0x326>
        {
          if((flag == GET_FILE) || (flag == DELETE))
    2c38:	a8 85       	ldd	r26, Y+8	; 0x08
    2c3a:	a2 30       	cpi	r26, 0x02	; 2
    2c3c:	08 f0       	brcs	.+2      	; 0x2c40 <findFiles+0xf0>
    2c3e:	d2 c0       	rjmp	.+420    	; 0x2de4 <findFiles+0x294>
    2c40:	20 e0       	ldi	r18, 0x00	; 0
    2c42:	30 e0       	ldi	r19, 0x00	; 0
          {
            for(j=0; j<11; j++)
            if(dir->name[j] != fileName[j]) break;
    2c44:	c8 01       	movw	r24, r16
    2c46:	82 0f       	add	r24, r18
    2c48:	93 1f       	adc	r25, r19
    2c4a:	ae 81       	ldd	r26, Y+6	; 0x06
    2c4c:	bf 81       	ldd	r27, Y+7	; 0x07
    2c4e:	a2 0f       	add	r26, r18
    2c50:	b3 1f       	adc	r27, r19
    2c52:	fc 01       	movw	r30, r24
    2c54:	90 81       	ld	r25, Z
    2c56:	8c 91       	ld	r24, X
    2c58:	98 17       	cp	r25, r24
    2c5a:	09 f0       	breq	.+2      	; 0x2c5e <findFiles+0x10e>
    2c5c:	0c c1       	rjmp	.+536    	; 0x2e76 <findFiles+0x326>
    2c5e:	82 2f       	mov	r24, r18
    2c60:	8f 5f       	subi	r24, 0xFF	; 255
    2c62:	2f 5f       	subi	r18, 0xFF	; 255
    2c64:	3f 4f       	sbci	r19, 0xFF	; 255
		}
		if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
        {
          if((flag == GET_FILE) || (flag == DELETE))
          {
            for(j=0; j<11; j++)
    2c66:	2b 30       	cpi	r18, 0x0B	; 11
    2c68:	31 05       	cpc	r19, r1
    2c6a:	61 f7       	brne	.-40     	; 0x2c44 <findFiles+0xf4>
            if(dir->name[j] != fileName[j]) break;
            if(j == 11)
    2c6c:	8b 30       	cpi	r24, 0x0B	; 11
    2c6e:	09 f0       	breq	.+2      	; 0x2c72 <findFiles+0x122>
    2c70:	02 c1       	rjmp	.+516    	; 0x2e76 <findFiles+0x326>
			{
			  if(flag == GET_FILE)
    2c72:	fd 81       	ldd	r31, Y+5	; 0x05
    2c74:	f1 30       	cpi	r31, 0x01	; 1
    2c76:	09 f0       	breq	.+2      	; 0x2c7a <findFiles+0x12a>
    2c78:	3f c0       	rjmp	.+126    	; 0x2cf8 <findFiles+0x1a8>
              {
			    appendFileSector = firstSector + sector;
    2c7a:	89 81       	ldd	r24, Y+1	; 0x01
    2c7c:	9a 81       	ldd	r25, Y+2	; 0x02
    2c7e:	ab 81       	ldd	r26, Y+3	; 0x03
    2c80:	bc 81       	ldd	r27, Y+4	; 0x04
    2c82:	80 93 91 03 	sts	0x0391, r24
    2c86:	90 93 92 03 	sts	0x0392, r25
    2c8a:	a0 93 93 03 	sts	0x0393, r26
    2c8e:	b0 93 94 03 	sts	0x0394, r27
				appendFileLocation = i;
    2c92:	ca 01       	movw	r24, r20
    2c94:	a0 e0       	ldi	r26, 0x00	; 0
    2c96:	b0 e0       	ldi	r27, 0x00	; 0
    2c98:	80 93 59 01 	sts	0x0159, r24
    2c9c:	90 93 5a 01 	sts	0x015A, r25
    2ca0:	a0 93 5b 01 	sts	0x015B, r26
    2ca4:	b0 93 5c 01 	sts	0x015C, r27
				appendStartCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    2ca8:	d8 01       	movw	r26, r16
    2caa:	54 96       	adiw	r26, 0x14	; 20
    2cac:	8d 91       	ld	r24, X+
    2cae:	9c 91       	ld	r25, X
    2cb0:	55 97       	sbiw	r26, 0x15	; 21
    2cb2:	a0 e0       	ldi	r26, 0x00	; 0
    2cb4:	b0 e0       	ldi	r27, 0x00	; 0
    2cb6:	dc 01       	movw	r26, r24
    2cb8:	99 27       	eor	r25, r25
    2cba:	88 27       	eor	r24, r24
    2cbc:	f8 01       	movw	r30, r16
    2cbe:	22 8d       	ldd	r18, Z+26	; 0x1a
    2cc0:	33 8d       	ldd	r19, Z+27	; 0x1b
    2cc2:	40 e0       	ldi	r20, 0x00	; 0
    2cc4:	50 e0       	ldi	r21, 0x00	; 0
    2cc6:	82 2b       	or	r24, r18
    2cc8:	93 2b       	or	r25, r19
    2cca:	a4 2b       	or	r26, r20
    2ccc:	b5 2b       	or	r27, r21
    2cce:	80 93 80 03 	sts	0x0380, r24
    2cd2:	90 93 81 03 	sts	0x0381, r25
    2cd6:	a0 93 82 03 	sts	0x0382, r26
    2cda:	b0 93 83 03 	sts	0x0383, r27
				fileSize = dir->fileSize;
    2cde:	84 8d       	ldd	r24, Z+28	; 0x1c
    2ce0:	95 8d       	ldd	r25, Z+29	; 0x1d
    2ce2:	a6 8d       	ldd	r26, Z+30	; 0x1e
    2ce4:	b7 8d       	ldd	r27, Z+31	; 0x1f
    2ce6:	80 93 61 01 	sts	0x0161, r24
    2cea:	90 93 62 01 	sts	0x0162, r25
    2cee:	a0 93 63 01 	sts	0x0163, r26
    2cf2:	b0 93 64 01 	sts	0x0164, r27
    2cf6:	ff c0       	rjmp	.+510    	; 0x2ef6 <findFiles+0x3a6>
			    return (dir);
			  }	
			  else    //when flag = DELETE
			  {
			     TX_NEWLINE;
    2cf8:	8d e0       	ldi	r24, 0x0D	; 13
    2cfa:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <transmitByte>
    2cfe:	8a e0       	ldi	r24, 0x0A	; 10
    2d00:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <transmitByte>
				 transmitString_F(PSTR("Deleting.."));
    2d04:	81 ea       	ldi	r24, 0xA1	; 161
    2d06:	91 e0       	ldi	r25, 0x01	; 1
    2d08:	0e 94 43 1e 	call	0x3c86	; 0x3c86 <transmitString_F>
				 TX_NEWLINE;
    2d0c:	8d e0       	ldi	r24, 0x0D	; 13
    2d0e:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <transmitByte>
    2d12:	8a e0       	ldi	r24, 0x0A	; 10
    2d14:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <transmitByte>
				 TX_NEWLINE;
    2d18:	8d e0       	ldi	r24, 0x0D	; 13
    2d1a:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <transmitByte>
    2d1e:	8a e0       	ldi	r24, 0x0A	; 10
    2d20:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <transmitByte>
				 firstCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    2d24:	d8 01       	movw	r26, r16
    2d26:	54 96       	adiw	r26, 0x14	; 20
    2d28:	8d 91       	ld	r24, X+
    2d2a:	9c 91       	ld	r25, X
    2d2c:	55 97       	sbiw	r26, 0x15	; 21
    2d2e:	a0 e0       	ldi	r26, 0x00	; 0
    2d30:	b0 e0       	ldi	r27, 0x00	; 0
    2d32:	5c 01       	movw	r10, r24
    2d34:	99 24       	eor	r9, r9
    2d36:	88 24       	eor	r8, r8
    2d38:	f8 01       	movw	r30, r16
    2d3a:	82 8d       	ldd	r24, Z+26	; 0x1a
    2d3c:	93 8d       	ldd	r25, Z+27	; 0x1b
    2d3e:	a0 e0       	ldi	r26, 0x00	; 0
    2d40:	b0 e0       	ldi	r27, 0x00	; 0
    2d42:	88 2a       	or	r8, r24
    2d44:	99 2a       	or	r9, r25
    2d46:	aa 2a       	or	r10, r26
    2d48:	bb 2a       	or	r11, r27
                
				 //mark file as 'deleted' in FAT table
				 dir->name[0] = DELETED;    
    2d4a:	85 ee       	ldi	r24, 0xE5	; 229
    2d4c:	80 83       	st	Z, r24
				 SD_writeSingleBlock (firstSector+sector);
    2d4e:	69 81       	ldd	r22, Y+1	; 0x01
    2d50:	7a 81       	ldd	r23, Y+2	; 0x02
    2d52:	8b 81       	ldd	r24, Y+3	; 0x03
    2d54:	9c 81       	ldd	r25, Y+4	; 0x04
    2d56:	0e 94 23 1d 	call	0x3a46	; 0x3a46 <SD_writeSingleBlock>
				 			 
				 freeMemoryUpdate (ADD, dir->fileSize);
    2d5a:	d8 01       	movw	r26, r16
    2d5c:	5c 96       	adiw	r26, 0x1c	; 28
    2d5e:	4d 91       	ld	r20, X+
    2d60:	5d 91       	ld	r21, X+
    2d62:	6d 91       	ld	r22, X+
    2d64:	7c 91       	ld	r23, X
    2d66:	5f 97       	sbiw	r26, 0x1f	; 31
    2d68:	80 e0       	ldi	r24, 0x00	; 0
    2d6a:	0e 94 b4 12 	call	0x2568	; 0x2568 <freeMemoryUpdate>

				 //update next free cluster entry in FSinfo sector
				 cluster = getSetFreeCluster (NEXT_FREE, GET, 0); 
    2d6e:	82 e0       	ldi	r24, 0x02	; 2
    2d70:	60 e0       	ldi	r22, 0x00	; 0
    2d72:	20 e0       	ldi	r18, 0x00	; 0
    2d74:	30 e0       	ldi	r19, 0x00	; 0
    2d76:	40 e0       	ldi	r20, 0x00	; 0
    2d78:	50 e0       	ldi	r21, 0x00	; 0
    2d7a:	0e 94 2d 12 	call	0x245a	; 0x245a <getSetFreeCluster>
				 if(firstCluster < cluster)
    2d7e:	86 16       	cp	r8, r22
    2d80:	97 06       	cpc	r9, r23
    2d82:	a8 06       	cpc	r10, r24
    2d84:	b9 06       	cpc	r11, r25
    2d86:	30 f4       	brcc	.+12     	; 0x2d94 <findFiles+0x244>
				     getSetFreeCluster (NEXT_FREE, SET, firstCluster);
    2d88:	82 e0       	ldi	r24, 0x02	; 2
    2d8a:	61 e0       	ldi	r22, 0x01	; 1
    2d8c:	a5 01       	movw	r20, r10
    2d8e:	94 01       	movw	r18, r8
    2d90:	0e 94 2d 12 	call	0x245a	; 0x245a <getSetFreeCluster>

				 //mark all the clusters allocated to the file as 'free'
			     while(1)  
			     {
			        nextCluster = getSetNextCluster (firstCluster, GET, 0);
    2d94:	c5 01       	movw	r24, r10
    2d96:	b4 01       	movw	r22, r8
    2d98:	40 e0       	ldi	r20, 0x00	; 0
    2d9a:	00 e0       	ldi	r16, 0x00	; 0
    2d9c:	10 e0       	ldi	r17, 0x00	; 0
    2d9e:	20 e0       	ldi	r18, 0x00	; 0
    2da0:	30 e0       	ldi	r19, 0x00	; 0
    2da2:	0e 94 2b 15 	call	0x2a56	; 0x2a56 <getSetNextCluster>
    2da6:	f6 2e       	mov	r15, r22
    2da8:	e7 2e       	mov	r14, r23
    2daa:	d8 2e       	mov	r13, r24
    2dac:	c9 2e       	mov	r12, r25
					getSetNextCluster (firstCluster, SET, 0);
    2dae:	c5 01       	movw	r24, r10
    2db0:	b4 01       	movw	r22, r8
    2db2:	41 e0       	ldi	r20, 0x01	; 1
    2db4:	00 e0       	ldi	r16, 0x00	; 0
    2db6:	10 e0       	ldi	r17, 0x00	; 0
    2db8:	20 e0       	ldi	r18, 0x00	; 0
    2dba:	30 e0       	ldi	r19, 0x00	; 0
    2dbc:	0e 94 2b 15 	call	0x2a56	; 0x2a56 <getSetNextCluster>
    2dc0:	8f 2d       	mov	r24, r15
    2dc2:	9e 2d       	mov	r25, r14
    2dc4:	ad 2d       	mov	r26, r13
    2dc6:	bc 2d       	mov	r27, r12
    2dc8:	4c 01       	movw	r8, r24
    2dca:	5d 01       	movw	r10, r26
					if(nextCluster > 0x0ffffff6) 
    2dcc:	b7 ef       	ldi	r27, 0xF7	; 247
    2dce:	8b 16       	cp	r8, r27
    2dd0:	bf ef       	ldi	r27, 0xFF	; 255
    2dd2:	9b 06       	cpc	r9, r27
    2dd4:	bf ef       	ldi	r27, 0xFF	; 255
    2dd6:	ab 06       	cpc	r10, r27
    2dd8:	bf e0       	ldi	r27, 0x0F	; 15
    2dda:	bb 06       	cpc	r11, r27
    2ddc:	d8 f2       	brcs	.-74     	; 0x2d94 <findFiles+0x244>
					   {transmitString_F(PSTR("File deleted!"));return 0;}
    2dde:	83 e9       	ldi	r24, 0x93	; 147
    2de0:	91 e0       	ldi	r25, 0x01	; 1
    2de2:	85 c0       	rjmp	.+266    	; 0x2eee <findFiles+0x39e>
			  }
            }
          }
          else  //when flag = GET_LIST
		  {
		     TX_NEWLINE;
    2de4:	8d e0       	ldi	r24, 0x0D	; 13
    2de6:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <transmitByte>
    2dea:	8a e0       	ldi	r24, 0x0A	; 10
    2dec:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <transmitByte>
    2df0:	1a 86       	std	Y+10, r1	; 0x0a
    2df2:	19 86       	std	Y+9, r1	; 0x09
    2df4:	0b c0       	rjmp	.+22     	; 0x2e0c <findFiles+0x2bc>
			 for(j=0; j<11; j++)
		     {
			   if(j == 8) transmitByte(' ');
    2df6:	e9 85       	ldd	r30, Y+9	; 0x09
    2df8:	e7 30       	cpi	r30, 0x07	; 7
    2dfa:	19 f4       	brne	.+6      	; 0x2e02 <findFiles+0x2b2>
    2dfc:	80 e2       	ldi	r24, 0x20	; 32
    2dfe:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <transmitByte>
    2e02:	89 85       	ldd	r24, Y+9	; 0x09
    2e04:	9a 85       	ldd	r25, Y+10	; 0x0a
    2e06:	01 96       	adiw	r24, 0x01	; 1
    2e08:	9a 87       	std	Y+10, r25	; 0x0a
    2e0a:	89 87       	std	Y+9, r24	; 0x09
			   transmitByte (dir->name[j]);
    2e0c:	e9 85       	ldd	r30, Y+9	; 0x09
    2e0e:	fa 85       	ldd	r31, Y+10	; 0x0a
    2e10:	e0 0f       	add	r30, r16
    2e12:	f1 1f       	adc	r31, r17
    2e14:	80 81       	ld	r24, Z
    2e16:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <transmitByte>
            }
          }
          else  //when flag = GET_LIST
		  {
		     TX_NEWLINE;
			 for(j=0; j<11; j++)
    2e1a:	a9 85       	ldd	r26, Y+9	; 0x09
    2e1c:	ba 85       	ldd	r27, Y+10	; 0x0a
    2e1e:	1a 97       	sbiw	r26, 0x0a	; 10
    2e20:	51 f7       	brne	.-44     	; 0x2df6 <findFiles+0x2a6>
		     {
			   if(j == 8) transmitByte(' ');
			   transmitByte (dir->name[j]);
			 }
		     transmitString_F (PSTR("   "));
    2e22:	8f e8       	ldi	r24, 0x8F	; 143
    2e24:	91 e0       	ldi	r25, 0x01	; 1
    2e26:	0e 94 43 1e 	call	0x3c86	; 0x3c86 <transmitString_F>
		     if((dir->attrib != 0x10) && (dir->attrib != 0x08))
    2e2a:	87 01       	movw	r16, r14
    2e2c:	0d 58       	subi	r16, 0x8D	; 141
    2e2e:	1e 4f       	sbci	r17, 0xFE	; 254
    2e30:	05 51       	subi	r16, 0x15	; 21
    2e32:	10 40       	sbci	r17, 0x00	; 0
    2e34:	f8 01       	movw	r30, r16
    2e36:	80 81       	ld	r24, Z
    2e38:	0b 5e       	subi	r16, 0xEB	; 235
    2e3a:	1f 4f       	sbci	r17, 0xFF	; 255
    2e3c:	80 31       	cpi	r24, 0x10	; 16
    2e3e:	b9 f0       	breq	.+46     	; 0x2e6e <findFiles+0x31e>
    2e40:	88 30       	cpi	r24, 0x08	; 8
    2e42:	19 f4       	brne	.+6      	; 0x2e4a <findFiles+0x2fa>
			     transmitString_F (PSTR("FILE" ));
		         transmitString_F (PSTR("   "));
			     displayMemory (LOW, dir->fileSize);
			 }
			 else
			   transmitString_F ((dir->attrib == 0x10)? PSTR("DIR") : PSTR("ROOT"));
    2e44:	8d e7       	ldi	r24, 0x7D	; 125
    2e46:	91 e0       	ldi	r25, 0x01	; 1
    2e48:	14 c0       	rjmp	.+40     	; 0x2e72 <findFiles+0x322>
			   transmitByte (dir->name[j]);
			 }
		     transmitString_F (PSTR("   "));
		     if((dir->attrib != 0x10) && (dir->attrib != 0x08))
			 {
			     transmitString_F (PSTR("FILE" ));
    2e4a:	8a e8       	ldi	r24, 0x8A	; 138
    2e4c:	91 e0       	ldi	r25, 0x01	; 1
    2e4e:	0e 94 43 1e 	call	0x3c86	; 0x3c86 <transmitString_F>
		         transmitString_F (PSTR("   "));
    2e52:	86 e8       	ldi	r24, 0x86	; 134
    2e54:	91 e0       	ldi	r25, 0x01	; 1
    2e56:	0e 94 43 1e 	call	0x3c86	; 0x3c86 <transmitString_F>
			     displayMemory (LOW, dir->fileSize);
    2e5a:	f8 01       	movw	r30, r16
    2e5c:	34 97       	sbiw	r30, 0x04	; 4
    2e5e:	40 81       	ld	r20, Z
    2e60:	51 81       	ldd	r21, Z+1	; 0x01
    2e62:	62 81       	ldd	r22, Z+2	; 0x02
    2e64:	73 81       	ldd	r23, Z+3	; 0x03
    2e66:	80 e0       	ldi	r24, 0x00	; 0
    2e68:	0e 94 b4 10 	call	0x2168	; 0x2168 <displayMemory>
    2e6c:	04 c0       	rjmp	.+8      	; 0x2e76 <findFiles+0x326>
			 }
			 else
			   transmitString_F ((dir->attrib == 0x10)? PSTR("DIR") : PSTR("ROOT"));
    2e6e:	82 e8       	ldi	r24, 0x82	; 130
    2e70:	91 e0       	ldi	r25, 0x01	; 1
    2e72:	0e 94 43 1e 	call	0x3c86	; 0x3c86 <transmitString_F>
    2e76:	80 e2       	ldi	r24, 0x20	; 32
    2e78:	90 e0       	ldi	r25, 0x00	; 0
    2e7a:	e8 0e       	add	r14, r24
    2e7c:	f9 1e       	adc	r15, r25
    2e7e:	a7 01       	movw	r20, r14
    2e80:	40 52       	subi	r20, 0x20	; 32
    2e82:	50 40       	sbci	r21, 0x00	; 0
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_readSingleBlock (firstSector + sector);
	

     for(i=0; i<bytesPerSector; i+=32)
    2e84:	80 91 65 01 	lds	r24, 0x0165
    2e88:	90 91 66 01 	lds	r25, 0x0166
    2e8c:	48 17       	cp	r20, r24
    2e8e:	59 07       	cpc	r21, r25
    2e90:	08 f4       	brcc	.+2      	; 0x2e94 <findFiles+0x344>
    2e92:	b7 ce       	rjmp	.-658    	; 0x2c02 <findFiles+0xb2>

while(1)
{
   firstSector = getFirstSector (cluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    2e94:	08 94       	sec
    2e96:	61 1c       	adc	r6, r1
    2e98:	71 1c       	adc	r7, r1
    2e9a:	81 1c       	adc	r8, r1
    2e9c:	91 1c       	adc	r9, r1
    2e9e:	80 91 73 03 	lds	r24, 0x0373
    2ea2:	90 91 74 03 	lds	r25, 0x0374
    2ea6:	a0 e0       	ldi	r26, 0x00	; 0
    2ea8:	b0 e0       	ldi	r27, 0x00	; 0
    2eaa:	68 16       	cp	r6, r24
    2eac:	79 06       	cpc	r7, r25
    2eae:	8a 06       	cpc	r8, r26
    2eb0:	9b 06       	cpc	r9, r27
    2eb2:	08 f4       	brcc	.+2      	; 0x2eb6 <findFiles+0x366>
    2eb4:	94 ce       	rjmp	.-728    	; 0x2bde <findFiles+0x8e>
		  }
       }
     }
   }

   cluster = (getSetNextCluster (cluster, GET, 0));
    2eb6:	c6 01       	movw	r24, r12
    2eb8:	b5 01       	movw	r22, r10
    2eba:	40 e0       	ldi	r20, 0x00	; 0
    2ebc:	00 e0       	ldi	r16, 0x00	; 0
    2ebe:	10 e0       	ldi	r17, 0x00	; 0
    2ec0:	20 e0       	ldi	r18, 0x00	; 0
    2ec2:	30 e0       	ldi	r19, 0x00	; 0
    2ec4:	0e 94 2b 15 	call	0x2a56	; 0x2a56 <getSetNextCluster>
    2ec8:	5b 01       	movw	r10, r22
    2eca:	6c 01       	movw	r12, r24

   if(cluster > 0x0ffffff6)
    2ecc:	97 ef       	ldi	r25, 0xF7	; 247
    2ece:	a9 16       	cp	r10, r25
    2ed0:	9f ef       	ldi	r25, 0xFF	; 255
    2ed2:	b9 06       	cpc	r11, r25
    2ed4:	9f ef       	ldi	r25, 0xFF	; 255
    2ed6:	c9 06       	cpc	r12, r25
    2ed8:	9f e0       	ldi	r25, 0x0F	; 15
    2eda:	d9 06       	cpc	r13, r25
    2edc:	50 f4       	brcc	.+20     	; 0x2ef2 <findFiles+0x3a2>
   	 return 0;
   if(cluster == 0) 
    2ede:	a1 14       	cp	r10, r1
    2ee0:	b1 04       	cpc	r11, r1
    2ee2:	c1 04       	cpc	r12, r1
    2ee4:	d1 04       	cpc	r13, r1
    2ee6:	09 f0       	breq	.+2      	; 0x2eea <findFiles+0x39a>
    2ee8:	5a ce       	rjmp	.-844    	; 0x2b9e <findFiles+0x4e>
   {transmitString_F(PSTR("Error in getting cluster"));  return 0;}
    2eea:	84 e6       	ldi	r24, 0x64	; 100
    2eec:	91 e0       	ldi	r25, 0x01	; 1
    2eee:	0e 94 43 1e 	call	0x3c86	; 0x3c86 <transmitString_F>
    2ef2:	00 e0       	ldi	r16, 0x00	; 0
    2ef4:	10 e0       	ldi	r17, 0x00	; 0
 }
return 0;
}
    2ef6:	c8 01       	movw	r24, r16
    2ef8:	2a 96       	adiw	r28, 0x0a	; 10
    2efa:	0f b6       	in	r0, 0x3f	; 63
    2efc:	f8 94       	cli
    2efe:	de bf       	out	0x3e, r29	; 62
    2f00:	0f be       	out	0x3f, r0	; 63
    2f02:	cd bf       	out	0x3d, r28	; 61
    2f04:	cf 91       	pop	r28
    2f06:	df 91       	pop	r29
    2f08:	1f 91       	pop	r17
    2f0a:	0f 91       	pop	r16
    2f0c:	ff 90       	pop	r15
    2f0e:	ef 90       	pop	r14
    2f10:	df 90       	pop	r13
    2f12:	cf 90       	pop	r12
    2f14:	bf 90       	pop	r11
    2f16:	af 90       	pop	r10
    2f18:	9f 90       	pop	r9
    2f1a:	8f 90       	pop	r8
    2f1c:	7f 90       	pop	r7
    2f1e:	6f 90       	pop	r6
    2f20:	5f 90       	pop	r5
    2f22:	4f 90       	pop	r4
    2f24:	3f 90       	pop	r3
    2f26:	2f 90       	pop	r2
    2f28:	08 95       	ret

00002f2a <deleteFile>:
//Function: to delete a specified file from the root directory
//Arguments: pointer to the file name
//return: none
//********************************************************************
void deleteFile (unsigned char *fileName)
{
    2f2a:	cf 93       	push	r28
    2f2c:	df 93       	push	r29
    2f2e:	ec 01       	movw	r28, r24
  unsigned char error;

  error = convertFileName (fileName);
    2f30:	0e 94 1b 11 	call	0x2236	; 0x2236 <convertFileName>
  if(error) return;
    2f34:	88 23       	and	r24, r24
    2f36:	21 f4       	brne	.+8      	; 0x2f40 <deleteFile+0x16>

  findFiles (DELETE, fileName);
    2f38:	82 e0       	ldi	r24, 0x02	; 2
    2f3a:	be 01       	movw	r22, r28
    2f3c:	0e 94 a8 15 	call	0x2b50	; 0x2b50 <findFiles>
}
    2f40:	df 91       	pop	r29
    2f42:	cf 91       	pop	r28
    2f44:	08 95       	ret

00002f46 <readFile>:
//return: 0, if normal operation or flag is READ
//	      1, if file is already existing and flag = VERIFY
//		  2, if file name is incompatible
//***************************************************************************
unsigned char readFile (unsigned char flag, unsigned char *fileName)
{
    2f46:	2f 92       	push	r2
    2f48:	3f 92       	push	r3
    2f4a:	4f 92       	push	r4
    2f4c:	5f 92       	push	r5
    2f4e:	6f 92       	push	r6
    2f50:	7f 92       	push	r7
    2f52:	8f 92       	push	r8
    2f54:	9f 92       	push	r9
    2f56:	af 92       	push	r10
    2f58:	bf 92       	push	r11
    2f5a:	cf 92       	push	r12
    2f5c:	df 92       	push	r13
    2f5e:	ef 92       	push	r14
    2f60:	ff 92       	push	r15
    2f62:	0f 93       	push	r16
    2f64:	1f 93       	push	r17
    2f66:	df 93       	push	r29
    2f68:	cf 93       	push	r28
    2f6a:	00 d0       	rcall	.+0      	; 0x2f6c <readFile+0x26>
    2f6c:	00 d0       	rcall	.+0      	; 0x2f6e <readFile+0x28>
    2f6e:	cd b7       	in	r28, 0x3d	; 61
    2f70:	de b7       	in	r29, 0x3e	; 62
    2f72:	18 2f       	mov	r17, r24
unsigned char j, error;

//error = convertFileName (fileName); //convert fileName into FAT format
//if(error) return 2;

dir = findFiles (GET_FILE, fileName); //get the file location
    2f74:	81 e0       	ldi	r24, 0x01	; 1
    2f76:	0e 94 a8 15 	call	0x2b50	; 0x2b50 <findFiles>
    2f7a:	9c 01       	movw	r18, r24
if(dir == 0) 
    2f7c:	00 97       	sbiw	r24, 0x00	; 0
    2f7e:	09 f4       	brne	.+2      	; 0x2f82 <readFile+0x3c>
    2f80:	89 c0       	rjmp	.+274    	; 0x3094 <readFile+0x14e>
  return (0);

if(flag == VERIFY) return (1);	//specified file name is already existing
    2f82:	11 30       	cpi	r17, 0x01	; 1
    2f84:	11 f4       	brne	.+4      	; 0x2f8a <readFile+0x44>
    2f86:	81 e0       	ldi	r24, 0x01	; 1
    2f88:	86 c0       	rjmp	.+268    	; 0x3096 <readFile+0x150>

cluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    2f8a:	dc 01       	movw	r26, r24
    2f8c:	54 96       	adiw	r26, 0x14	; 20
    2f8e:	8d 91       	ld	r24, X+
    2f90:	9c 91       	ld	r25, X
    2f92:	55 97       	sbiw	r26, 0x15	; 21
    2f94:	a0 e0       	ldi	r26, 0x00	; 0
    2f96:	b0 e0       	ldi	r27, 0x00	; 0
    2f98:	6c 01       	movw	r12, r24
    2f9a:	bb 24       	eor	r11, r11
    2f9c:	aa 24       	eor	r10, r10
    2f9e:	f9 01       	movw	r30, r18
    2fa0:	82 8d       	ldd	r24, Z+26	; 0x1a
    2fa2:	93 8d       	ldd	r25, Z+27	; 0x1b
    2fa4:	a0 e0       	ldi	r26, 0x00	; 0
    2fa6:	b0 e0       	ldi	r27, 0x00	; 0
    2fa8:	a8 2a       	or	r10, r24
    2faa:	b9 2a       	or	r11, r25
    2fac:	ca 2a       	or	r12, r26
    2fae:	db 2a       	or	r13, r27

fileSize = dir->fileSize;
    2fb0:	d9 01       	movw	r26, r18
    2fb2:	5c 96       	adiw	r26, 0x1c	; 28
    2fb4:	8d 91       	ld	r24, X+
    2fb6:	9d 91       	ld	r25, X+
    2fb8:	0d 90       	ld	r0, X+
    2fba:	bc 91       	ld	r27, X
    2fbc:	a0 2d       	mov	r26, r0
    2fbe:	89 83       	std	Y+1, r24	; 0x01
    2fc0:	9a 83       	std	Y+2, r25	; 0x02
    2fc2:	ab 83       	std	Y+3, r26	; 0x03
    2fc4:	bc 83       	std	Y+4, r27	; 0x04
    2fc6:	22 24       	eor	r2, r2
    2fc8:	33 24       	eor	r3, r3
    2fca:	21 01       	movw	r4, r2
//Arguments: cluster number for which first sector is to be found
//return: first sector address
//***************************************************************************
unsigned long getFirstSector(unsigned long clusterNumber)
{
  return (((clusterNumber - 2) * sectorPerCluster) + firstDataSector);
    2fcc:	20 91 73 03 	lds	r18, 0x0373
    2fd0:	30 91 74 03 	lds	r19, 0x0374
    2fd4:	e0 90 5d 01 	lds	r14, 0x015D
    2fd8:	f0 90 5e 01 	lds	r15, 0x015E
    2fdc:	00 91 5f 01 	lds	r16, 0x015F
    2fe0:	10 91 60 01 	lds	r17, 0x0160
    2fe4:	c6 01       	movw	r24, r12
    2fe6:	b5 01       	movw	r22, r10
    2fe8:	62 50       	subi	r22, 0x02	; 2
    2fea:	70 40       	sbci	r23, 0x00	; 0
    2fec:	80 40       	sbci	r24, 0x00	; 0
    2fee:	90 40       	sbci	r25, 0x00	; 0
    2ff0:	40 e0       	ldi	r20, 0x00	; 0
    2ff2:	50 e0       	ldi	r21, 0x00	; 0
    2ff4:	0e 94 ac 1e 	call	0x3d58	; 0x3d58 <__mulsi3>
    2ff8:	3b 01       	movw	r6, r22
    2ffa:	4c 01       	movw	r8, r24
    2ffc:	6e 0c       	add	r6, r14
    2ffe:	7f 1c       	adc	r7, r15
    3000:	80 1e       	adc	r8, r16
    3002:	91 1e       	adc	r9, r17
    3004:	10 e0       	ldi	r17, 0x00	; 0
    3006:	28 c0       	rjmp	.+80     	; 0x3058 <readFile+0x112>
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
  {
    SD_readSingleBlock(firstSector + j);
    3008:	c4 01       	movw	r24, r8
    300a:	b3 01       	movw	r22, r6
    300c:	61 0f       	add	r22, r17
    300e:	71 1d       	adc	r23, r1
    3010:	81 1d       	adc	r24, r1
    3012:	91 1d       	adc	r25, r1
    3014:	0e 94 71 1d 	call	0x3ae2	; 0x3ae2 <SD_readSingleBlock>
    3018:	20 e0       	ldi	r18, 0x00	; 0
    301a:	30 e0       	ldi	r19, 0x00	; 0
    
	for(k=0; k<512; k++)
    {
     // transmitByte(buffer[k]);
	  // Sending to DAC
		PORTA = buffer[k];
    301c:	f9 01       	movw	r30, r18
    301e:	ed 58       	subi	r30, 0x8D	; 141
    3020:	fe 4f       	sbci	r31, 0xFE	; 254
    3022:	80 81       	ld	r24, Z
    3024:	8b bb       	out	0x1b, r24	; 27
    3026:	87 e7       	ldi	r24, 0x77	; 119
    3028:	91 e0       	ldi	r25, 0x01	; 1
    302a:	01 97       	sbiw	r24, 0x01	; 1
    302c:	f1 f7       	brne	.-4      	; 0x302a <readFile+0xe4>
	
	//	sample=(int)buffer[k];
	//	send_pwm(sample);
		_delay_ms(.125);

      if ((byteCounter++) >= fileSize ) return 0;
    302e:	89 81       	ldd	r24, Y+1	; 0x01
    3030:	9a 81       	ldd	r25, Y+2	; 0x02
    3032:	ab 81       	ldd	r26, Y+3	; 0x03
    3034:	bc 81       	ldd	r27, Y+4	; 0x04
    3036:	28 16       	cp	r2, r24
    3038:	39 06       	cpc	r3, r25
    303a:	4a 06       	cpc	r4, r26
    303c:	5b 06       	cpc	r5, r27
    303e:	50 f5       	brcc	.+84     	; 0x3094 <readFile+0x14e>
    3040:	08 94       	sec
    3042:	21 1c       	adc	r2, r1
    3044:	31 1c       	adc	r3, r1
    3046:	41 1c       	adc	r4, r1
    3048:	51 1c       	adc	r5, r1

  for(j=0; j<sectorPerCluster; j++)
  {
    SD_readSingleBlock(firstSector + j);
    
	for(k=0; k<512; k++)
    304a:	2f 5f       	subi	r18, 0xFF	; 255
    304c:	3f 4f       	sbci	r19, 0xFF	; 255
    304e:	92 e0       	ldi	r25, 0x02	; 2
    3050:	20 30       	cpi	r18, 0x00	; 0
    3052:	39 07       	cpc	r19, r25
    3054:	19 f7       	brne	.-58     	; 0x301c <readFile+0xd6>

while(1)
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
    3056:	1f 5f       	subi	r17, 0xFF	; 255
    3058:	20 91 73 03 	lds	r18, 0x0373
    305c:	30 91 74 03 	lds	r19, 0x0374
    3060:	81 2f       	mov	r24, r17
    3062:	90 e0       	ldi	r25, 0x00	; 0
    3064:	82 17       	cp	r24, r18
    3066:	93 07       	cpc	r25, r19
    3068:	78 f2       	brcs	.-98     	; 0x3008 <readFile+0xc2>
		_delay_ms(.125);

      if ((byteCounter++) >= fileSize ) return 0;
    }
  }
  cluster = getSetNextCluster (cluster, GET, 0);
    306a:	c6 01       	movw	r24, r12
    306c:	b5 01       	movw	r22, r10
    306e:	40 e0       	ldi	r20, 0x00	; 0
    3070:	00 e0       	ldi	r16, 0x00	; 0
    3072:	10 e0       	ldi	r17, 0x00	; 0
    3074:	20 e0       	ldi	r18, 0x00	; 0
    3076:	30 e0       	ldi	r19, 0x00	; 0
    3078:	0e 94 2b 15 	call	0x2a56	; 0x2a56 <getSetNextCluster>
    307c:	5b 01       	movw	r10, r22
    307e:	6c 01       	movw	r12, r24
  if(cluster == 0) {transmitString_F(PSTR("Error in getting cluster")); return 0;}
    3080:	61 15       	cp	r22, r1
    3082:	71 05       	cpc	r23, r1
    3084:	81 05       	cpc	r24, r1
    3086:	91 05       	cpc	r25, r1
    3088:	09 f0       	breq	.+2      	; 0x308c <readFile+0x146>
    308a:	a0 cf       	rjmp	.-192    	; 0x2fcc <readFile+0x86>
    308c:	8b e4       	ldi	r24, 0x4B	; 75
    308e:	91 e0       	ldi	r25, 0x01	; 1
    3090:	0e 94 43 1e 	call	0x3c86	; 0x3c86 <transmitString_F>
    3094:	80 e0       	ldi	r24, 0x00	; 0
}
return 0;
}
    3096:	0f 90       	pop	r0
    3098:	0f 90       	pop	r0
    309a:	0f 90       	pop	r0
    309c:	0f 90       	pop	r0
    309e:	cf 91       	pop	r28
    30a0:	df 91       	pop	r29
    30a2:	1f 91       	pop	r17
    30a4:	0f 91       	pop	r16
    30a6:	ff 90       	pop	r15
    30a8:	ef 90       	pop	r14
    30aa:	df 90       	pop	r13
    30ac:	cf 90       	pop	r12
    30ae:	bf 90       	pop	r11
    30b0:	af 90       	pop	r10
    30b2:	9f 90       	pop	r9
    30b4:	8f 90       	pop	r8
    30b6:	7f 90       	pop	r7
    30b8:	6f 90       	pop	r6
    30ba:	5f 90       	pop	r5
    30bc:	4f 90       	pop	r4
    30be:	3f 90       	pop	r3
    30c0:	2f 90       	pop	r2
    30c2:	08 95       	ret

000030c4 <writeFile>:
//			file name does not exist; if the file already exists then append the data
//Arguments: pointer to the file name
//return: none
//************************************************************************************
void writeFile (unsigned char *fileName)
{
    30c4:	2f 92       	push	r2
    30c6:	3f 92       	push	r3
    30c8:	4f 92       	push	r4
    30ca:	5f 92       	push	r5
    30cc:	6f 92       	push	r6
    30ce:	7f 92       	push	r7
    30d0:	8f 92       	push	r8
    30d2:	9f 92       	push	r9
    30d4:	af 92       	push	r10
    30d6:	bf 92       	push	r11
    30d8:	cf 92       	push	r12
    30da:	df 92       	push	r13
    30dc:	ef 92       	push	r14
    30de:	ff 92       	push	r15
    30e0:	0f 93       	push	r16
    30e2:	1f 93       	push	r17
    30e4:	df 93       	push	r29
    30e6:	cf 93       	push	r28
    30e8:	cd b7       	in	r28, 0x3d	; 61
    30ea:	de b7       	in	r29, 0x3e	; 62
    30ec:	27 97       	sbiw	r28, 0x07	; 7
    30ee:	0f b6       	in	r0, 0x3f	; 63
    30f0:	f8 94       	cli
    30f2:	de bf       	out	0x3e, r29	; 62
    30f4:	0f be       	out	0x3f, r0	; 63
    30f6:	cd bf       	out	0x3d, r28	; 61
    30f8:	9f 83       	std	Y+7, r25	; 0x07
    30fa:	8e 83       	std	Y+6, r24	; 0x06
unsigned char j, data, error, fileCreatedFlag = 0, start = 0, appendFile = 0, sectorEndFlag = 0, sector;
unsigned int i, firstClusterHigh, firstClusterLow;
struct dir_Structure *dir;
unsigned long cluster, nextCluster, prevCluster, firstSector, clusterCount, extraMemory;

j = readFile (VERIFY, fileName);
    30fc:	81 e0       	ldi	r24, 0x01	; 1
    30fe:	6e 81       	ldd	r22, Y+6	; 0x06
    3100:	7f 81       	ldd	r23, Y+7	; 0x07
    3102:	0e 94 a3 17 	call	0x2f46	; 0x2f46 <readFile>

if(j == 1) 
    3106:	81 30       	cpi	r24, 0x01	; 1
    3108:	09 f0       	breq	.+2      	; 0x310c <writeFile+0x48>
    310a:	57 c0       	rjmp	.+174    	; 0x31ba <writeFile+0xf6>
{
  transmitString_F(PSTR("  File already existing, appending data..")); 
    310c:	8e e0       	ldi	r24, 0x0E	; 14
    310e:	91 e0       	ldi	r25, 0x01	; 1
    3110:	0e 94 43 1e 	call	0x3c86	; 0x3c86 <transmitString_F>
  appendFile = 1;
  cluster = appendStartCluster;
    3114:	60 90 80 03 	lds	r6, 0x0380
    3118:	70 90 81 03 	lds	r7, 0x0381
    311c:	80 90 82 03 	lds	r8, 0x0382
    3120:	90 90 83 03 	lds	r9, 0x0383
    3124:	aa 24       	eor	r10, r10
    3126:	bb 24       	eor	r11, r11
    3128:	65 01       	movw	r12, r10
  clusterCount=0;
  while(1)
  {
    nextCluster = getSetNextCluster (cluster, GET, 0);
    312a:	c4 01       	movw	r24, r8
    312c:	b3 01       	movw	r22, r6
    312e:	40 e0       	ldi	r20, 0x00	; 0
    3130:	00 e0       	ldi	r16, 0x00	; 0
    3132:	10 e0       	ldi	r17, 0x00	; 0
    3134:	20 e0       	ldi	r18, 0x00	; 0
    3136:	30 e0       	ldi	r19, 0x00	; 0
    3138:	0e 94 2b 15 	call	0x2a56	; 0x2a56 <getSetNextCluster>
    if(nextCluster == EOF) break;
    313c:	6f 3f       	cpi	r22, 0xFF	; 255
    313e:	2f ef       	ldi	r18, 0xFF	; 255
    3140:	72 07       	cpc	r23, r18
    3142:	2f ef       	ldi	r18, 0xFF	; 255
    3144:	82 07       	cpc	r24, r18
    3146:	2f ef       	ldi	r18, 0xFF	; 255
    3148:	92 07       	cpc	r25, r18
    314a:	41 f0       	breq	.+16     	; 0x315c <writeFile+0x98>
	cluster = nextCluster;
	clusterCount++;
    314c:	08 94       	sec
    314e:	a1 1c       	adc	r10, r1
    3150:	b1 1c       	adc	r11, r1
    3152:	c1 1c       	adc	r12, r1
    3154:	d1 1c       	adc	r13, r1
    3156:	3b 01       	movw	r6, r22
    3158:	4c 01       	movw	r8, r24
    315a:	e7 cf       	rjmp	.-50     	; 0x312a <writeFile+0x66>
  }

  sector = (fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector; //last sector number of the last cluster of the file
    315c:	20 91 73 03 	lds	r18, 0x0373
    3160:	30 91 74 03 	lds	r19, 0x0374
    3164:	60 91 65 01 	lds	r22, 0x0165
    3168:	70 91 66 01 	lds	r23, 0x0166
    316c:	e0 90 65 01 	lds	r14, 0x0165
    3170:	f0 90 66 01 	lds	r15, 0x0166
    3174:	80 e0       	ldi	r24, 0x00	; 0
    3176:	90 e0       	ldi	r25, 0x00	; 0
    3178:	40 e0       	ldi	r20, 0x00	; 0
    317a:	50 e0       	ldi	r21, 0x00	; 0
    317c:	0e 94 ac 1e 	call	0x3d58	; 0x3d58 <__mulsi3>
    3180:	a6 01       	movw	r20, r12
    3182:	95 01       	movw	r18, r10
    3184:	0e 94 ac 1e 	call	0x3d58	; 0x3d58 <__mulsi3>
    3188:	9b 01       	movw	r18, r22
    318a:	ac 01       	movw	r20, r24
    318c:	60 91 61 01 	lds	r22, 0x0161
    3190:	70 91 62 01 	lds	r23, 0x0162
    3194:	80 91 63 01 	lds	r24, 0x0163
    3198:	90 91 64 01 	lds	r25, 0x0164
    319c:	62 1b       	sub	r22, r18
    319e:	73 0b       	sbc	r23, r19
    31a0:	84 0b       	sbc	r24, r20
    31a2:	95 0b       	sbc	r25, r21
    31a4:	00 e0       	ldi	r16, 0x00	; 0
    31a6:	10 e0       	ldi	r17, 0x00	; 0
    31a8:	a8 01       	movw	r20, r16
    31aa:	97 01       	movw	r18, r14
    31ac:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <__udivmodsi4>
    31b0:	b2 2e       	mov	r11, r18
    31b2:	21 e0       	ldi	r18, 0x01	; 1
    31b4:	aa 24       	eor	r10, r10
    31b6:	a3 94       	inc	r10
    31b8:	58 c0       	rjmp	.+176    	; 0x326a <writeFile+0x1a6>
  start = 1;
//  appendFile();
//  return;
}
else if(j == 2) 
    31ba:	82 30       	cpi	r24, 0x02	; 2
    31bc:	09 f4       	brne	.+2      	; 0x31c0 <writeFile+0xfc>
    31be:	23 c3       	rjmp	.+1606   	; 0x3806 <writeFile+0x742>
   return; //invalid file name
else
{
  TX_NEWLINE;
    31c0:	8d e0       	ldi	r24, 0x0D	; 13
    31c2:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <transmitByte>
    31c6:	8a e0       	ldi	r24, 0x0A	; 10
    31c8:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <transmitByte>
  transmitString_F(PSTR(" Creating File.."));
    31cc:	8d ef       	ldi	r24, 0xFD	; 253
    31ce:	90 e0       	ldi	r25, 0x00	; 0
    31d0:	0e 94 43 1e 	call	0x3c86	; 0x3c86 <transmitString_F>

  cluster = getSetFreeCluster (NEXT_FREE, GET, 0);
    31d4:	82 e0       	ldi	r24, 0x02	; 2
    31d6:	60 e0       	ldi	r22, 0x00	; 0
    31d8:	20 e0       	ldi	r18, 0x00	; 0
    31da:	30 e0       	ldi	r19, 0x00	; 0
    31dc:	40 e0       	ldi	r20, 0x00	; 0
    31de:	50 e0       	ldi	r21, 0x00	; 0
    31e0:	0e 94 2d 12 	call	0x245a	; 0x245a <getSetFreeCluster>
    31e4:	9b 01       	movw	r18, r22
    31e6:	ac 01       	movw	r20, r24
  if(cluster > totalClusters)
    31e8:	80 91 67 01 	lds	r24, 0x0167
    31ec:	90 91 68 01 	lds	r25, 0x0168
    31f0:	a0 91 69 01 	lds	r26, 0x0169
    31f4:	b0 91 6a 01 	lds	r27, 0x016A
    31f8:	82 17       	cp	r24, r18
    31fa:	93 07       	cpc	r25, r19
    31fc:	a4 07       	cpc	r26, r20
    31fe:	b5 07       	cpc	r27, r21
    3200:	40 f4       	brcc	.+16     	; 0x3212 <writeFile+0x14e>
     cluster = rootCluster;
    3202:	20 91 6b 01 	lds	r18, 0x016B
    3206:	30 91 6c 01 	lds	r19, 0x016C
    320a:	40 91 6d 01 	lds	r20, 0x016D
    320e:	50 91 6e 01 	lds	r21, 0x016E

  cluster = searchNextFreeCluster(cluster);
    3212:	ca 01       	movw	r24, r20
    3214:	b9 01       	movw	r22, r18
    3216:	0e 94 a3 11 	call	0x2346	; 0x2346 <searchNextFreeCluster>
    321a:	3b 01       	movw	r6, r22
    321c:	4c 01       	movw	r8, r24
   if(cluster == 0)
    321e:	61 15       	cp	r22, r1
    3220:	71 05       	cpc	r23, r1
    3222:	81 05       	cpc	r24, r1
    3224:	91 05       	cpc	r25, r1
    3226:	49 f4       	brne	.+18     	; 0x323a <writeFile+0x176>
   {
      TX_NEWLINE;
    3228:	8d e0       	ldi	r24, 0x0D	; 13
    322a:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <transmitByte>
    322e:	8a e0       	ldi	r24, 0x0A	; 10
    3230:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <transmitByte>
      transmitString_F(PSTR(" No free cluster!"));
    3234:	8b ee       	ldi	r24, 0xEB	; 235
    3236:	90 e0       	ldi	r25, 0x00	; 0
    3238:	e4 c2       	rjmp	.+1480   	; 0x3802 <writeFile+0x73e>
	  return;
   }
  getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
    323a:	41 e0       	ldi	r20, 0x01	; 1
    323c:	0f ef       	ldi	r16, 0xFF	; 255
    323e:	1f ef       	ldi	r17, 0xFF	; 255
    3240:	2f ef       	ldi	r18, 0xFF	; 255
    3242:	3f ef       	ldi	r19, 0xFF	; 255
    3244:	0e 94 2b 15 	call	0x2a56	; 0x2a56 <getSetNextCluster>
   
  firstClusterHigh = (unsigned int) ((cluster & 0xffff0000) >> 16 );
    3248:	c4 01       	movw	r24, r8
    324a:	aa 27       	eor	r26, r26
    324c:	bb 27       	eor	r27, r27
    324e:	9c 83       	std	Y+4, r25	; 0x04
    3250:	8b 83       	std	Y+3, r24	; 0x03
  firstClusterLow = (unsigned int) ( cluster & 0x0000ffff);
    3252:	7a 82       	std	Y+2, r7	; 0x02
    3254:	69 82       	std	Y+1, r6	; 0x01
  fileSize = 0;
    3256:	10 92 61 01 	sts	0x0161, r1
    325a:	10 92 62 01 	sts	0x0162, r1
    325e:	10 92 63 01 	sts	0x0163, r1
    3262:	10 92 64 01 	sts	0x0164, r1
    3266:	20 e0       	ldi	r18, 0x00	; 0
    3268:	aa 24       	eor	r10, r10
    326a:	1d 82       	std	Y+5, r1	; 0x05
while(1)
{
   if(start)
   {
      start = 0;
	  startBlock = getFirstSector (cluster) + sector;
    326c:	2b 2c       	mov	r2, r11
    326e:	33 24       	eor	r3, r3
    3270:	44 24       	eor	r4, r4
    3272:	55 24       	eor	r5, r5
    3274:	c4 01       	movw	r24, r8
    3276:	b3 01       	movw	r22, r6
    3278:	62 50       	subi	r22, 0x02	; 2
    327a:	70 40       	sbci	r23, 0x00	; 0
    327c:	80 40       	sbci	r24, 0x00	; 0
    327e:	90 40       	sbci	r25, 0x00	; 0



while(1)
{
   if(start)
    3280:	22 23       	and	r18, r18
    3282:	e9 f1       	breq	.+122    	; 0x32fe <writeFile+0x23a>
//Arguments: cluster number for which first sector is to be found
//return: first sector address
//***************************************************************************
unsigned long getFirstSector(unsigned long clusterNumber)
{
  return (((clusterNumber - 2) * sectorPerCluster) + firstDataSector);
    3284:	20 91 73 03 	lds	r18, 0x0373
    3288:	30 91 74 03 	lds	r19, 0x0374
    328c:	e0 90 5d 01 	lds	r14, 0x015D
    3290:	f0 90 5e 01 	lds	r15, 0x015E
    3294:	00 91 5f 01 	lds	r16, 0x015F
    3298:	10 91 60 01 	lds	r17, 0x0160
while(1)
{
   if(start)
   {
      start = 0;
	  startBlock = getFirstSector (cluster) + sector;
    329c:	e2 0c       	add	r14, r2
    329e:	f3 1c       	adc	r15, r3
    32a0:	04 1d       	adc	r16, r4
    32a2:	15 1d       	adc	r17, r5
    32a4:	40 e0       	ldi	r20, 0x00	; 0
    32a6:	50 e0       	ldi	r21, 0x00	; 0
    32a8:	0e 94 ac 1e 	call	0x3d58	; 0x3d58 <__mulsi3>
    32ac:	e6 0e       	add	r14, r22
    32ae:	f7 1e       	adc	r15, r23
    32b0:	08 1f       	adc	r16, r24
    32b2:	19 1f       	adc	r17, r25
    32b4:	e0 92 6f 01 	sts	0x016F, r14
    32b8:	f0 92 70 01 	sts	0x0170, r15
    32bc:	00 93 71 01 	sts	0x0171, r16
    32c0:	10 93 72 01 	sts	0x0172, r17
	  SD_readSingleBlock (startBlock);
    32c4:	60 91 6f 01 	lds	r22, 0x016F
    32c8:	70 91 70 01 	lds	r23, 0x0170
    32cc:	80 91 71 01 	lds	r24, 0x0171
    32d0:	90 91 72 01 	lds	r25, 0x0172
    32d4:	0e 94 71 1d 	call	0x3ae2	; 0x3ae2 <SD_readSingleBlock>
	  i = fileSize % bytesPerSector;
    32d8:	20 91 65 01 	lds	r18, 0x0165
    32dc:	30 91 66 01 	lds	r19, 0x0166
    32e0:	40 e0       	ldi	r20, 0x00	; 0
    32e2:	50 e0       	ldi	r21, 0x00	; 0
    32e4:	60 91 61 01 	lds	r22, 0x0161
    32e8:	70 91 62 01 	lds	r23, 0x0162
    32ec:	80 91 63 01 	lds	r24, 0x0163
    32f0:	90 91 64 01 	lds	r25, 0x0164
    32f4:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <__udivmodsi4>
    32f8:	8b 01       	movw	r16, r22
    32fa:	eb 2c       	mov	r14, r11
    32fc:	1f c0       	rjmp	.+62     	; 0x333c <writeFile+0x278>
//Arguments: cluster number for which first sector is to be found
//return: first sector address
//***************************************************************************
unsigned long getFirstSector(unsigned long clusterNumber)
{
  return (((clusterNumber - 2) * sectorPerCluster) + firstDataSector);
    32fe:	20 91 73 03 	lds	r18, 0x0373
    3302:	30 91 74 03 	lds	r19, 0x0374
    3306:	e0 90 5d 01 	lds	r14, 0x015D
    330a:	f0 90 5e 01 	lds	r15, 0x015E
    330e:	00 91 5f 01 	lds	r16, 0x015F
    3312:	10 91 60 01 	lds	r17, 0x0160
    3316:	40 e0       	ldi	r20, 0x00	; 0
    3318:	50 e0       	ldi	r21, 0x00	; 0
    331a:	0e 94 ac 1e 	call	0x3d58	; 0x3d58 <__mulsi3>
    331e:	e6 0e       	add	r14, r22
    3320:	f7 1e       	adc	r15, r23
    3322:	08 1f       	adc	r16, r24
    3324:	19 1f       	adc	r17, r25
	  i = fileSize % bytesPerSector;
	  j = sector;
   }
   else
   {
      startBlock = getFirstSector (cluster);
    3326:	e0 92 6f 01 	sts	0x016F, r14
    332a:	f0 92 70 01 	sts	0x0170, r15
    332e:	00 93 71 01 	sts	0x0171, r16
    3332:	10 93 72 01 	sts	0x0172, r17
    3336:	ee 24       	eor	r14, r14
    3338:	00 e0       	ldi	r16, 0x00	; 0
    333a:	10 e0       	ldi	r17, 0x00	; 0
	  i=0;
	  j=0;
   }
   

   TX_NEWLINE;
    333c:	8d e0       	ldi	r24, 0x0D	; 13
    333e:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <transmitByte>
    3342:	8a e0       	ldi	r24, 0x0A	; 10
    3344:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <transmitByte>
   transmitString_F(PSTR(" Enter text (end with ~):"));
    3348:	81 ed       	ldi	r24, 0xD1	; 209
    334a:	90 e0       	ldi	r25, 0x00	; 0
    334c:	0e 94 43 1e 	call	0x3c86	; 0x3c86 <transmitString_F>
   
   do
   {
     if(sectorEndFlag == 1) //special case when the last character in previous sector was '\r'
    3350:	8d 81       	ldd	r24, Y+5	; 0x05
    3352:	81 30       	cpi	r24, 0x01	; 1
    3354:	e9 f4       	brne	.+58     	; 0x3390 <writeFile+0x2cc>
	 {
	 	transmitByte ('\n');
    3356:	8a e0       	ldi	r24, 0x0A	; 10
    3358:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <transmitByte>
        buffer[i++] = '\n'; //appending 'Line Feed (LF)' character
    335c:	f8 01       	movw	r30, r16
    335e:	ed 58       	subi	r30, 0x8D	; 141
    3360:	fe 4f       	sbci	r31, 0xFE	; 254
    3362:	8a e0       	ldi	r24, 0x0A	; 10
    3364:	80 83       	st	Z, r24
    3366:	0f 5f       	subi	r16, 0xFF	; 255
    3368:	1f 4f       	sbci	r17, 0xFF	; 255
		fileSize++;
    336a:	80 91 61 01 	lds	r24, 0x0161
    336e:	90 91 62 01 	lds	r25, 0x0162
    3372:	a0 91 63 01 	lds	r26, 0x0163
    3376:	b0 91 64 01 	lds	r27, 0x0164
    337a:	01 96       	adiw	r24, 0x01	; 1
    337c:	a1 1d       	adc	r26, r1
    337e:	b1 1d       	adc	r27, r1
    3380:	80 93 61 01 	sts	0x0161, r24
    3384:	90 93 62 01 	sts	0x0162, r25
    3388:	a0 93 63 01 	sts	0x0163, r26
    338c:	b0 93 64 01 	sts	0x0164, r27
	 }

	sectorEndFlag = 0;

	 data = receiveByte();
    3390:	0e 94 3a 1e 	call	0x3c74	; 0x3c74 <receiveByte>
    3394:	f8 2e       	mov	r15, r24
	 if(data == 0x08)	//'Back Space' key pressed
    3396:	98 e0       	ldi	r25, 0x08	; 8
    3398:	89 17       	cp	r24, r25
    339a:	d1 f4       	brne	.+52     	; 0x33d0 <writeFile+0x30c>
	 { 
	   if(i != 0)
    339c:	01 15       	cp	r16, r1
    339e:	11 05       	cpc	r17, r1
    33a0:	b9 f3       	breq	.-18     	; 0x3390 <writeFile+0x2cc>
	   { 
	     transmitByte(data);
    33a2:	88 e0       	ldi	r24, 0x08	; 8
    33a4:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <transmitByte>
		 transmitByte(' '); 
    33a8:	80 e2       	ldi	r24, 0x20	; 32
    33aa:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <transmitByte>
	     transmitByte(data); 
    33ae:	88 e0       	ldi	r24, 0x08	; 8
    33b0:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <transmitByte>
	     i--; 
    33b4:	01 50       	subi	r16, 0x01	; 1
    33b6:	10 40       	sbci	r17, 0x00	; 0
		 fileSize--;
    33b8:	80 91 61 01 	lds	r24, 0x0161
    33bc:	90 91 62 01 	lds	r25, 0x0162
    33c0:	a0 91 63 01 	lds	r26, 0x0163
    33c4:	b0 91 64 01 	lds	r27, 0x0164
    33c8:	01 97       	sbiw	r24, 0x01	; 1
    33ca:	a1 09       	sbc	r26, r1
    33cc:	b1 09       	sbc	r27, r1
    33ce:	d8 cf       	rjmp	.-80     	; 0x3380 <writeFile+0x2bc>
	   } 
	   continue;     
	 }
	 transmitByte(data);
    33d0:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <transmitByte>
     buffer[i++] = data;
    33d4:	f8 01       	movw	r30, r16
    33d6:	ed 58       	subi	r30, 0x8D	; 141
    33d8:	fe 4f       	sbci	r31, 0xFE	; 254
    33da:	f0 82       	st	Z, r15
    33dc:	0f 5f       	subi	r16, 0xFF	; 255
    33de:	1f 4f       	sbci	r17, 0xFF	; 255
	 fileSize++;
    33e0:	80 91 61 01 	lds	r24, 0x0161
    33e4:	90 91 62 01 	lds	r25, 0x0162
    33e8:	a0 91 63 01 	lds	r26, 0x0163
    33ec:	b0 91 64 01 	lds	r27, 0x0164
    33f0:	01 96       	adiw	r24, 0x01	; 1
    33f2:	a1 1d       	adc	r26, r1
    33f4:	b1 1d       	adc	r27, r1
    33f6:	80 93 61 01 	sts	0x0161, r24
    33fa:	90 93 62 01 	sts	0x0162, r25
    33fe:	a0 93 63 01 	sts	0x0163, r26
    3402:	b0 93 64 01 	sts	0x0164, r27
     if(data == '\r')  //'Carriege Return (CR)' character
    3406:	ad e0       	ldi	r26, 0x0D	; 13
    3408:	fa 16       	cp	r15, r26
    340a:	21 f5       	brne	.+72     	; 0x3454 <writeFile+0x390>
     {
        if(i == 512)
    340c:	b2 e0       	ldi	r27, 0x02	; 2
    340e:	00 30       	cpi	r16, 0x00	; 0
    3410:	1b 07       	cpc	r17, r27
    3412:	19 f4       	brne	.+6      	; 0x341a <writeFile+0x356>
    3414:	e1 e0       	ldi	r30, 0x01	; 1
    3416:	ed 83       	std	Y+5, r30	; 0x05
    3418:	24 c0       	rjmp	.+72     	; 0x3462 <writeFile+0x39e>
		   sectorEndFlag = 1;  //flag to indicate that the appended '\n' char should be put in the next sector
	    else
		{ 
		   transmitByte ('\n');
    341a:	8a e0       	ldi	r24, 0x0A	; 10
    341c:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <transmitByte>
           buffer[i++] = '\n'; //appending 'Line Feed (LF)' character
    3420:	f8 01       	movw	r30, r16
    3422:	ed 58       	subi	r30, 0x8D	; 141
    3424:	fe 4f       	sbci	r31, 0xFE	; 254
    3426:	8a e0       	ldi	r24, 0x0A	; 10
    3428:	80 83       	st	Z, r24
    342a:	0f 5f       	subi	r16, 0xFF	; 255
    342c:	1f 4f       	sbci	r17, 0xFF	; 255
		   fileSize++;
    342e:	80 91 61 01 	lds	r24, 0x0161
    3432:	90 91 62 01 	lds	r25, 0x0162
    3436:	a0 91 63 01 	lds	r26, 0x0163
    343a:	b0 91 64 01 	lds	r27, 0x0164
    343e:	01 96       	adiw	r24, 0x01	; 1
    3440:	a1 1d       	adc	r26, r1
    3442:	b1 1d       	adc	r27, r1
    3444:	80 93 61 01 	sts	0x0161, r24
    3448:	90 93 62 01 	sts	0x0162, r25
    344c:	a0 93 63 01 	sts	0x0163, r26
    3450:	b0 93 64 01 	sts	0x0164, r27
	    }
     }
	 
     if(i >= 512)   //though 'i' will never become greater than 512, it's kept here to avoid 
    3454:	f2 e0       	ldi	r31, 0x02	; 2
    3456:	00 30       	cpi	r16, 0x00	; 0
    3458:	1f 07       	cpc	r17, r31
    345a:	10 f4       	brcc	.+4      	; 0x3460 <writeFile+0x39c>
    345c:	1d 82       	std	Y+5, r1	; 0x05
    345e:	2a c0       	rjmp	.+84     	; 0x34b4 <writeFile+0x3f0>
    3460:	1d 82       	std	Y+5, r1	; 0x05
	 {				//infinite loop in case it happens to be greater than 512 due to some data corruption
	   i=0;
	   error = SD_writeSingleBlock (startBlock);
    3462:	60 91 6f 01 	lds	r22, 0x016F
    3466:	70 91 70 01 	lds	r23, 0x0170
    346a:	80 91 71 01 	lds	r24, 0x0171
    346e:	90 91 72 01 	lds	r25, 0x0172
    3472:	0e 94 23 1d 	call	0x3a46	; 0x3a46 <SD_writeSingleBlock>
       j++;
    3476:	e3 94       	inc	r14
	   if(j == sectorPerCluster) {j = 0; break;}
    3478:	20 91 73 03 	lds	r18, 0x0373
    347c:	30 91 74 03 	lds	r19, 0x0374
    3480:	8e 2d       	mov	r24, r14
    3482:	90 e0       	ldi	r25, 0x00	; 0
    3484:	82 17       	cp	r24, r18
    3486:	93 07       	cpc	r25, r19
    3488:	d1 f0       	breq	.+52     	; 0x34be <writeFile+0x3fa>
	   startBlock++; 
    348a:	80 91 6f 01 	lds	r24, 0x016F
    348e:	90 91 70 01 	lds	r25, 0x0170
    3492:	a0 91 71 01 	lds	r26, 0x0171
    3496:	b0 91 72 01 	lds	r27, 0x0172
    349a:	01 96       	adiw	r24, 0x01	; 1
    349c:	a1 1d       	adc	r26, r1
    349e:	b1 1d       	adc	r27, r1
    34a0:	80 93 6f 01 	sts	0x016F, r24
    34a4:	90 93 70 01 	sts	0x0170, r25
    34a8:	a0 93 71 01 	sts	0x0171, r26
    34ac:	b0 93 72 01 	sts	0x0172, r27
    34b0:	00 e0       	ldi	r16, 0x00	; 0
    34b2:	10 e0       	ldi	r17, 0x00	; 0
     }
	}while (data != '~');
    34b4:	2e e7       	ldi	r18, 0x7E	; 126
    34b6:	f2 16       	cp	r15, r18
    34b8:	09 f0       	breq	.+2      	; 0x34bc <writeFile+0x3f8>
    34ba:	4a cf       	rjmp	.-364    	; 0x3350 <writeFile+0x28c>
    34bc:	05 c0       	rjmp	.+10     	; 0x34c8 <writeFile+0x404>

   if(data == '~') 
    34be:	8e e7       	ldi	r24, 0x7E	; 126
    34c0:	f8 16       	cp	r15, r24
    34c2:	b9 f5       	brne	.+110    	; 0x3532 <writeFile+0x46e>
    34c4:	00 e0       	ldi	r16, 0x00	; 0
    34c6:	10 e0       	ldi	r17, 0x00	; 0
   {
      fileSize--;	//to remove the last entered '~' character
    34c8:	80 91 61 01 	lds	r24, 0x0161
    34cc:	90 91 62 01 	lds	r25, 0x0162
    34d0:	a0 91 63 01 	lds	r26, 0x0163
    34d4:	b0 91 64 01 	lds	r27, 0x0164
    34d8:	01 97       	sbiw	r24, 0x01	; 1
    34da:	a1 09       	sbc	r26, r1
    34dc:	b1 09       	sbc	r27, r1
    34de:	80 93 61 01 	sts	0x0161, r24
    34e2:	90 93 62 01 	sts	0x0162, r25
    34e6:	a0 93 63 01 	sts	0x0163, r26
    34ea:	b0 93 64 01 	sts	0x0164, r27
	  i--;
    34ee:	b8 01       	movw	r22, r16
    34f0:	61 50       	subi	r22, 0x01	; 1
    34f2:	70 40       	sbci	r23, 0x00	; 0
    34f4:	06 c0       	rjmp	.+12     	; 0x3502 <writeFile+0x43e>
	  for(;i<512;i++)  //fill the rest of the buffer with 0x00
        buffer[i]= 0x00;
    34f6:	fb 01       	movw	r30, r22
    34f8:	ed 58       	subi	r30, 0x8D	; 141
    34fa:	fe 4f       	sbci	r31, 0xFE	; 254
    34fc:	10 82       	st	Z, r1

   if(data == '~') 
   {
      fileSize--;	//to remove the last entered '~' character
	  i--;
	  for(;i<512;i++)  //fill the rest of the buffer with 0x00
    34fe:	6f 5f       	subi	r22, 0xFF	; 255
    3500:	7f 4f       	sbci	r23, 0xFF	; 255
    3502:	92 e0       	ldi	r25, 0x02	; 2
    3504:	60 30       	cpi	r22, 0x00	; 0
    3506:	79 07       	cpc	r23, r25
    3508:	b0 f3       	brcs	.-20     	; 0x34f6 <writeFile+0x432>
        buffer[i]= 0x00;
   	  error = SD_writeSingleBlock (startBlock);
    350a:	60 91 6f 01 	lds	r22, 0x016F
    350e:	70 91 70 01 	lds	r23, 0x0170
    3512:	80 91 71 01 	lds	r24, 0x0171
    3516:	90 91 72 01 	lds	r25, 0x0172
    351a:	0e 94 23 1d 	call	0x3a46	; 0x3a46 <SD_writeSingleBlock>

   getSetNextCluster(prevCluster, SET, cluster);
   getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
}        

getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry
    351e:	82 e0       	ldi	r24, 0x02	; 2
    3520:	61 e0       	ldi	r22, 0x01	; 1
    3522:	a4 01       	movw	r20, r8
    3524:	93 01       	movw	r18, r6
    3526:	0e 94 2d 12 	call	0x245a	; 0x245a <getSetFreeCluster>

if(appendFile)  //executes this loop if file is to be appended
    352a:	aa 20       	and	r10, r10
    352c:	09 f4       	brne	.+2      	; 0x3530 <writeFile+0x46c>
    352e:	6f c0       	rjmp	.+222    	; 0x360e <writeFile+0x54a>
    3530:	28 c0       	rjmp	.+80     	; 0x3582 <writeFile+0x4be>
      break;
   } 
	  
   prevCluster = cluster;

   cluster = searchNextFreeCluster(prevCluster); //look for a free cluster starting from the current cluster
    3532:	c4 01       	movw	r24, r8
    3534:	b3 01       	movw	r22, r6
    3536:	0e 94 a3 11 	call	0x2346	; 0x2346 <searchNextFreeCluster>
    353a:	6b 01       	movw	r12, r22
    353c:	7c 01       	movw	r14, r24

   if(cluster == 0)
    353e:	61 15       	cp	r22, r1
    3540:	71 05       	cpc	r23, r1
    3542:	81 05       	cpc	r24, r1
    3544:	91 05       	cpc	r25, r1
    3546:	49 f4       	brne	.+18     	; 0x355a <writeFile+0x496>
   {
      TX_NEWLINE;
    3548:	8d e0       	ldi	r24, 0x0D	; 13
    354a:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <transmitByte>
    354e:	8a e0       	ldi	r24, 0x0A	; 10
    3550:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <transmitByte>
      transmitString_F(PSTR(" No free cluster!"));
    3554:	8f eb       	ldi	r24, 0xBF	; 191
    3556:	90 e0       	ldi	r25, 0x00	; 0
    3558:	54 c1       	rjmp	.+680    	; 0x3802 <writeFile+0x73e>
	  return;
   }

   getSetNextCluster(prevCluster, SET, cluster);
    355a:	c4 01       	movw	r24, r8
    355c:	b3 01       	movw	r22, r6
    355e:	41 e0       	ldi	r20, 0x01	; 1
    3560:	97 01       	movw	r18, r14
    3562:	86 01       	movw	r16, r12
    3564:	0e 94 2b 15 	call	0x2a56	; 0x2a56 <getSetNextCluster>
   getSetNextCluster(cluster, SET, EOF);   //last cluster of the file, marked EOF
    3568:	c7 01       	movw	r24, r14
    356a:	b6 01       	movw	r22, r12
    356c:	41 e0       	ldi	r20, 0x01	; 1
    356e:	0f ef       	ldi	r16, 0xFF	; 255
    3570:	1f ef       	ldi	r17, 0xFF	; 255
    3572:	2f ef       	ldi	r18, 0xFF	; 255
    3574:	3f ef       	ldi	r19, 0xFF	; 255
    3576:	0e 94 2b 15 	call	0x2a56	; 0x2a56 <getSetNextCluster>
    357a:	20 e0       	ldi	r18, 0x00	; 0
    357c:	36 01       	movw	r6, r12
    357e:	47 01       	movw	r8, r14
    3580:	79 ce       	rjmp	.-782    	; 0x3274 <writeFile+0x1b0>

getSetFreeCluster (NEXT_FREE, SET, cluster); //update FSinfo next free cluster entry

if(appendFile)  //executes this loop if file is to be appended
{
  SD_readSingleBlock (appendFileSector);    
    3582:	60 91 91 03 	lds	r22, 0x0391
    3586:	70 91 92 03 	lds	r23, 0x0392
    358a:	80 91 93 03 	lds	r24, 0x0393
    358e:	90 91 94 03 	lds	r25, 0x0394
    3592:	0e 94 71 1d 	call	0x3ae2	; 0x3ae2 <SD_readSingleBlock>
  dir = (struct dir_Structure *) &buffer[appendFileLocation]; 
    3596:	e0 91 59 01 	lds	r30, 0x0159
    359a:	f0 91 5a 01 	lds	r31, 0x015A
    359e:	ed 58       	subi	r30, 0x8D	; 141
    35a0:	fe 4f       	sbci	r31, 0xFE	; 254
  extraMemory = fileSize - dir->fileSize;
    35a2:	20 91 61 01 	lds	r18, 0x0161
    35a6:	30 91 62 01 	lds	r19, 0x0162
    35aa:	40 91 63 01 	lds	r20, 0x0163
    35ae:	50 91 64 01 	lds	r21, 0x0164
    35b2:	84 8d       	ldd	r24, Z+28	; 0x1c
    35b4:	95 8d       	ldd	r25, Z+29	; 0x1d
    35b6:	a6 8d       	ldd	r26, Z+30	; 0x1e
    35b8:	b7 8d       	ldd	r27, Z+31	; 0x1f
    35ba:	79 01       	movw	r14, r18
    35bc:	8a 01       	movw	r16, r20
    35be:	e8 1a       	sub	r14, r24
    35c0:	f9 0a       	sbc	r15, r25
    35c2:	0a 0b       	sbc	r16, r26
    35c4:	1b 0b       	sbc	r17, r27
  dir->fileSize = fileSize;
    35c6:	24 8f       	std	Z+28, r18	; 0x1c
    35c8:	35 8f       	std	Z+29, r19	; 0x1d
    35ca:	46 8f       	std	Z+30, r20	; 0x1e
    35cc:	57 8f       	std	Z+31, r21	; 0x1f
  SD_writeSingleBlock (appendFileSector);
    35ce:	60 91 91 03 	lds	r22, 0x0391
    35d2:	70 91 92 03 	lds	r23, 0x0392
    35d6:	80 91 93 03 	lds	r24, 0x0393
    35da:	90 91 94 03 	lds	r25, 0x0394
    35de:	0e 94 23 1d 	call	0x3a46	; 0x3a46 <SD_writeSingleBlock>
  freeMemoryUpdate (REMOVE, extraMemory); //updating free memory count in FSinfo sector;
    35e2:	81 e0       	ldi	r24, 0x01	; 1
    35e4:	b8 01       	movw	r22, r16
    35e6:	a7 01       	movw	r20, r14
    35e8:	0e 94 b4 12 	call	0x2568	; 0x2568 <freeMemoryUpdate>

  
  TX_NEWLINE;
    35ec:	8d e0       	ldi	r24, 0x0D	; 13
    35ee:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <transmitByte>
    35f2:	8a e0       	ldi	r24, 0x0A	; 10
    35f4:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <transmitByte>
  transmitString_F(PSTR(" File appended!"));
    35f8:	8f ea       	ldi	r24, 0xAF	; 175
    35fa:	90 e0       	ldi	r25, 0x00	; 0
    35fc:	0e 94 43 1e 	call	0x3c86	; 0x3c86 <transmitString_F>
  TX_NEWLINE;
    3600:	8d e0       	ldi	r24, 0x0D	; 13
    3602:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <transmitByte>
    3606:	8a e0       	ldi	r24, 0x0A	; 10
    3608:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <transmitByte>
    360c:	fc c0       	rjmp	.+504    	; 0x3806 <writeFile+0x742>
  return;
}

//executes following portion when new file is created

prevCluster = rootCluster; //root cluster
    360e:	80 90 6b 01 	lds	r8, 0x016B
    3612:	90 90 6c 01 	lds	r9, 0x016C
    3616:	a0 90 6d 01 	lds	r10, 0x016D
    361a:	b0 90 6e 01 	lds	r11, 0x016E
    361e:	22 24       	eor	r2, r2
//Arguments: cluster number for which first sector is to be found
//return: first sector address
//***************************************************************************
unsigned long getFirstSector(unsigned long clusterNumber)
{
  return (((clusterNumber - 2) * sectorPerCluster) + firstDataSector);
    3620:	20 91 73 03 	lds	r18, 0x0373
    3624:	30 91 74 03 	lds	r19, 0x0374
    3628:	e0 90 5d 01 	lds	r14, 0x015D
    362c:	f0 90 5e 01 	lds	r15, 0x015E
    3630:	00 91 5f 01 	lds	r16, 0x015F
    3634:	10 91 60 01 	lds	r17, 0x0160
    3638:	c5 01       	movw	r24, r10
    363a:	b4 01       	movw	r22, r8
    363c:	62 50       	subi	r22, 0x02	; 2
    363e:	70 40       	sbci	r23, 0x00	; 0
    3640:	80 40       	sbci	r24, 0x00	; 0
    3642:	90 40       	sbci	r25, 0x00	; 0
    3644:	40 e0       	ldi	r20, 0x00	; 0
    3646:	50 e0       	ldi	r21, 0x00	; 0
    3648:	0e 94 ac 1e 	call	0x3d58	; 0x3d58 <__mulsi3>
    364c:	2b 01       	movw	r4, r22
    364e:	3c 01       	movw	r6, r24
    3650:	4e 0c       	add	r4, r14
    3652:	5f 1c       	adc	r5, r15
    3654:	60 1e       	adc	r6, r16
    3656:	71 1e       	adc	r7, r17
    3658:	33 24       	eor	r3, r3
    365a:	8a c0       	rjmp	.+276    	; 0x3770 <writeFile+0x6ac>
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_readSingleBlock (firstSector + sector);
    365c:	73 01       	movw	r14, r6
    365e:	62 01       	movw	r12, r4
    3660:	c3 0c       	add	r12, r3
    3662:	d1 1c       	adc	r13, r1
    3664:	e1 1c       	adc	r14, r1
    3666:	f1 1c       	adc	r15, r1
    3668:	c7 01       	movw	r24, r14
    366a:	b6 01       	movw	r22, r12
    366c:	0e 94 71 1d 	call	0x3ae2	; 0x3ae2 <SD_readSingleBlock>
    3670:	00 e2       	ldi	r16, 0x20	; 32
    3672:	10 e0       	ldi	r17, 0x00	; 0
    3674:	72 c0       	rjmp	.+228    	; 0x375a <writeFile+0x696>
	

     for(i=0; i<bytesPerSector; i+=32)
    3676:	af 01       	movw	r20, r30
    3678:	4d 58       	subi	r20, 0x8D	; 141
    367a:	5e 4f       	sbci	r21, 0xFE	; 254
     {
	    dir = (struct dir_Structure *) &buffer[i];

		if(fileCreatedFlag)   //to mark last directory entry with 0x00 (empty) mark
    367c:	22 20       	and	r2, r2
    367e:	19 f0       	breq	.+6      	; 0x3686 <writeFile+0x5c2>
		 { 					  //indicating end of the directory file list
		   dir->name[0] = 0x00;
    3680:	da 01       	movw	r26, r20
    3682:	1c 92       	st	X, r1
    3684:	c0 c0       	rjmp	.+384    	; 0x3806 <writeFile+0x742>
           return;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
    3686:	f8 01       	movw	r30, r16
    3688:	ed 5a       	subi	r30, 0xAD	; 173
    368a:	fe 4f       	sbci	r31, 0xFE	; 254
    368c:	e0 81       	ld	r30, Z
    368e:	ee 23       	and	r30, r30
    3690:	19 f0       	breq	.+6      	; 0x3698 <writeFile+0x5d4>
    3692:	e5 3e       	cpi	r30, 0xE5	; 229
    3694:	09 f0       	breq	.+2      	; 0x3698 <writeFile+0x5d4>
    3696:	5f c0       	rjmp	.+190    	; 0x3756 <writeFile+0x692>
    3698:	20 e0       	ldi	r18, 0x00	; 0
    369a:	30 e0       	ldi	r19, 0x00	; 0
		{
		  for(j=0; j<11; j++)
  			dir->name[j] = fileName[j];
    369c:	ba 01       	movw	r22, r20
    369e:	62 0f       	add	r22, r18
    36a0:	73 1f       	adc	r23, r19
    36a2:	ae 81       	ldd	r26, Y+6	; 0x06
    36a4:	bf 81       	ldd	r27, Y+7	; 0x07
    36a6:	a2 0f       	add	r26, r18
    36a8:	b3 1f       	adc	r27, r19
    36aa:	8c 91       	ld	r24, X
    36ac:	fb 01       	movw	r30, r22
    36ae:	80 83       	st	Z, r24
    36b0:	2f 5f       	subi	r18, 0xFF	; 255
    36b2:	3f 4f       	sbci	r19, 0xFF	; 255
           return;
         }

        if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
		{
		  for(j=0; j<11; j++)
    36b4:	2b 30       	cpi	r18, 0x0B	; 11
    36b6:	31 05       	cpc	r19, r1
    36b8:	89 f7       	brne	.-30     	; 0x369c <writeFile+0x5d8>
  			dir->name[j] = fileName[j];
		  dir->attrib = ATTR_ARCHIVE;	//settting file attribute as 'archive'
    36ba:	f8 01       	movw	r30, r16
    36bc:	ed 58       	subi	r30, 0x8D	; 141
    36be:	fe 4f       	sbci	r31, 0xFE	; 254
    36c0:	75 97       	sbiw	r30, 0x15	; 21
    36c2:	20 e2       	ldi	r18, 0x20	; 32
    36c4:	21 93       	st	Z+, r18
		  dir->NTreserved = 0;			//always set to 0
    36c6:	11 92       	st	Z+, r1
		  dir->timeTenth = 0;			//always set to 0
    36c8:	11 92       	st	Z+, r1
		  dir->createTime = 0x9684;		//fixed time of creation
    36ca:	84 e8       	ldi	r24, 0x84	; 132
    36cc:	96 e9       	ldi	r25, 0x96	; 150
    36ce:	81 93       	st	Z+, r24
    36d0:	91 93       	st	Z+, r25
		  dir->createDate = 0x3a37;		//fixed date of creation
    36d2:	a7 e3       	ldi	r26, 0x37	; 55
    36d4:	ba e3       	ldi	r27, 0x3A	; 58
    36d6:	a1 93       	st	Z+, r26
    36d8:	b1 93       	st	Z+, r27
		  dir->lastAccessDate = 0x3a37;	//fixed date of last access
    36da:	b1 83       	std	Z+1, r27	; 0x01
    36dc:	a0 83       	st	Z, r26
		  dir->writeTime = 0x9684;		//fixed time of last write
    36de:	34 96       	adiw	r30, 0x04	; 4
    36e0:	81 93       	st	Z+, r24
    36e2:	91 93       	st	Z+, r25
		  dir->writeDate = 0x3a37;		//fixed date of last write
    36e4:	b1 83       	std	Z+1, r27	; 0x01
    36e6:	a0 83       	st	Z, r26
		  dir->firstClusterHI = firstClusterHigh;
    36e8:	34 97       	sbiw	r30, 0x04	; 4
    36ea:	8b 81       	ldd	r24, Y+3	; 0x03
    36ec:	9c 81       	ldd	r25, Y+4	; 0x04
    36ee:	91 83       	std	Z+1, r25	; 0x01
    36f0:	80 83       	st	Z, r24
		  dir->firstClusterLO = firstClusterLow;
    36f2:	36 96       	adiw	r30, 0x06	; 6
    36f4:	a9 81       	ldd	r26, Y+1	; 0x01
    36f6:	ba 81       	ldd	r27, Y+2	; 0x02
    36f8:	a1 93       	st	Z+, r26
    36fa:	b1 93       	st	Z+, r27
		  dir->fileSize = fileSize;
    36fc:	80 91 61 01 	lds	r24, 0x0161
    3700:	90 91 62 01 	lds	r25, 0x0162
    3704:	a0 91 63 01 	lds	r26, 0x0163
    3708:	b0 91 64 01 	lds	r27, 0x0164
    370c:	80 83       	st	Z, r24
    370e:	91 83       	std	Z+1, r25	; 0x01
    3710:	a2 83       	std	Z+2, r26	; 0x02
    3712:	b3 83       	std	Z+3, r27	; 0x03

		  SD_writeSingleBlock (firstSector + sector);
    3714:	c7 01       	movw	r24, r14
    3716:	b6 01       	movw	r22, r12
    3718:	0e 94 23 1d 	call	0x3a46	; 0x3a46 <SD_writeSingleBlock>
		  fileCreatedFlag = 1;

		  TX_NEWLINE;
    371c:	8d e0       	ldi	r24, 0x0D	; 13
    371e:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <transmitByte>
    3722:	8a e0       	ldi	r24, 0x0A	; 10
    3724:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <transmitByte>
		  TX_NEWLINE;
    3728:	8d e0       	ldi	r24, 0x0D	; 13
    372a:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <transmitByte>
    372e:	8a e0       	ldi	r24, 0x0A	; 10
    3730:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <transmitByte>
		  transmitString_F(PSTR(" File Created!"));
    3734:	80 ea       	ldi	r24, 0xA0	; 160
    3736:	90 e0       	ldi	r25, 0x00	; 0
    3738:	0e 94 43 1e 	call	0x3c86	; 0x3c86 <transmitString_F>

		  freeMemoryUpdate (REMOVE, fileSize); //updating free memory count in FSinfo sector
    373c:	40 91 61 01 	lds	r20, 0x0161
    3740:	50 91 62 01 	lds	r21, 0x0162
    3744:	60 91 63 01 	lds	r22, 0x0163
    3748:	70 91 64 01 	lds	r23, 0x0164
    374c:	81 e0       	ldi	r24, 0x01	; 1
    374e:	0e 94 b4 12 	call	0x2568	; 0x2568 <freeMemoryUpdate>
    3752:	22 24       	eor	r2, r2
    3754:	23 94       	inc	r2
    3756:	00 5e       	subi	r16, 0xE0	; 224
    3758:	1f 4f       	sbci	r17, 0xFF	; 255
   for(sector = 0; sector < sectorPerCluster; sector++)
   {
     SD_readSingleBlock (firstSector + sector);
	

     for(i=0; i<bytesPerSector; i+=32)
    375a:	80 91 65 01 	lds	r24, 0x0165
    375e:	90 91 66 01 	lds	r25, 0x0166
    3762:	f8 01       	movw	r30, r16
    3764:	b0 97       	sbiw	r30, 0x20	; 32
    3766:	e8 17       	cp	r30, r24
    3768:	f9 07       	cpc	r31, r25
    376a:	08 f4       	brcc	.+2      	; 0x376e <writeFile+0x6aa>
    376c:	84 cf       	rjmp	.-248    	; 0x3676 <writeFile+0x5b2>

while(1)
{
   firstSector = getFirstSector (prevCluster);

   for(sector = 0; sector < sectorPerCluster; sector++)
    376e:	33 94       	inc	r3
    3770:	20 91 73 03 	lds	r18, 0x0373
    3774:	30 91 74 03 	lds	r19, 0x0374
    3778:	83 2d       	mov	r24, r3
    377a:	90 e0       	ldi	r25, 0x00	; 0
    377c:	82 17       	cp	r24, r18
    377e:	93 07       	cpc	r25, r19
    3780:	08 f4       	brcc	.+2      	; 0x3784 <writeFile+0x6c0>
    3782:	6c cf       	rjmp	.-296    	; 0x365c <writeFile+0x598>
	     
        }
     }
   }

   cluster = getSetNextCluster (prevCluster, GET, 0);
    3784:	c5 01       	movw	r24, r10
    3786:	b4 01       	movw	r22, r8
    3788:	40 e0       	ldi	r20, 0x00	; 0
    378a:	00 e0       	ldi	r16, 0x00	; 0
    378c:	10 e0       	ldi	r17, 0x00	; 0
    378e:	20 e0       	ldi	r18, 0x00	; 0
    3790:	30 e0       	ldi	r19, 0x00	; 0
    3792:	0e 94 2b 15 	call	0x2a56	; 0x2a56 <getSetNextCluster>
    3796:	6b 01       	movw	r12, r22
    3798:	7c 01       	movw	r14, r24

   if(cluster > 0x0ffffff6)
    379a:	67 3f       	cpi	r22, 0xF7	; 247
    379c:	bf ef       	ldi	r27, 0xFF	; 255
    379e:	7b 07       	cpc	r23, r27
    37a0:	bf ef       	ldi	r27, 0xFF	; 255
    37a2:	8b 07       	cpc	r24, r27
    37a4:	bf e0       	ldi	r27, 0x0F	; 15
    37a6:	9b 07       	cpc	r25, r27
    37a8:	10 f1       	brcs	.+68     	; 0x37ee <writeFile+0x72a>
   {
      if(cluster == EOF)   //this situation will come when total files in root is multiple of (32*sectorPerCluster)
    37aa:	6f 3f       	cpi	r22, 0xFF	; 255
    37ac:	ef ef       	ldi	r30, 0xFF	; 255
    37ae:	7e 07       	cpc	r23, r30
    37b0:	ef ef       	ldi	r30, 0xFF	; 255
    37b2:	8e 07       	cpc	r24, r30
    37b4:	ef ef       	ldi	r30, 0xFF	; 255
    37b6:	9e 07       	cpc	r25, r30
    37b8:	b9 f4       	brne	.+46     	; 0x37e8 <writeFile+0x724>
	  {  
		cluster = searchNextFreeCluster(prevCluster); //find next cluster for root directory entries
    37ba:	c5 01       	movw	r24, r10
    37bc:	b4 01       	movw	r22, r8
    37be:	0e 94 a3 11 	call	0x2346	; 0x2346 <searchNextFreeCluster>
    37c2:	6b 01       	movw	r12, r22
    37c4:	7c 01       	movw	r14, r24
		getSetNextCluster(prevCluster, SET, cluster); //link the new cluster of root to the previous cluster
    37c6:	c5 01       	movw	r24, r10
    37c8:	b4 01       	movw	r22, r8
    37ca:	41 e0       	ldi	r20, 0x01	; 1
    37cc:	97 01       	movw	r18, r14
    37ce:	86 01       	movw	r16, r12
    37d0:	0e 94 2b 15 	call	0x2a56	; 0x2a56 <getSetNextCluster>
		getSetNextCluster(cluster, SET, EOF);  //set the new cluster as end of the root directory
    37d4:	c7 01       	movw	r24, r14
    37d6:	b6 01       	movw	r22, r12
    37d8:	41 e0       	ldi	r20, 0x01	; 1
    37da:	0f ef       	ldi	r16, 0xFF	; 255
    37dc:	1f ef       	ldi	r17, 0xFF	; 255
    37de:	2f ef       	ldi	r18, 0xFF	; 255
    37e0:	3f ef       	ldi	r19, 0xFF	; 255
    37e2:	0e 94 2b 15 	call	0x2a56	; 0x2a56 <getSetNextCluster>
    37e6:	03 c0       	rjmp	.+6      	; 0x37ee <writeFile+0x72a>
      } 

      else
      {	
	    transmitString_F(PSTR("End of Cluster Chain")); 
    37e8:	8b e8       	ldi	r24, 0x8B	; 139
    37ea:	90 e0       	ldi	r25, 0x00	; 0
    37ec:	0a c0       	rjmp	.+20     	; 0x3802 <writeFile+0x73e>
	    return;
    37ee:	46 01       	movw	r8, r12
    37f0:	57 01       	movw	r10, r14
      }
   }
   if(cluster == 0) {transmitString_F(PSTR("Error in getting cluster")); return;}
    37f2:	c1 14       	cp	r12, r1
    37f4:	d1 04       	cpc	r13, r1
    37f6:	e1 04       	cpc	r14, r1
    37f8:	f1 04       	cpc	r15, r1
    37fa:	09 f0       	breq	.+2      	; 0x37fe <writeFile+0x73a>
    37fc:	11 cf       	rjmp	.-478    	; 0x3620 <writeFile+0x55c>
    37fe:	82 e7       	ldi	r24, 0x72	; 114
    3800:	90 e0       	ldi	r25, 0x00	; 0
    3802:	0e 94 43 1e 	call	0x3c86	; 0x3c86 <transmitString_F>
   
   prevCluster = cluster;
 }
 
 return;
}
    3806:	27 96       	adiw	r28, 0x07	; 7
    3808:	0f b6       	in	r0, 0x3f	; 63
    380a:	f8 94       	cli
    380c:	de bf       	out	0x3e, r29	; 62
    380e:	0f be       	out	0x3f, r0	; 63
    3810:	cd bf       	out	0x3d, r28	; 61
    3812:	cf 91       	pop	r28
    3814:	df 91       	pop	r29
    3816:	1f 91       	pop	r17
    3818:	0f 91       	pop	r16
    381a:	ff 90       	pop	r15
    381c:	ef 90       	pop	r14
    381e:	df 90       	pop	r13
    3820:	cf 90       	pop	r12
    3822:	bf 90       	pop	r11
    3824:	af 90       	pop	r10
    3826:	9f 90       	pop	r9
    3828:	8f 90       	pop	r8
    382a:	7f 90       	pop	r7
    382c:	6f 90       	pop	r6
    382e:	5f 90       	pop	r5
    3830:	4f 90       	pop	r4
    3832:	3f 90       	pop	r3
    3834:	2f 90       	pop	r2
    3836:	08 95       	ret

00003838 <LCD_WriteCommand>:
void LCD_WriteCommand (unsigned char Command)

{


  SET_LCD_CMD; // Set LCD in command mode
    3838:	a8 98       	cbi	0x15, 0	; 21


  PORTD = Command; // Load data to port
    383a:	82 bb       	out	0x12, r24	; 18


  ENABLE_LCD; // Write data to LCD
    383c:	a9 9a       	sbi	0x15, 1	; 21


  asm("nop");
    383e:	00 00       	nop

  asm("nop");
    3840:	00 00       	nop

  DISABLE_LCD; // Disable LCD
    3842:	a9 98       	cbi	0x15, 1	; 21
    3844:	88 eb       	ldi	r24, 0xB8	; 184
    3846:	9b e0       	ldi	r25, 0x0B	; 11
    3848:	01 97       	sbiw	r24, 0x01	; 1
    384a:	f1 f7       	brne	.-4      	; 0x3848 <LCD_WriteCommand+0x10>

  _delay_ms(1); // wait for 1ms

}
    384c:	08 95       	ret

0000384e <LCD_WriteData>:

void LCD_WriteData (unsigned char Data)

{

  SET_LCD_DATA; // Set LCD in data mode
    384e:	a8 9a       	sbi	0x15, 0	; 21


  PORTD = Data; // Load data to port
    3850:	82 bb       	out	0x12, r24	; 18


  ENABLE_LCD; // Write data to LCD
    3852:	a9 9a       	sbi	0x15, 1	; 21


  asm("nop");
    3854:	00 00       	nop

  asm("nop");
    3856:	00 00       	nop


  DISABLE_LCD; // Disable LCD
    3858:	a9 98       	cbi	0x15, 1	; 21
    385a:	88 eb       	ldi	r24, 0xB8	; 184
    385c:	9b e0       	ldi	r25, 0x0B	; 11
    385e:	01 97       	sbiw	r24, 0x01	; 1
    3860:	f1 f7       	brne	.-4      	; 0x385e <LCD_WriteData+0x10>

  _delay_ms(1); // wait for 1ms

}
    3862:	08 95       	ret

00003864 <LCD_Cursor>:

void LCD_Cursor (char row, char column)

{

  switch (row)
    3864:	81 30       	cpi	r24, 0x01	; 1
    3866:	19 f0       	breq	.+6      	; 0x386e <LCD_Cursor+0xa>
    3868:	82 30       	cpi	r24, 0x02	; 2
    386a:	51 f4       	brne	.+20     	; 0x3880 <LCD_Cursor+0x1c>
    386c:	05 c0       	rjmp	.+10     	; 0x3878 <LCD_Cursor+0x14>

  {

    case 1: LCD_WriteCommand (0x80 + column - 1); break;
    386e:	86 2f       	mov	r24, r22
    3870:	81 58       	subi	r24, 0x81	; 129
    3872:	0e 94 1c 1c 	call	0x3838	; 0x3838 <LCD_WriteCommand>
    3876:	08 95       	ret

    case 2: LCD_WriteCommand (0xc0 + column - 1); break;
    3878:	86 2f       	mov	r24, r22
    387a:	81 54       	subi	r24, 0x41	; 65
    387c:	0e 94 1c 1c 	call	0x3838	; 0x3838 <LCD_WriteCommand>
    3880:	08 95       	ret

00003882 <LCD_DisplayString_F>:

//*************************************************************

void LCD_DisplayString_F (char row, char column ,const unsigned char *string)

{
    3882:	cf 93       	push	r28
    3884:	df 93       	push	r29
    3886:	ea 01       	movw	r28, r20

  LCD_Cursor (row, column);
    3888:	0e 94 32 1c 	call	0x3864	; 0x3864 <LCD_Cursor>
    388c:	03 c0       	rjmp	.+6      	; 0x3894 <LCD_DisplayString_F+0x12>

  while (*string)

    LCD_WriteData(*string++);
    388e:	21 96       	adiw	r28, 0x01	; 1
    3890:	0e 94 27 1c 	call	0x384e	; 0x384e <LCD_WriteData>

{

  LCD_Cursor (row, column);

  while (*string)
    3894:	88 81       	ld	r24, Y
    3896:	88 23       	and	r24, r24
    3898:	d1 f7       	brne	.-12     	; 0x388e <LCD_DisplayString_F+0xc>

    LCD_WriteData(*string++);

}
    389a:	df 91       	pop	r29
    389c:	cf 91       	pop	r28
    389e:	08 95       	ret

000038a0 <delay_ms>:

// ********************************************************

void delay_ms(int miliSec) //for 16 Mhz crystal

{
    38a0:	40 e0       	ldi	r20, 0x00	; 0
    38a2:	50 e0       	ldi	r21, 0x00	; 0
    38a4:	0c c0       	rjmp	.+24     	; 0x38be <delay_ms+0x1e>

    int i,j;

    for(i=0;i<miliSec;i++)
    38a6:	20 e0       	ldi	r18, 0x00	; 0
    38a8:	30 e0       	ldi	r19, 0x00	; 0

    for(j=0;j<1550;j++)

  {

   asm("nop");
    38aa:	00 00       	nop

   asm("nop");
    38ac:	00 00       	nop

    int i,j;

    for(i=0;i<miliSec;i++)

    for(j=0;j<1550;j++)
    38ae:	2f 5f       	subi	r18, 0xFF	; 255
    38b0:	3f 4f       	sbci	r19, 0xFF	; 255
    38b2:	66 e0       	ldi	r22, 0x06	; 6
    38b4:	2e 30       	cpi	r18, 0x0E	; 14
    38b6:	36 07       	cpc	r19, r22
    38b8:	c1 f7       	brne	.-16     	; 0x38aa <delay_ms+0xa>

{

    int i,j;

    for(i=0;i<miliSec;i++)
    38ba:	4f 5f       	subi	r20, 0xFF	; 255
    38bc:	5f 4f       	sbci	r21, 0xFF	; 255
    38be:	48 17       	cp	r20, r24
    38c0:	59 07       	cpc	r21, r25
    38c2:	8c f3       	brlt	.-30     	; 0x38a6 <delay_ms+0x6>

   asm("nop");

  }

}
    38c4:	08 95       	ret

000038c6 <LCD_init>:

void LCD_init(void)

{

  delay_ms(100); // wait for 100ms
    38c6:	84 e6       	ldi	r24, 0x64	; 100
    38c8:	90 e0       	ldi	r25, 0x00	; 0
    38ca:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <delay_ms>

  LCD_WriteCommand (0x38); // 8 data lines
    38ce:	88 e3       	ldi	r24, 0x38	; 56
    38d0:	0e 94 1c 1c 	call	0x3838	; 0x3838 <LCD_WriteCommand>

  LCD_WriteCommand (0x06); // cursor setting
    38d4:	86 e0       	ldi	r24, 0x06	; 6
    38d6:	0e 94 1c 1c 	call	0x3838	; 0x3838 <LCD_WriteCommand>

  LCD_WriteCommand (0x0f); // display ON
    38da:	8f e0       	ldi	r24, 0x0F	; 15
    38dc:	0e 94 1c 1c 	call	0x3838	; 0x3838 <LCD_WriteCommand>

  LCD_WriteCommand (0x01); // clear LCD memory
    38e0:	81 e0       	ldi	r24, 0x01	; 1
    38e2:	0e 94 1c 1c 	call	0x3838	; 0x3838 <LCD_WriteCommand>

  delay_ms (10); // 10ms delay after clearing LCD
    38e6:	8a e0       	ldi	r24, 0x0A	; 10
    38e8:	90 e0       	ldi	r25, 0x00	; 0
    38ea:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <delay_ms>

}
    38ee:	08 95       	ret

000038f0 <init_pwm>:
{
	


	/* use OC1A pin as output */
    DDRD = _BV(PD5);
    38f0:	80 e2       	ldi	r24, 0x20	; 32
    38f2:	81 bb       	out	0x11, r24	; 17
    /*
    * clear OC1A on compare match
    * set OC1A at BOTTOM, non-inverting mode
    * Fast PWM, 8bit
    */
    TCCR1A = _BV(COM1A1) | _BV(WGM10);
    38f4:	81 e8       	ldi	r24, 0x81	; 129
    38f6:	8f bd       	out	0x2f, r24	; 47
    /*
    * Fast PWM, 8bit
    * Prescaler: clk/1 = 12MHz
    * PWM frequency = 12MHz / (255 + 1) = 46.875kHz
    */
    TCCR1B = _BV(WGM12) | _BV(CS10);
    38f8:	89 e0       	ldi	r24, 0x09	; 9
    38fa:	8e bd       	out	0x2e, r24	; 46
   
    /* set initial duty cycle to zero */
    OCR1A = 0;
    38fc:	1b bc       	out	0x2b, r1	; 43
    38fe:	1a bc       	out	0x2a, r1	; 42
   

};
    3900:	08 95       	ret

00003902 <send_pwm>:


void send_pwm(int duty)
{

	OCR1A = duty;
    3902:	9b bd       	out	0x2b, r25	; 43
    3904:	8a bd       	out	0x2a, r24	; 42
};
    3906:	08 95       	ret

00003908 <SD_sendCommand>:
// 			  & unsigned long (32-bit command argument)
//return	: unsigned char; response byte
//******************************************************************

unsigned char SD_sendCommand(unsigned char cmd, unsigned long arg)
{
    3908:	df 92       	push	r13
    390a:	ef 92       	push	r14
    390c:	ff 92       	push	r15
    390e:	0f 93       	push	r16
    3910:	1f 93       	push	r17
    3912:	d8 2e       	mov	r13, r24
    3914:	7a 01       	movw	r14, r20
    3916:	8b 01       	movw	r16, r22
	//so, if it's SD card we need to convert block address into corresponding byte address by 
	//multipying it with 512. which is equivalent to shifting it left 9 times
	//following 'if' loop does that


	if(SDHC_flag == 0)		
    3918:	80 91 79 03 	lds	r24, 0x0379
    391c:	88 23       	and	r24, r24
    391e:	b9 f4       	brne	.+46     	; 0x394e <SD_sendCommand+0x46>
	if(	cmd == READ_SINGLE_BLOCK     ||
    3920:	8d 2d       	mov	r24, r13
    3922:	81 51       	subi	r24, 0x11	; 17
    3924:	82 30       	cpi	r24, 0x02	; 2
    3926:	60 f0       	brcs	.+24     	; 0x3940 <SD_sendCommand+0x38>
    3928:	88 e1       	ldi	r24, 0x18	; 24
    392a:	d8 16       	cp	r13, r24
    392c:	49 f0       	breq	.+18     	; 0x3940 <SD_sendCommand+0x38>
    392e:	89 e1       	ldi	r24, 0x19	; 25
    3930:	d8 16       	cp	r13, r24
    3932:	31 f0       	breq	.+12     	; 0x3940 <SD_sendCommand+0x38>
    3934:	80 e2       	ldi	r24, 0x20	; 32
    3936:	d8 16       	cp	r13, r24
    3938:	19 f0       	breq	.+6      	; 0x3940 <SD_sendCommand+0x38>
    393a:	81 e2       	ldi	r24, 0x21	; 33
    393c:	d8 16       	cp	r13, r24
    393e:	39 f4       	brne	.+14     	; 0x394e <SD_sendCommand+0x46>
		cmd == WRITE_SINGLE_BLOCK    ||
		cmd == WRITE_MULTIPLE_BLOCKS ||
		cmd == ERASE_BLOCK_START_ADDR|| 
		cmd == ERASE_BLOCK_END_ADDR ) 
		{
			arg = arg << 9;
    3940:	39 e0       	ldi	r19, 0x09	; 9
    3942:	ee 0c       	add	r14, r14
    3944:	ff 1c       	adc	r15, r15
    3946:	00 1f       	adc	r16, r16
    3948:	11 1f       	adc	r17, r17
    394a:	3a 95       	dec	r19
    394c:	d1 f7       	brne	.-12     	; 0x3942 <SD_sendCommand+0x3a>
		}	   

	SD_CS_ASSERT;
    394e:	c1 98       	cbi	0x18, 1	; 24

	SPI_transmit(cmd | 0x40); //send command, first two bits always '01'
    3950:	8d 2d       	mov	r24, r13
    3952:	80 64       	ori	r24, 0x40	; 64
    3954:	0e 94 20 1e 	call	0x3c40	; 0x3c40 <SPI_transmit>
	SPI_transmit(arg>>24);
    3958:	81 2f       	mov	r24, r17
    395a:	99 27       	eor	r25, r25
    395c:	aa 27       	eor	r26, r26
    395e:	bb 27       	eor	r27, r27
    3960:	0e 94 20 1e 	call	0x3c40	; 0x3c40 <SPI_transmit>
	SPI_transmit(arg>>16);
    3964:	c8 01       	movw	r24, r16
    3966:	aa 27       	eor	r26, r26
    3968:	bb 27       	eor	r27, r27
    396a:	0e 94 20 1e 	call	0x3c40	; 0x3c40 <SPI_transmit>
	SPI_transmit(arg>>8);
    396e:	bb 27       	eor	r27, r27
    3970:	a1 2f       	mov	r26, r17
    3972:	90 2f       	mov	r25, r16
    3974:	8f 2d       	mov	r24, r15
    3976:	0e 94 20 1e 	call	0x3c40	; 0x3c40 <SPI_transmit>
	SPI_transmit(arg);
    397a:	8e 2d       	mov	r24, r14
    397c:	0e 94 20 1e 	call	0x3c40	; 0x3c40 <SPI_transmit>

	if(cmd == SEND_IF_COND)	 //it is compulsory to send correct CRC for CMD8 (CRC=0x87) & CMD0 (CRC=0x95)
    3980:	88 e0       	ldi	r24, 0x08	; 8
    3982:	d8 16       	cp	r13, r24
    3984:	11 f4       	brne	.+4      	; 0x398a <SD_sendCommand+0x82>
		SPI_transmit(0x87);    //for remaining commands, CRC is ignored in SPI mode
    3986:	87 e8       	ldi	r24, 0x87	; 135
    3988:	01 c0       	rjmp	.+2      	; 0x398c <SD_sendCommand+0x84>
	else 
		SPI_transmit(0x95); 
    398a:	85 e9       	ldi	r24, 0x95	; 149
    398c:	0e 94 20 1e 	call	0x3c40	; 0x3c40 <SPI_transmit>

	while((response = SPI_receive()) == 0xff) //wait response
		if(retry++ > 0xfe) break; //time out error
    3990:	10 e0       	ldi	r17, 0x00	; 0
    3992:	02 c0       	rjmp	.+4      	; 0x3998 <SD_sendCommand+0x90>
	SPI_transmit(arg);

	if(cmd == SEND_IF_COND)	 //it is compulsory to send correct CRC for CMD8 (CRC=0x87) & CMD0 (CRC=0x95)
		SPI_transmit(0x87);    //for remaining commands, CRC is ignored in SPI mode
	else 
		SPI_transmit(0x95); 
    3994:	11 50       	subi	r17, 0x01	; 1

	while((response = SPI_receive()) == 0xff) //wait response
		if(retry++ > 0xfe) break; //time out error
    3996:	d1 f0       	breq	.+52     	; 0x39cc <SD_sendCommand+0xc4>
	if(cmd == SEND_IF_COND)	 //it is compulsory to send correct CRC for CMD8 (CRC=0x87) & CMD0 (CRC=0x95)
		SPI_transmit(0x87);    //for remaining commands, CRC is ignored in SPI mode
	else 
		SPI_transmit(0x95); 

	while((response = SPI_receive()) == 0xff) //wait response
    3998:	0e 94 25 1e 	call	0x3c4a	; 0x3c4a <SPI_receive>
    399c:	08 2f       	mov	r16, r24
    399e:	8f 3f       	cpi	r24, 0xFF	; 255
    39a0:	c9 f3       	breq	.-14     	; 0x3994 <SD_sendCommand+0x8c>
		if(retry++ > 0xfe) break; //time out error

	if(response == 0x00 && cmd == 58)  //checking response of CMD58
    39a2:	88 23       	and	r24, r24
    39a4:	99 f4       	brne	.+38     	; 0x39cc <SD_sendCommand+0xc4>
    39a6:	8a e3       	ldi	r24, 0x3A	; 58
    39a8:	d8 16       	cp	r13, r24
    39aa:	81 f4       	brne	.+32     	; 0x39cc <SD_sendCommand+0xc4>
		{
			status = SPI_receive() & 0x40;     //first byte of the OCR register (bit 31:24)
    39ac:	0e 94 25 1e 	call	0x3c4a	; 0x3c4a <SPI_receive>
			if(status == 0x40) SDHC_flag = 1;  //we need it to verify SDHC card
    39b0:	86 ff       	sbrs	r24, 6
    39b2:	04 c0       	rjmp	.+8      	; 0x39bc <SD_sendCommand+0xb4>
    39b4:	81 e0       	ldi	r24, 0x01	; 1
    39b6:	80 93 79 03 	sts	0x0379, r24
    39ba:	02 c0       	rjmp	.+4      	; 0x39c0 <SD_sendCommand+0xb8>
			else SDHC_flag = 0;
    39bc:	10 92 79 03 	sts	0x0379, r1

			SPI_receive(); //remaining 3 bytes of the OCR register are ignored here
    39c0:	0e 94 25 1e 	call	0x3c4a	; 0x3c4a <SPI_receive>
			SPI_receive(); //one can use these bytes to check power supply limits of SD
    39c4:	0e 94 25 1e 	call	0x3c4a	; 0x3c4a <SPI_receive>
			SPI_receive(); 
    39c8:	0e 94 25 1e 	call	0x3c4a	; 0x3c4a <SPI_receive>
		}

	SPI_receive(); //extra 8 CLK
    39cc:	0e 94 25 1e 	call	0x3c4a	; 0x3c4a <SPI_receive>
	SD_CS_DEASSERT;
    39d0:	c1 9a       	sbi	0x18, 1	; 24

	return response; //return state
}
    39d2:	80 2f       	mov	r24, r16
    39d4:	1f 91       	pop	r17
    39d6:	0f 91       	pop	r16
    39d8:	ff 90       	pop	r15
    39da:	ef 90       	pop	r14
    39dc:	df 90       	pop	r13
    39de:	08 95       	ret

000039e0 <SD_erase>:
//Arguments	: none
//return	: unsigned char; will be 0 if no error,
// 			  otherwise the response byte will be sent
//*****************************************************************
unsigned char SD_erase (unsigned long startBlock, unsigned long totalBlocks)
{
    39e0:	af 92       	push	r10
    39e2:	bf 92       	push	r11
    39e4:	cf 92       	push	r12
    39e6:	df 92       	push	r13
    39e8:	ef 92       	push	r14
    39ea:	ff 92       	push	r15
    39ec:	0f 93       	push	r16
    39ee:	1f 93       	push	r17
    39f0:	7b 01       	movw	r14, r22
    39f2:	8c 01       	movw	r16, r24
    39f4:	59 01       	movw	r10, r18
    39f6:	6a 01       	movw	r12, r20
	unsigned char response;

	response = SD_sendCommand(ERASE_BLOCK_START_ADDR, startBlock); //send starting block address
    39f8:	80 e2       	ldi	r24, 0x20	; 32
    39fa:	b8 01       	movw	r22, r16
    39fc:	a7 01       	movw	r20, r14
    39fe:	0e 94 84 1c 	call	0x3908	; 0x3908 <SD_sendCommand>
	if(response != 0x00) //check for SD status: 0x00 - OK (No flags set)
    3a02:	88 23       	and	r24, r24
    3a04:	b9 f4       	brne	.+46     	; 0x3a34 <SD_erase+0x54>
		return response;

	response = SD_sendCommand(ERASE_BLOCK_END_ADDR,(startBlock + totalBlocks - 1)); //send end block address
    3a06:	08 94       	sec
    3a08:	e1 08       	sbc	r14, r1
    3a0a:	f1 08       	sbc	r15, r1
    3a0c:	01 09       	sbc	r16, r1
    3a0e:	11 09       	sbc	r17, r1
    3a10:	ea 0c       	add	r14, r10
    3a12:	fb 1c       	adc	r15, r11
    3a14:	0c 1d       	adc	r16, r12
    3a16:	1d 1d       	adc	r17, r13
    3a18:	81 e2       	ldi	r24, 0x21	; 33
    3a1a:	b8 01       	movw	r22, r16
    3a1c:	a7 01       	movw	r20, r14
    3a1e:	0e 94 84 1c 	call	0x3908	; 0x3908 <SD_sendCommand>
	if(response != 0x00)
    3a22:	88 23       	and	r24, r24
    3a24:	39 f4       	brne	.+14     	; 0x3a34 <SD_erase+0x54>
		return response;

	response = SD_sendCommand(ERASE_SELECTED_BLOCKS, 0); //erase all selected blocks
    3a26:	86 e2       	ldi	r24, 0x26	; 38
    3a28:	40 e0       	ldi	r20, 0x00	; 0
    3a2a:	50 e0       	ldi	r21, 0x00	; 0
    3a2c:	60 e0       	ldi	r22, 0x00	; 0
    3a2e:	70 e0       	ldi	r23, 0x00	; 0
    3a30:	0e 94 84 1c 	call	0x3908	; 0x3908 <SD_sendCommand>
	if(response != 0x00)
		return response;

	return 0; //normal return
}
    3a34:	1f 91       	pop	r17
    3a36:	0f 91       	pop	r16
    3a38:	ff 90       	pop	r15
    3a3a:	ef 90       	pop	r14
    3a3c:	df 90       	pop	r13
    3a3e:	cf 90       	pop	r12
    3a40:	bf 90       	pop	r11
    3a42:	af 90       	pop	r10
    3a44:	08 95       	ret

00003a46 <SD_writeSingleBlock>:
//Arguments	: none
//return	: unsigned char; will be 0 if no error,
// 			  otherwise the response byte will be sent
//******************************************************************
unsigned char SD_writeSingleBlock(unsigned long startBlock)
{
    3a46:	cf 93       	push	r28
    3a48:	df 93       	push	r29
    3a4a:	ab 01       	movw	r20, r22
    3a4c:	bc 01       	movw	r22, r24
	unsigned char response;
	unsigned int i, retry=0;

	response = SD_sendCommand(WRITE_SINGLE_BLOCK, startBlock); //write a Block command
    3a4e:	88 e1       	ldi	r24, 0x18	; 24
    3a50:	0e 94 84 1c 	call	0x3908	; 0x3908 <SD_sendCommand>
  
	if(response != 0x00) return response; //check for SD status: 0x00 - OK (No flags set)
    3a54:	88 23       	and	r24, r24
    3a56:	11 f0       	breq	.+4      	; 0x3a5c <SD_writeSingleBlock+0x16>
    3a58:	98 2f       	mov	r25, r24
    3a5a:	3f c0       	rjmp	.+126    	; 0x3ada <SD_writeSingleBlock+0x94>

	SD_CS_ASSERT;
    3a5c:	c1 98       	cbi	0x18, 1	; 24

	SPI_transmit(0xfe);     //Send start block token 0xfe (0x11111110)
    3a5e:	8e ef       	ldi	r24, 0xFE	; 254
    3a60:	0e 94 20 1e 	call	0x3c40	; 0x3c40 <SPI_transmit>
    3a64:	c0 e0       	ldi	r28, 0x00	; 0
    3a66:	d0 e0       	ldi	r29, 0x00	; 0

	for(i=0; i<512; i++)    //send 512 bytes data
		SPI_transmit(buffer[i]);
    3a68:	fe 01       	movw	r30, r28
    3a6a:	ed 58       	subi	r30, 0x8D	; 141
    3a6c:	fe 4f       	sbci	r31, 0xFE	; 254
    3a6e:	80 81       	ld	r24, Z
    3a70:	0e 94 20 1e 	call	0x3c40	; 0x3c40 <SPI_transmit>

	SD_CS_ASSERT;

	SPI_transmit(0xfe);     //Send start block token 0xfe (0x11111110)

	for(i=0; i<512; i++)    //send 512 bytes data
    3a74:	21 96       	adiw	r28, 0x01	; 1
    3a76:	82 e0       	ldi	r24, 0x02	; 2
    3a78:	c0 30       	cpi	r28, 0x00	; 0
    3a7a:	d8 07       	cpc	r29, r24
    3a7c:	a9 f7       	brne	.-22     	; 0x3a68 <SD_writeSingleBlock+0x22>
		SPI_transmit(buffer[i]);

	SPI_transmit(0xff);     //transmit dummy CRC (16-bit), CRC is ignored here
    3a7e:	8f ef       	ldi	r24, 0xFF	; 255
    3a80:	0e 94 20 1e 	call	0x3c40	; 0x3c40 <SPI_transmit>
	SPI_transmit(0xff);
    3a84:	8f ef       	ldi	r24, 0xFF	; 255
    3a86:	0e 94 20 1e 	call	0x3c40	; 0x3c40 <SPI_transmit>

	response = SPI_receive();
    3a8a:	0e 94 25 1e 	call	0x3c4a	; 0x3c4a <SPI_receive>
    3a8e:	98 2f       	mov	r25, r24

	if( (response & 0x1f) != 0x05) //response= 0xXXX0AAA1 ; AAA='010' - data accepted
    3a90:	8f 71       	andi	r24, 0x1F	; 31
    3a92:	85 30       	cpi	r24, 0x05	; 5
    3a94:	41 f0       	breq	.+16     	; 0x3aa6 <SD_writeSingleBlock+0x60>
	{                              //AAA='101'-data rejected due to CRC error
		SD_CS_DEASSERT;              //AAA='110'-data rejected due to write error
    3a96:	c1 9a       	sbi	0x18, 1	; 24
    3a98:	20 c0       	rjmp	.+64     	; 0x3ada <SD_writeSingleBlock+0x94>
		return response;
	}

	while(!SPI_receive()) //wait for SD card to complete writing and get idle
		if(retry++ > 0xfffe){SD_CS_DEASSERT; return 1;}
    3a9a:	8f ef       	ldi	r24, 0xFF	; 255
    3a9c:	cf 3f       	cpi	r28, 0xFF	; 255
    3a9e:	d8 07       	cpc	r29, r24
    3aa0:	91 f0       	breq	.+36     	; 0x3ac6 <SD_writeSingleBlock+0x80>
    3aa2:	21 96       	adiw	r28, 0x01	; 1
    3aa4:	02 c0       	rjmp	.+4      	; 0x3aaa <SD_writeSingleBlock+0x64>
    3aa6:	c0 e0       	ldi	r28, 0x00	; 0
    3aa8:	d0 e0       	ldi	r29, 0x00	; 0
	{                              //AAA='101'-data rejected due to CRC error
		SD_CS_DEASSERT;              //AAA='110'-data rejected due to write error
		return response;
	}

	while(!SPI_receive()) //wait for SD card to complete writing and get idle
    3aaa:	0e 94 25 1e 	call	0x3c4a	; 0x3c4a <SPI_receive>
    3aae:	88 23       	and	r24, r24
    3ab0:	a1 f3       	breq	.-24     	; 0x3a9a <SD_writeSingleBlock+0x54>
		if(retry++ > 0xfffe){SD_CS_DEASSERT; return 1;}

	SD_CS_DEASSERT;
    3ab2:	c1 9a       	sbi	0x18, 1	; 24
	SPI_transmit(0xff);   //just spend 8 clock cycle delay before reasserting the CS line
    3ab4:	8f ef       	ldi	r24, 0xFF	; 255
    3ab6:	0e 94 20 1e 	call	0x3c40	; 0x3c40 <SPI_transmit>
	SD_CS_ASSERT;         //re-asserting the CS line to verify if card is still busy
    3aba:	c1 98       	cbi	0x18, 1	; 24
    3abc:	08 c0       	rjmp	.+16     	; 0x3ace <SD_writeSingleBlock+0x88>

	while(!SPI_receive()) //wait for SD card to complete writing and get idle
		if(retry++ > 0xfffe){SD_CS_DEASSERT; return 1;}
    3abe:	8f ef       	ldi	r24, 0xFF	; 255
    3ac0:	cf 3f       	cpi	r28, 0xFF	; 255
    3ac2:	d8 07       	cpc	r29, r24
    3ac4:	19 f4       	brne	.+6      	; 0x3acc <SD_writeSingleBlock+0x86>
    3ac6:	c1 9a       	sbi	0x18, 1	; 24
    3ac8:	91 e0       	ldi	r25, 0x01	; 1
    3aca:	07 c0       	rjmp	.+14     	; 0x3ada <SD_writeSingleBlock+0x94>
    3acc:	21 96       	adiw	r28, 0x01	; 1

	SD_CS_DEASSERT;
	SPI_transmit(0xff);   //just spend 8 clock cycle delay before reasserting the CS line
	SD_CS_ASSERT;         //re-asserting the CS line to verify if card is still busy

	while(!SPI_receive()) //wait for SD card to complete writing and get idle
    3ace:	0e 94 25 1e 	call	0x3c4a	; 0x3c4a <SPI_receive>
    3ad2:	88 23       	and	r24, r24
    3ad4:	a1 f3       	breq	.-24     	; 0x3abe <SD_writeSingleBlock+0x78>
		if(retry++ > 0xfffe){SD_CS_DEASSERT; return 1;}
	SD_CS_DEASSERT;
    3ad6:	c1 9a       	sbi	0x18, 1	; 24
    3ad8:	90 e0       	ldi	r25, 0x00	; 0

	return 0;
}
    3ada:	89 2f       	mov	r24, r25
    3adc:	df 91       	pop	r29
    3ade:	cf 91       	pop	r28
    3ae0:	08 95       	ret

00003ae2 <SD_readSingleBlock>:
//Arguments	: none
//return	: unsigned char; will be 0 if no error,
// 			  otherwise the response byte will be sent
//******************************************************************
unsigned char SD_readSingleBlock(unsigned long startBlock)
{
    3ae2:	1f 93       	push	r17
    3ae4:	cf 93       	push	r28
    3ae6:	df 93       	push	r29
    3ae8:	ab 01       	movw	r20, r22
    3aea:	bc 01       	movw	r22, r24
	unsigned char response;
	unsigned int i, retry=0;

	response = SD_sendCommand(READ_SINGLE_BLOCK, startBlock); //read a Block command
    3aec:	81 e1       	ldi	r24, 0x11	; 17
    3aee:	0e 94 84 1c 	call	0x3908	; 0x3908 <SD_sendCommand>
    3af2:	18 2f       	mov	r17, r24
 
	if(response != 0x00) return response; //check for SD status: 0x00 - OK (No flags set)
    3af4:	88 23       	and	r24, r24
    3af6:	09 f5       	brne	.+66     	; 0x3b3a <SD_readSingleBlock+0x58>

	SD_CS_ASSERT;
    3af8:	c1 98       	cbi	0x18, 1	; 24
    3afa:	c0 e0       	ldi	r28, 0x00	; 0
    3afc:	d0 e0       	ldi	r29, 0x00	; 0
    3afe:	05 c0       	rjmp	.+10     	; 0x3b0a <SD_readSingleBlock+0x28>

	retry = 0;
	while(SPI_receive() != 0xfe) //wait for start block token 0xfe (0x11111110)
    3b00:	21 97       	sbiw	r28, 0x01	; 1
		if(retry++ > 0xfffe){SD_CS_DEASSERT; return 1;} //return if time-out
    3b02:	19 f4       	brne	.+6      	; 0x3b0a <SD_readSingleBlock+0x28>
    3b04:	c1 9a       	sbi	0x18, 1	; 24
    3b06:	11 e0       	ldi	r17, 0x01	; 1
    3b08:	18 c0       	rjmp	.+48     	; 0x3b3a <SD_readSingleBlock+0x58>
	if(response != 0x00) return response; //check for SD status: 0x00 - OK (No flags set)

	SD_CS_ASSERT;

	retry = 0;
	while(SPI_receive() != 0xfe) //wait for start block token 0xfe (0x11111110)
    3b0a:	0e 94 25 1e 	call	0x3c4a	; 0x3c4a <SPI_receive>
    3b0e:	8e 3f       	cpi	r24, 0xFE	; 254
    3b10:	b9 f7       	brne	.-18     	; 0x3b00 <SD_readSingleBlock+0x1e>
    3b12:	c0 e0       	ldi	r28, 0x00	; 0
    3b14:	d0 e0       	ldi	r29, 0x00	; 0
		if(retry++ > 0xfffe){SD_CS_DEASSERT; return 1;} //return if time-out

	for(i=0; i<512; i++) //read 512 bytes
		buffer[i] = SPI_receive();
    3b16:	0e 94 25 1e 	call	0x3c4a	; 0x3c4a <SPI_receive>
    3b1a:	fe 01       	movw	r30, r28
    3b1c:	ed 58       	subi	r30, 0x8D	; 141
    3b1e:	fe 4f       	sbci	r31, 0xFE	; 254
    3b20:	80 83       	st	Z, r24

	retry = 0;
	while(SPI_receive() != 0xfe) //wait for start block token 0xfe (0x11111110)
		if(retry++ > 0xfffe){SD_CS_DEASSERT; return 1;} //return if time-out

	for(i=0; i<512; i++) //read 512 bytes
    3b22:	21 96       	adiw	r28, 0x01	; 1
    3b24:	82 e0       	ldi	r24, 0x02	; 2
    3b26:	c0 30       	cpi	r28, 0x00	; 0
    3b28:	d8 07       	cpc	r29, r24
    3b2a:	a9 f7       	brne	.-22     	; 0x3b16 <SD_readSingleBlock+0x34>
		buffer[i] = SPI_receive();

	SPI_receive(); //receive incoming CRC (16-bit), CRC is ignored here
    3b2c:	0e 94 25 1e 	call	0x3c4a	; 0x3c4a <SPI_receive>
	SPI_receive();
    3b30:	0e 94 25 1e 	call	0x3c4a	; 0x3c4a <SPI_receive>

	SPI_receive(); //extra 8 clock pulses
    3b34:	0e 94 25 1e 	call	0x3c4a	; 0x3c4a <SPI_receive>
	SD_CS_DEASSERT;
    3b38:	c1 9a       	sbi	0x18, 1	; 24

	return 0;
}
    3b3a:	81 2f       	mov	r24, r17
    3b3c:	df 91       	pop	r29
    3b3e:	cf 91       	pop	r28
    3b40:	1f 91       	pop	r17
    3b42:	08 95       	ret

00003b44 <SD_init>:
//Arguments	: none
//return	: unsigned char; will be 0 if no error,
// 			  otherwise the response byte will be sent
//******************************************************************
unsigned char SD_init(void)
{
    3b44:	1f 93       	push	r17
    3b46:	cf 93       	push	r28
    3b48:	df 93       	push	r29
    3b4a:	10 e0       	ldi	r17, 0x00	; 0
	unsigned char i, response, SD_version;
	unsigned int retry=0 ;


	for(i=0;i<10;i++)
      SPI_transmit(0xff);   //80 clock pulses spent before sending the first command
    3b4c:	8f ef       	ldi	r24, 0xFF	; 255
    3b4e:	0e 94 20 1e 	call	0x3c40	; 0x3c40 <SPI_transmit>
{
	unsigned char i, response, SD_version;
	unsigned int retry=0 ;


	for(i=0;i<10;i++)
    3b52:	1f 5f       	subi	r17, 0xFF	; 255
    3b54:	1a 30       	cpi	r17, 0x0A	; 10
    3b56:	d1 f7       	brne	.-12     	; 0x3b4c <SD_init+0x8>
      SPI_transmit(0xff);   //80 clock pulses spent before sending the first command


	SD_CS_ASSERT;
    3b58:	c1 98       	cbi	0x18, 1	; 24
    3b5a:	c0 e0       	ldi	r28, 0x00	; 0
    3b5c:	d0 e0       	ldi	r29, 0x00	; 0

	do
	{
  
		response = SD_sendCommand(GO_IDLE_STATE, 0); //send 'reset & go idle' command
    3b5e:	80 e0       	ldi	r24, 0x00	; 0
    3b60:	40 e0       	ldi	r20, 0x00	; 0
    3b62:	50 e0       	ldi	r21, 0x00	; 0
    3b64:	60 e0       	ldi	r22, 0x00	; 0
    3b66:	70 e0       	ldi	r23, 0x00	; 0
    3b68:	0e 94 84 1c 	call	0x3908	; 0x3908 <SD_sendCommand>
		retry++;
    3b6c:	21 96       	adiw	r28, 0x01	; 1
		if(retry>0x20) 
    3b6e:	c1 32       	cpi	r28, 0x21	; 33
    3b70:	d1 05       	cpc	r29, r1
    3b72:	11 f4       	brne	.+4      	; 0x3b78 <SD_init+0x34>
    3b74:	81 e0       	ldi	r24, 0x01	; 1
    3b76:	5c c0       	rjmp	.+184    	; 0x3c30 <SD_init+0xec>
		return 1;   //time out, card not detected
   
	} while(response != 0x01);
    3b78:	81 30       	cpi	r24, 0x01	; 1
    3b7a:	89 f7       	brne	.-30     	; 0x3b5e <SD_init+0x1a>


	SD_CS_DEASSERT;
    3b7c:	c1 9a       	sbi	0x18, 1	; 24

	SPI_transmit (0xff);
    3b7e:	8f ef       	ldi	r24, 0xFF	; 255
    3b80:	0e 94 20 1e 	call	0x3c40	; 0x3c40 <SPI_transmit>
	SPI_transmit (0xff);
    3b84:	8f ef       	ldi	r24, 0xFF	; 255
    3b86:	0e 94 20 1e 	call	0x3c40	; 0x3c40 <SPI_transmit>
    3b8a:	c0 e0       	ldi	r28, 0x00	; 0
    3b8c:	d0 e0       	ldi	r29, 0x00	; 0

	SD_version = 2; //default set to SD compliance with ver2.x; 
				//this may change after checking the next command
	do
	{
		response = SD_sendCommand(SEND_IF_COND,0x000001AA); //Check power supply status, mendatory for SDHC card
    3b8e:	88 e0       	ldi	r24, 0x08	; 8
    3b90:	4a ea       	ldi	r20, 0xAA	; 170
    3b92:	51 e0       	ldi	r21, 0x01	; 1
    3b94:	60 e0       	ldi	r22, 0x00	; 0
    3b96:	70 e0       	ldi	r23, 0x00	; 0
    3b98:	0e 94 84 1c 	call	0x3908	; 0x3908 <SD_sendCommand>
		retry++;
    3b9c:	21 96       	adiw	r28, 0x01	; 1
		if(retry>0xfe) 
    3b9e:	cf 3f       	cpi	r28, 0xFF	; 255
    3ba0:	d1 05       	cpc	r29, r1
    3ba2:	29 f4       	brne	.+10     	; 0x3bae <SD_init+0x6a>
		{
		//	TX_NEWLINE;
			SD_version = 1;
			cardType = 1;
    3ba4:	81 e0       	ldi	r24, 0x01	; 1
    3ba6:	80 93 84 03 	sts	0x0384, r24
    3baa:	11 e0       	ldi	r17, 0x01	; 1
    3bac:	03 c0       	rjmp	.+6      	; 0x3bb4 <SD_init+0x70>
			break;
		} //time out

	}while(response != 0x01);
    3bae:	81 30       	cpi	r24, 0x01	; 1
    3bb0:	71 f7       	brne	.-36     	; 0x3b8e <SD_init+0x4a>
    3bb2:	12 e0       	ldi	r17, 0x02	; 2
    3bb4:	c0 e0       	ldi	r28, 0x00	; 0
    3bb6:	d0 e0       	ldi	r29, 0x00	; 0

	retry = 0;

	do
	{
		response = SD_sendCommand(APP_CMD,0); //CMD55, must be sent before sending any ACMD command
    3bb8:	87 e3       	ldi	r24, 0x37	; 55
    3bba:	40 e0       	ldi	r20, 0x00	; 0
    3bbc:	50 e0       	ldi	r21, 0x00	; 0
    3bbe:	60 e0       	ldi	r22, 0x00	; 0
    3bc0:	70 e0       	ldi	r23, 0x00	; 0
    3bc2:	0e 94 84 1c 	call	0x3908	; 0x3908 <SD_sendCommand>
		response = SD_sendCommand(SD_SEND_OP_COND,0x40000000); //ACMD41
    3bc6:	89 e2       	ldi	r24, 0x29	; 41
    3bc8:	40 e0       	ldi	r20, 0x00	; 0
    3bca:	50 e0       	ldi	r21, 0x00	; 0
    3bcc:	60 e0       	ldi	r22, 0x00	; 0
    3bce:	70 e4       	ldi	r23, 0x40	; 64
    3bd0:	0e 94 84 1c 	call	0x3908	; 0x3908 <SD_sendCommand>

		retry++;
    3bd4:	21 96       	adiw	r28, 0x01	; 1
		if(retry>0xfe) 
    3bd6:	cf 3f       	cpi	r28, 0xFF	; 255
    3bd8:	d1 05       	cpc	r29, r1
    3bda:	11 f4       	brne	.+4      	; 0x3be0 <SD_init+0x9c>
    3bdc:	82 e0       	ldi	r24, 0x02	; 2
    3bde:	28 c0       	rjmp	.+80     	; 0x3c30 <SD_init+0xec>
		{
		//	TX_NEWLINE;
			return 2;  //time out, card initialization failed
		} 

	}while(response != 0x00);
    3be0:	88 23       	and	r24, r24
    3be2:	51 f7       	brne	.-44     	; 0x3bb8 <SD_init+0x74>


	retry = 0;
	SDHC_flag = 0;
    3be4:	10 92 79 03 	sts	0x0379, r1

	if (SD_version == 2)
    3be8:	12 30       	cpi	r17, 0x02	; 2
    3bea:	11 f5       	brne	.+68     	; 0x3c30 <SD_init+0xec>
    3bec:	c0 e0       	ldi	r28, 0x00	; 0
    3bee:	d0 e0       	ldi	r29, 0x00	; 0
	{ 
		do
		{
			response = SD_sendCommand(READ_OCR,0);
    3bf0:	8a e3       	ldi	r24, 0x3A	; 58
    3bf2:	40 e0       	ldi	r20, 0x00	; 0
    3bf4:	50 e0       	ldi	r21, 0x00	; 0
    3bf6:	60 e0       	ldi	r22, 0x00	; 0
    3bf8:	70 e0       	ldi	r23, 0x00	; 0
    3bfa:	0e 94 84 1c 	call	0x3908	; 0x3908 <SD_sendCommand>
			retry++;
    3bfe:	21 96       	adiw	r28, 0x01	; 1
			if(retry>0xfe) 
    3c00:	cf 3f       	cpi	r28, 0xFF	; 255
    3c02:	d1 05       	cpc	r29, r1
    3c04:	49 f4       	brne	.+18     	; 0x3c18 <SD_init+0xd4>
			{
				TX_NEWLINE;
    3c06:	8d e0       	ldi	r24, 0x0D	; 13
    3c08:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <transmitByte>
    3c0c:	8a e0       	ldi	r24, 0x0A	; 10
    3c0e:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <transmitByte>
				cardType = 0;
    3c12:	10 92 84 03 	sts	0x0384, r1
    3c16:	02 c0       	rjmp	.+4      	; 0x3c1c <SD_init+0xd8>
				break;
			} //time out

		}while(response != 0x00);
    3c18:	88 23       	and	r24, r24
    3c1a:	51 f7       	brne	.-44     	; 0x3bf0 <SD_init+0xac>

		if(SDHC_flag == 1) cardType = 2;
    3c1c:	80 91 79 03 	lds	r24, 0x0379
    3c20:	81 30       	cpi	r24, 0x01	; 1
    3c22:	11 f4       	brne	.+4      	; 0x3c28 <SD_init+0xe4>
    3c24:	82 e0       	ldi	r24, 0x02	; 2
    3c26:	01 c0       	rjmp	.+2      	; 0x3c2a <SD_init+0xe6>
		else cardType = 3;
    3c28:	83 e0       	ldi	r24, 0x03	; 3
    3c2a:	80 93 84 03 	sts	0x0384, r24
    3c2e:	80 e0       	ldi	r24, 0x00	; 0
	//SD_sendCommand(CRC_ON_OFF, OFF); //disable CRC; deafault - CRC disabled in SPI mode
	//SD_sendCommand(SET_BLOCK_LEN, 512); //set block size to 512; default size is 512


	return 0; //successful return
}
    3c30:	df 91       	pop	r29
    3c32:	cf 91       	pop	r28
    3c34:	1f 91       	pop	r17
    3c36:	08 95       	ret

00003c38 <init_spi>:

//SPI initialize for SD card

void init_spi(void)
{
	SPCR = 0x52; 	// Master mode,
    3c38:	82 e5       	ldi	r24, 0x52	; 82
    3c3a:	8d b9       	out	0x0d, r24	; 13
					// SPI enable
					// SPI mode 0
					// sck=fosc/64
	SPSR = 0x00;
    3c3c:	1e b8       	out	0x0e, r1	; 14
};
    3c3e:	08 95       	ret

00003c40 <SPI_transmit>:


unsigned char SPI_transmit(unsigned char data)
{
	// Start transmission
	SPDR = data;
    3c40:	8f b9       	out	0x0f, r24	; 15

	// Wait for transmission complete
	while(!(SPSR & (1<<SPIF)));
    3c42:	77 9b       	sbis	0x0e, 7	; 14
    3c44:	fe cf       	rjmp	.-4      	; 0x3c42 <SPI_transmit+0x2>
	data = SPDR;
    3c46:	8f b1       	in	r24, 0x0f	; 15

	return(data);
};
    3c48:	08 95       	ret

00003c4a <SPI_receive>:
unsigned char SPI_receive(void)
{
	unsigned char data;
	// Wait for reception complete

	SPDR = 0xff;
    3c4a:	8f ef       	ldi	r24, 0xFF	; 255
    3c4c:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1<<SPIF)));
    3c4e:	77 9b       	sbis	0x0e, 7	; 14
    3c50:	fe cf       	rjmp	.-4      	; 0x3c4e <SPI_receive+0x4>
	data = SPDR;
    3c52:	8f b1       	in	r24, 0x0f	; 15

	// Return data register
	return data;
}
    3c54:	08 95       	ret

00003c56 <xmit_uart>:

// UART transmit
int xmit_uart( char data, FILE *fd )
{
	/* Wait for empty transmit buffer */
	while ( !( UCSRA & (1<<UDRE)) );
    3c56:	5d 9b       	sbis	0x0b, 5	; 11
    3c58:	fe cf       	rjmp	.-4      	; 0x3c56 <xmit_uart>
	
	/* Put data into buffer, sends the data */
	UDR = data;
    3c5a:	8c b9       	out	0x0c, r24	; 12
	return 0;
};
    3c5c:	80 e0       	ldi	r24, 0x00	; 0
    3c5e:	90 e0       	ldi	r25, 0x00	; 0
    3c60:	08 95       	ret

00003c62 <rcv_uart>:
int rcv_uart( FILE *fp)
{
	/* Wait for data to be received */
	char c;

	while ( !(UCSRA & (1<<RXC)) );
    3c62:	5f 9b       	sbis	0x0b, 7	; 11
    3c64:	fe cf       	rjmp	.-4      	; 0x3c62 <rcv_uart>

	c = UDR;
    3c66:	8c b1       	in	r24, 0x0c	; 12

// UART transmit
int xmit_uart( char data, FILE *fd )
{
	/* Wait for empty transmit buffer */
	while ( !( UCSRA & (1<<UDRE)) );
    3c68:	5d 9b       	sbis	0x0b, 5	; 11
    3c6a:	fe cf       	rjmp	.-4      	; 0x3c68 <rcv_uart+0x6>
	
	/* Put data into buffer, sends the data */
	UDR = data;
    3c6c:	8c b9       	out	0x0c, r24	; 12
	//echo character
	xmit_uart(c,NULL);
	//printf("%c",c);

	/* Get and return received data from buffer */
	return UDR;
    3c6e:	8c b1       	in	r24, 0x0c	; 12
};
    3c70:	90 e0       	ldi	r25, 0x00	; 0
    3c72:	08 95       	ret

00003c74 <receiveByte>:
//*************************************************
unsigned char receiveByte( void )
{
	unsigned char data, status;
	
	while(!(UCSRA & (1<<RXC))); 	// Wait for incomming data
    3c74:	5f 9b       	sbis	0x0b, 7	; 11
    3c76:	fe cf       	rjmp	.-4      	; 0x3c74 <receiveByte>
	
	status = UCSRA;
    3c78:	8b b1       	in	r24, 0x0b	; 11
	data = UDR;
    3c7a:	8c b1       	in	r24, 0x0c	; 12
	
	return(data);
};
    3c7c:	08 95       	ret

00003c7e <transmitByte>:
//***************************************************
//Function to transmit a single byte
//***************************************************
void transmitByte( unsigned char data )
{
	while ( !(UCSRA & (1<<UDRE)) )
    3c7e:	5d 9b       	sbis	0x0b, 5	; 11
    3c80:	fe cf       	rjmp	.-4      	; 0x3c7e <transmitByte>
		; 			                /* Wait for empty transmit buffer */
	UDR = data; 			        /* Start transmition */
    3c82:	8c b9       	out	0x0c, r24	; 12
};
    3c84:	08 95       	ret

00003c86 <transmitString_F>:

//***************************************************
//Function to transmit a string in Flash
//***************************************************
void transmitString_F(char* string)
{
    3c86:	fc 01       	movw	r30, r24
    3c88:	04 c0       	rjmp	.+8      	; 0x3c92 <transmitString_F+0xc>
//***************************************************
//Function to transmit a single byte
//***************************************************
void transmitByte( unsigned char data )
{
	while ( !(UCSRA & (1<<UDRE)) )
    3c8a:	5d 9b       	sbis	0x0b, 5	; 11
    3c8c:	fe cf       	rjmp	.-4      	; 0x3c8a <transmitString_F+0x4>
//Function to transmit a string in Flash
//***************************************************
void transmitString_F(char* string)
{
  while (pgm_read_byte(&(*string)))
   transmitByte(pgm_read_byte(&(*string++)));
    3c8e:	31 96       	adiw	r30, 0x01	; 1
//***************************************************
void transmitByte( unsigned char data )
{
	while ( !(UCSRA & (1<<UDRE)) )
		; 			                /* Wait for empty transmit buffer */
	UDR = data; 			        /* Start transmition */
    3c90:	8c b9       	out	0x0c, r24	; 12
//***************************************************
//Function to transmit a string in Flash
//***************************************************
void transmitString_F(char* string)
{
  while (pgm_read_byte(&(*string)))
    3c92:	84 91       	lpm	r24, Z+
    3c94:	88 23       	and	r24, r24
    3c96:	c9 f7       	brne	.-14     	; 0x3c8a <transmitString_F+0x4>
   transmitByte(pgm_read_byte(&(*string++)));
}
    3c98:	08 95       	ret

00003c9a <transmitString>:

//***************************************************
//Function to transmit a string in RAM
//***************************************************
void transmitString(unsigned char* string)
{
    3c9a:	fc 01       	movw	r30, r24
    3c9c:	04 c0       	rjmp	.+8      	; 0x3ca6 <transmitString+0xc>
//***************************************************
//Function to transmit a single byte
//***************************************************
void transmitByte( unsigned char data )
{
	while ( !(UCSRA & (1<<UDRE)) )
    3c9e:	5d 9b       	sbis	0x0b, 5	; 11
    3ca0:	fe cf       	rjmp	.-4      	; 0x3c9e <transmitString+0x4>
//Function to transmit a string in RAM
//***************************************************
void transmitString(unsigned char* string)
{
  while (*string)
   transmitByte(*string++);
    3ca2:	31 96       	adiw	r30, 0x01	; 1
//***************************************************
void transmitByte( unsigned char data )
{
	while ( !(UCSRA & (1<<UDRE)) )
		; 			                /* Wait for empty transmit buffer */
	UDR = data; 			        /* Start transmition */
    3ca4:	8c b9       	out	0x0c, r24	; 12
//***************************************************
//Function to transmit a string in RAM
//***************************************************
void transmitString(unsigned char* string)
{
  while (*string)
    3ca6:	80 81       	ld	r24, Z
    3ca8:	88 23       	and	r24, r24
    3caa:	c9 f7       	brne	.-14     	; 0x3c9e <transmitString+0x4>
   transmitByte(*string++);
}
    3cac:	08 95       	ret

00003cae <transmitHex>:
//Function to transmit hex format data
//first argument indicates type: CHAR, INT or LONG
//Second argument is the data to be displayed
//***************************************************
void transmitHex( unsigned char dataType, unsigned long data )
{
    3cae:	df 93       	push	r29
    3cb0:	cf 93       	push	r28
    3cb2:	cd b7       	in	r28, 0x3d	; 61
    3cb4:	de b7       	in	r29, 0x3e	; 62
    3cb6:	2b 97       	sbiw	r28, 0x0b	; 11
    3cb8:	0f b6       	in	r0, 0x3f	; 63
    3cba:	f8 94       	cli
    3cbc:	de bf       	out	0x3e, r29	; 62
    3cbe:	0f be       	out	0x3f, r0	; 63
    3cc0:	cd bf       	out	0x3d, r28	; 61
unsigned char count, i, temp;
unsigned char dataString[] = "0x        ";

if (dataType == CHAR) count = 2;
if (dataType == INT) count = 4;
    3cc2:	81 30       	cpi	r24, 0x01	; 1
    3cc4:	11 f4       	brne	.+4      	; 0x3cca <transmitHex+0x1c>
    3cc6:	94 e0       	ldi	r25, 0x04	; 4
    3cc8:	05 c0       	rjmp	.+10     	; 0x3cd4 <transmitHex+0x26>
if (dataType == LONG) count = 8;
    3cca:	82 30       	cpi	r24, 0x02	; 2
    3ccc:	11 f4       	brne	.+4      	; 0x3cd2 <transmitHex+0x24>
    3cce:	98 e0       	ldi	r25, 0x08	; 8
    3cd0:	01 c0       	rjmp	.+2      	; 0x3cd4 <transmitHex+0x26>
    3cd2:	92 e0       	ldi	r25, 0x02	; 2
//Second argument is the data to be displayed
//***************************************************
void transmitHex( unsigned char dataType, unsigned long data )
{
unsigned char count, i, temp;
unsigned char dataString[] = "0x        ";
    3cd4:	de 01       	movw	r26, r28
    3cd6:	11 96       	adiw	r26, 0x01	; 1
    3cd8:	e6 e4       	ldi	r30, 0x46	; 70
    3cda:	f1 e0       	ldi	r31, 0x01	; 1
    3cdc:	8b e0       	ldi	r24, 0x0B	; 11
    3cde:	01 90       	ld	r0, Z+
    3ce0:	0d 92       	st	X+, r0
    3ce2:	81 50       	subi	r24, 0x01	; 1
    3ce4:	e1 f7       	brne	.-8      	; 0x3cde <transmitHex+0x30>
    3ce6:	9e 01       	movw	r18, r28
    3ce8:	2e 5f       	subi	r18, 0xFE	; 254
    3cea:	3f 4f       	sbci	r19, 0xFF	; 255
if (dataType == INT) count = 4;
if (dataType == LONG) count = 8;

for(i=count; i>0; i--)
{
  temp = data % 16;
    3cec:	84 2f       	mov	r24, r20
    3cee:	8f 70       	andi	r24, 0x0F	; 15
    3cf0:	e9 2f       	mov	r30, r25
    3cf2:	f0 e0       	ldi	r31, 0x00	; 0
  if((temp>=0) && (temp<10)) dataString [i+1] = temp + 0x30;
    3cf4:	8a 30       	cpi	r24, 0x0A	; 10
    3cf6:	20 f4       	brcc	.+8      	; 0x3d00 <transmitHex+0x52>
    3cf8:	e2 0f       	add	r30, r18
    3cfa:	f3 1f       	adc	r31, r19
    3cfc:	80 5d       	subi	r24, 0xD0	; 208
    3cfe:	03 c0       	rjmp	.+6      	; 0x3d06 <transmitHex+0x58>
  else dataString [i+1] = (temp - 10) + 0x41;
    3d00:	e2 0f       	add	r30, r18
    3d02:	f3 1f       	adc	r31, r19
    3d04:	89 5c       	subi	r24, 0xC9	; 201
    3d06:	80 83       	st	Z, r24

if (dataType == CHAR) count = 2;
if (dataType == INT) count = 4;
if (dataType == LONG) count = 8;

for(i=count; i>0; i--)
    3d08:	91 50       	subi	r25, 0x01	; 1
    3d0a:	41 f0       	breq	.+16     	; 0x3d1c <transmitHex+0x6e>
{
  temp = data % 16;
  if((temp>=0) && (temp<10)) dataString [i+1] = temp + 0x30;
  else dataString [i+1] = (temp - 10) + 0x41;

  data = data/16;
    3d0c:	84 e0       	ldi	r24, 0x04	; 4
    3d0e:	76 95       	lsr	r23
    3d10:	67 95       	ror	r22
    3d12:	57 95       	ror	r21
    3d14:	47 95       	ror	r20
    3d16:	8a 95       	dec	r24
    3d18:	d1 f7       	brne	.-12     	; 0x3d0e <transmitHex+0x60>
    3d1a:	e8 cf       	rjmp	.-48     	; 0x3cec <transmitHex+0x3e>
}

transmitString (dataString);
    3d1c:	ce 01       	movw	r24, r28
    3d1e:	01 96       	adiw	r24, 0x01	; 1
    3d20:	0e 94 4d 1e 	call	0x3c9a	; 0x3c9a <transmitString>
}
    3d24:	2b 96       	adiw	r28, 0x0b	; 11
    3d26:	0f b6       	in	r0, 0x3f	; 63
    3d28:	f8 94       	cli
    3d2a:	de bf       	out	0x3e, r29	; 62
    3d2c:	0f be       	out	0x3f, r0	; 63
    3d2e:	cd bf       	out	0x3d, r28	; 61
    3d30:	cf 91       	pop	r28
    3d32:	df 91       	pop	r29
    3d34:	08 95       	ret

00003d36 <init_uart>:
void init_uart()
{
	

	/* Set baud rate */
	UBRRH = (unsigned char)(val_load>>8);
    3d36:	10 bc       	out	0x20, r1	; 32
	UBRRL = (unsigned char)val_load;
    3d38:	8d e4       	ldi	r24, 0x4D	; 77
    3d3a:	89 b9       	out	0x09, r24	; 9


	/* Enable receiver and transmitter */
	UCSRB = (1<<RXEN)|(1<<TXEN);
    3d3c:	88 e1       	ldi	r24, 0x18	; 24
    3d3e:	8a b9       	out	0x0a, r24	; 10

	/* Set frame format: 8data, 2 stop bit */
	UCSRC = (1<<URSEL)|(1<<USBS)|(3<<UCSZ0);
    3d40:	8e e8       	ldi	r24, 0x8E	; 142
    3d42:	80 bd       	out	0x20, r24	; 32


	#ifdef EN_UART_IOF

	// Enable printf()/scanf() call-back
	  fdevopen(&xmit_uart, &rcv_uart);
    3d44:	8b e2       	ldi	r24, 0x2B	; 43
    3d46:	9e e1       	ldi	r25, 0x1E	; 30
    3d48:	61 e3       	ldi	r22, 0x31	; 49
    3d4a:	7e e1       	ldi	r23, 0x1E	; 30
    3d4c:	0e 94 ed 1e 	call	0x3dda	; 0x3dda <fdevopen>

	#endif   

	//Enable the interrupts globally. 
  	SREG |= _BV(SREG_I); 
    3d50:	8f b7       	in	r24, 0x3f	; 63
    3d52:	80 68       	ori	r24, 0x80	; 128
    3d54:	8f bf       	out	0x3f, r24	; 63


};
    3d56:	08 95       	ret

00003d58 <__mulsi3>:
    3d58:	62 9f       	mul	r22, r18
    3d5a:	d0 01       	movw	r26, r0
    3d5c:	73 9f       	mul	r23, r19
    3d5e:	f0 01       	movw	r30, r0
    3d60:	82 9f       	mul	r24, r18
    3d62:	e0 0d       	add	r30, r0
    3d64:	f1 1d       	adc	r31, r1
    3d66:	64 9f       	mul	r22, r20
    3d68:	e0 0d       	add	r30, r0
    3d6a:	f1 1d       	adc	r31, r1
    3d6c:	92 9f       	mul	r25, r18
    3d6e:	f0 0d       	add	r31, r0
    3d70:	83 9f       	mul	r24, r19
    3d72:	f0 0d       	add	r31, r0
    3d74:	74 9f       	mul	r23, r20
    3d76:	f0 0d       	add	r31, r0
    3d78:	65 9f       	mul	r22, r21
    3d7a:	f0 0d       	add	r31, r0
    3d7c:	99 27       	eor	r25, r25
    3d7e:	72 9f       	mul	r23, r18
    3d80:	b0 0d       	add	r27, r0
    3d82:	e1 1d       	adc	r30, r1
    3d84:	f9 1f       	adc	r31, r25
    3d86:	63 9f       	mul	r22, r19
    3d88:	b0 0d       	add	r27, r0
    3d8a:	e1 1d       	adc	r30, r1
    3d8c:	f9 1f       	adc	r31, r25
    3d8e:	bd 01       	movw	r22, r26
    3d90:	cf 01       	movw	r24, r30
    3d92:	11 24       	eor	r1, r1
    3d94:	08 95       	ret

00003d96 <__udivmodsi4>:
    3d96:	a1 e2       	ldi	r26, 0x21	; 33
    3d98:	1a 2e       	mov	r1, r26
    3d9a:	aa 1b       	sub	r26, r26
    3d9c:	bb 1b       	sub	r27, r27
    3d9e:	fd 01       	movw	r30, r26
    3da0:	0d c0       	rjmp	.+26     	; 0x3dbc <__udivmodsi4_ep>

00003da2 <__udivmodsi4_loop>:
    3da2:	aa 1f       	adc	r26, r26
    3da4:	bb 1f       	adc	r27, r27
    3da6:	ee 1f       	adc	r30, r30
    3da8:	ff 1f       	adc	r31, r31
    3daa:	a2 17       	cp	r26, r18
    3dac:	b3 07       	cpc	r27, r19
    3dae:	e4 07       	cpc	r30, r20
    3db0:	f5 07       	cpc	r31, r21
    3db2:	20 f0       	brcs	.+8      	; 0x3dbc <__udivmodsi4_ep>
    3db4:	a2 1b       	sub	r26, r18
    3db6:	b3 0b       	sbc	r27, r19
    3db8:	e4 0b       	sbc	r30, r20
    3dba:	f5 0b       	sbc	r31, r21

00003dbc <__udivmodsi4_ep>:
    3dbc:	66 1f       	adc	r22, r22
    3dbe:	77 1f       	adc	r23, r23
    3dc0:	88 1f       	adc	r24, r24
    3dc2:	99 1f       	adc	r25, r25
    3dc4:	1a 94       	dec	r1
    3dc6:	69 f7       	brne	.-38     	; 0x3da2 <__udivmodsi4_loop>
    3dc8:	60 95       	com	r22
    3dca:	70 95       	com	r23
    3dcc:	80 95       	com	r24
    3dce:	90 95       	com	r25
    3dd0:	9b 01       	movw	r18, r22
    3dd2:	ac 01       	movw	r20, r24
    3dd4:	bd 01       	movw	r22, r26
    3dd6:	cf 01       	movw	r24, r30
    3dd8:	08 95       	ret

00003dda <fdevopen>:
    3dda:	0f 93       	push	r16
    3ddc:	1f 93       	push	r17
    3dde:	cf 93       	push	r28
    3de0:	df 93       	push	r29
    3de2:	8c 01       	movw	r16, r24
    3de4:	eb 01       	movw	r28, r22
    3de6:	00 97       	sbiw	r24, 0x00	; 0
    3de8:	31 f4       	brne	.+12     	; 0x3df6 <fdevopen+0x1c>
    3dea:	61 15       	cp	r22, r1
    3dec:	71 05       	cpc	r23, r1
    3dee:	19 f4       	brne	.+6      	; 0x3df6 <fdevopen+0x1c>
    3df0:	20 e0       	ldi	r18, 0x00	; 0
    3df2:	30 e0       	ldi	r19, 0x00	; 0
    3df4:	38 c0       	rjmp	.+112    	; 0x3e66 <fdevopen+0x8c>
    3df6:	81 e0       	ldi	r24, 0x01	; 1
    3df8:	90 e0       	ldi	r25, 0x00	; 0
    3dfa:	6e e0       	ldi	r22, 0x0E	; 14
    3dfc:	70 e0       	ldi	r23, 0x00	; 0
    3dfe:	0e 94 39 1f 	call	0x3e72	; 0x3e72 <calloc>
    3e02:	fc 01       	movw	r30, r24
    3e04:	9c 01       	movw	r18, r24
    3e06:	00 97       	sbiw	r24, 0x00	; 0
    3e08:	71 f1       	breq	.+92     	; 0x3e66 <fdevopen+0x8c>
    3e0a:	80 e8       	ldi	r24, 0x80	; 128
    3e0c:	83 83       	std	Z+3, r24	; 0x03
    3e0e:	20 97       	sbiw	r28, 0x00	; 0
    3e10:	71 f0       	breq	.+28     	; 0x3e2e <fdevopen+0x54>
    3e12:	d3 87       	std	Z+11, r29	; 0x0b
    3e14:	c2 87       	std	Z+10, r28	; 0x0a
    3e16:	81 e8       	ldi	r24, 0x81	; 129
    3e18:	83 83       	std	Z+3, r24	; 0x03
    3e1a:	80 91 a0 03 	lds	r24, 0x03A0
    3e1e:	90 91 a1 03 	lds	r25, 0x03A1
    3e22:	89 2b       	or	r24, r25
    3e24:	21 f4       	brne	.+8      	; 0x3e2e <fdevopen+0x54>
    3e26:	f0 93 a1 03 	sts	0x03A1, r31
    3e2a:	e0 93 a0 03 	sts	0x03A0, r30
    3e2e:	01 15       	cp	r16, r1
    3e30:	11 05       	cpc	r17, r1
    3e32:	c9 f0       	breq	.+50     	; 0x3e66 <fdevopen+0x8c>
    3e34:	11 87       	std	Z+9, r17	; 0x09
    3e36:	00 87       	std	Z+8, r16	; 0x08
    3e38:	83 81       	ldd	r24, Z+3	; 0x03
    3e3a:	82 60       	ori	r24, 0x02	; 2
    3e3c:	83 83       	std	Z+3, r24	; 0x03
    3e3e:	80 91 a2 03 	lds	r24, 0x03A2
    3e42:	90 91 a3 03 	lds	r25, 0x03A3
    3e46:	89 2b       	or	r24, r25
    3e48:	71 f4       	brne	.+28     	; 0x3e66 <fdevopen+0x8c>
    3e4a:	f0 93 a3 03 	sts	0x03A3, r31
    3e4e:	e0 93 a2 03 	sts	0x03A2, r30
    3e52:	80 91 a4 03 	lds	r24, 0x03A4
    3e56:	90 91 a5 03 	lds	r25, 0x03A5
    3e5a:	89 2b       	or	r24, r25
    3e5c:	21 f4       	brne	.+8      	; 0x3e66 <fdevopen+0x8c>
    3e5e:	f0 93 a5 03 	sts	0x03A5, r31
    3e62:	e0 93 a4 03 	sts	0x03A4, r30
    3e66:	c9 01       	movw	r24, r18
    3e68:	df 91       	pop	r29
    3e6a:	cf 91       	pop	r28
    3e6c:	1f 91       	pop	r17
    3e6e:	0f 91       	pop	r16
    3e70:	08 95       	ret

00003e72 <calloc>:
    3e72:	0f 93       	push	r16
    3e74:	1f 93       	push	r17
    3e76:	cf 93       	push	r28
    3e78:	df 93       	push	r29
    3e7a:	68 9f       	mul	r22, r24
    3e7c:	80 01       	movw	r16, r0
    3e7e:	69 9f       	mul	r22, r25
    3e80:	10 0d       	add	r17, r0
    3e82:	78 9f       	mul	r23, r24
    3e84:	10 0d       	add	r17, r0
    3e86:	11 24       	eor	r1, r1
    3e88:	c8 01       	movw	r24, r16
    3e8a:	0e 94 55 1f 	call	0x3eaa	; 0x3eaa <malloc>
    3e8e:	ec 01       	movw	r28, r24
    3e90:	00 97       	sbiw	r24, 0x00	; 0
    3e92:	29 f0       	breq	.+10     	; 0x3e9e <calloc+0x2c>
    3e94:	60 e0       	ldi	r22, 0x00	; 0
    3e96:	70 e0       	ldi	r23, 0x00	; 0
    3e98:	a8 01       	movw	r20, r16
    3e9a:	0e 94 5a 20 	call	0x40b4	; 0x40b4 <memset>
    3e9e:	ce 01       	movw	r24, r28
    3ea0:	df 91       	pop	r29
    3ea2:	cf 91       	pop	r28
    3ea4:	1f 91       	pop	r17
    3ea6:	0f 91       	pop	r16
    3ea8:	08 95       	ret

00003eaa <malloc>:
    3eaa:	cf 93       	push	r28
    3eac:	df 93       	push	r29
    3eae:	bc 01       	movw	r22, r24
    3eb0:	82 30       	cpi	r24, 0x02	; 2
    3eb2:	91 05       	cpc	r25, r1
    3eb4:	10 f4       	brcc	.+4      	; 0x3eba <malloc+0x10>
    3eb6:	62 e0       	ldi	r22, 0x02	; 2
    3eb8:	70 e0       	ldi	r23, 0x00	; 0
    3eba:	a0 91 a8 03 	lds	r26, 0x03A8
    3ebe:	b0 91 a9 03 	lds	r27, 0x03A9
    3ec2:	ed 01       	movw	r28, r26
    3ec4:	e0 e0       	ldi	r30, 0x00	; 0
    3ec6:	f0 e0       	ldi	r31, 0x00	; 0
    3ec8:	40 e0       	ldi	r20, 0x00	; 0
    3eca:	50 e0       	ldi	r21, 0x00	; 0
    3ecc:	21 c0       	rjmp	.+66     	; 0x3f10 <malloc+0x66>
    3ece:	88 81       	ld	r24, Y
    3ed0:	99 81       	ldd	r25, Y+1	; 0x01
    3ed2:	86 17       	cp	r24, r22
    3ed4:	97 07       	cpc	r25, r23
    3ed6:	69 f4       	brne	.+26     	; 0x3ef2 <malloc+0x48>
    3ed8:	8a 81       	ldd	r24, Y+2	; 0x02
    3eda:	9b 81       	ldd	r25, Y+3	; 0x03
    3edc:	30 97       	sbiw	r30, 0x00	; 0
    3ede:	19 f0       	breq	.+6      	; 0x3ee6 <malloc+0x3c>
    3ee0:	93 83       	std	Z+3, r25	; 0x03
    3ee2:	82 83       	std	Z+2, r24	; 0x02
    3ee4:	04 c0       	rjmp	.+8      	; 0x3eee <malloc+0x44>
    3ee6:	90 93 a9 03 	sts	0x03A9, r25
    3eea:	80 93 a8 03 	sts	0x03A8, r24
    3eee:	fe 01       	movw	r30, r28
    3ef0:	34 c0       	rjmp	.+104    	; 0x3f5a <malloc+0xb0>
    3ef2:	68 17       	cp	r22, r24
    3ef4:	79 07       	cpc	r23, r25
    3ef6:	38 f4       	brcc	.+14     	; 0x3f06 <malloc+0x5c>
    3ef8:	41 15       	cp	r20, r1
    3efa:	51 05       	cpc	r21, r1
    3efc:	19 f0       	breq	.+6      	; 0x3f04 <malloc+0x5a>
    3efe:	84 17       	cp	r24, r20
    3f00:	95 07       	cpc	r25, r21
    3f02:	08 f4       	brcc	.+2      	; 0x3f06 <malloc+0x5c>
    3f04:	ac 01       	movw	r20, r24
    3f06:	fe 01       	movw	r30, r28
    3f08:	8a 81       	ldd	r24, Y+2	; 0x02
    3f0a:	9b 81       	ldd	r25, Y+3	; 0x03
    3f0c:	9c 01       	movw	r18, r24
    3f0e:	e9 01       	movw	r28, r18
    3f10:	20 97       	sbiw	r28, 0x00	; 0
    3f12:	e9 f6       	brne	.-70     	; 0x3ece <malloc+0x24>
    3f14:	41 15       	cp	r20, r1
    3f16:	51 05       	cpc	r21, r1
    3f18:	a9 f1       	breq	.+106    	; 0x3f84 <malloc+0xda>
    3f1a:	ca 01       	movw	r24, r20
    3f1c:	86 1b       	sub	r24, r22
    3f1e:	97 0b       	sbc	r25, r23
    3f20:	04 97       	sbiw	r24, 0x04	; 4
    3f22:	08 f4       	brcc	.+2      	; 0x3f26 <malloc+0x7c>
    3f24:	ba 01       	movw	r22, r20
    3f26:	e0 e0       	ldi	r30, 0x00	; 0
    3f28:	f0 e0       	ldi	r31, 0x00	; 0
    3f2a:	2a c0       	rjmp	.+84     	; 0x3f80 <malloc+0xd6>
    3f2c:	8d 91       	ld	r24, X+
    3f2e:	9c 91       	ld	r25, X
    3f30:	11 97       	sbiw	r26, 0x01	; 1
    3f32:	84 17       	cp	r24, r20
    3f34:	95 07       	cpc	r25, r21
    3f36:	f9 f4       	brne	.+62     	; 0x3f76 <malloc+0xcc>
    3f38:	64 17       	cp	r22, r20
    3f3a:	75 07       	cpc	r23, r21
    3f3c:	81 f4       	brne	.+32     	; 0x3f5e <malloc+0xb4>
    3f3e:	12 96       	adiw	r26, 0x02	; 2
    3f40:	8d 91       	ld	r24, X+
    3f42:	9c 91       	ld	r25, X
    3f44:	13 97       	sbiw	r26, 0x03	; 3
    3f46:	30 97       	sbiw	r30, 0x00	; 0
    3f48:	19 f0       	breq	.+6      	; 0x3f50 <malloc+0xa6>
    3f4a:	93 83       	std	Z+3, r25	; 0x03
    3f4c:	82 83       	std	Z+2, r24	; 0x02
    3f4e:	04 c0       	rjmp	.+8      	; 0x3f58 <malloc+0xae>
    3f50:	90 93 a9 03 	sts	0x03A9, r25
    3f54:	80 93 a8 03 	sts	0x03A8, r24
    3f58:	fd 01       	movw	r30, r26
    3f5a:	32 96       	adiw	r30, 0x02	; 2
    3f5c:	4f c0       	rjmp	.+158    	; 0x3ffc <malloc+0x152>
    3f5e:	ca 01       	movw	r24, r20
    3f60:	86 1b       	sub	r24, r22
    3f62:	97 0b       	sbc	r25, r23
    3f64:	fd 01       	movw	r30, r26
    3f66:	e8 0f       	add	r30, r24
    3f68:	f9 1f       	adc	r31, r25
    3f6a:	61 93       	st	Z+, r22
    3f6c:	71 93       	st	Z+, r23
    3f6e:	02 97       	sbiw	r24, 0x02	; 2
    3f70:	8d 93       	st	X+, r24
    3f72:	9c 93       	st	X, r25
    3f74:	43 c0       	rjmp	.+134    	; 0x3ffc <malloc+0x152>
    3f76:	fd 01       	movw	r30, r26
    3f78:	82 81       	ldd	r24, Z+2	; 0x02
    3f7a:	93 81       	ldd	r25, Z+3	; 0x03
    3f7c:	9c 01       	movw	r18, r24
    3f7e:	d9 01       	movw	r26, r18
    3f80:	10 97       	sbiw	r26, 0x00	; 0
    3f82:	a1 f6       	brne	.-88     	; 0x3f2c <malloc+0x82>
    3f84:	80 91 a6 03 	lds	r24, 0x03A6
    3f88:	90 91 a7 03 	lds	r25, 0x03A7
    3f8c:	89 2b       	or	r24, r25
    3f8e:	41 f4       	brne	.+16     	; 0x3fa0 <malloc+0xf6>
    3f90:	80 91 53 01 	lds	r24, 0x0153
    3f94:	90 91 54 01 	lds	r25, 0x0154
    3f98:	90 93 a7 03 	sts	0x03A7, r25
    3f9c:	80 93 a6 03 	sts	0x03A6, r24
    3fa0:	40 91 55 01 	lds	r20, 0x0155
    3fa4:	50 91 56 01 	lds	r21, 0x0156
    3fa8:	41 15       	cp	r20, r1
    3faa:	51 05       	cpc	r21, r1
    3fac:	41 f4       	brne	.+16     	; 0x3fbe <malloc+0x114>
    3fae:	4d b7       	in	r20, 0x3d	; 61
    3fb0:	5e b7       	in	r21, 0x3e	; 62
    3fb2:	80 91 51 01 	lds	r24, 0x0151
    3fb6:	90 91 52 01 	lds	r25, 0x0152
    3fba:	48 1b       	sub	r20, r24
    3fbc:	59 0b       	sbc	r21, r25
    3fbe:	20 91 a6 03 	lds	r18, 0x03A6
    3fc2:	30 91 a7 03 	lds	r19, 0x03A7
    3fc6:	24 17       	cp	r18, r20
    3fc8:	35 07       	cpc	r19, r21
    3fca:	b0 f4       	brcc	.+44     	; 0x3ff8 <malloc+0x14e>
    3fcc:	ca 01       	movw	r24, r20
    3fce:	82 1b       	sub	r24, r18
    3fd0:	93 0b       	sbc	r25, r19
    3fd2:	86 17       	cp	r24, r22
    3fd4:	97 07       	cpc	r25, r23
    3fd6:	80 f0       	brcs	.+32     	; 0x3ff8 <malloc+0x14e>
    3fd8:	ab 01       	movw	r20, r22
    3fda:	4e 5f       	subi	r20, 0xFE	; 254
    3fdc:	5f 4f       	sbci	r21, 0xFF	; 255
    3fde:	84 17       	cp	r24, r20
    3fe0:	95 07       	cpc	r25, r21
    3fe2:	50 f0       	brcs	.+20     	; 0x3ff8 <malloc+0x14e>
    3fe4:	42 0f       	add	r20, r18
    3fe6:	53 1f       	adc	r21, r19
    3fe8:	50 93 a7 03 	sts	0x03A7, r21
    3fec:	40 93 a6 03 	sts	0x03A6, r20
    3ff0:	f9 01       	movw	r30, r18
    3ff2:	61 93       	st	Z+, r22
    3ff4:	71 93       	st	Z+, r23
    3ff6:	02 c0       	rjmp	.+4      	; 0x3ffc <malloc+0x152>
    3ff8:	e0 e0       	ldi	r30, 0x00	; 0
    3ffa:	f0 e0       	ldi	r31, 0x00	; 0
    3ffc:	cf 01       	movw	r24, r30
    3ffe:	df 91       	pop	r29
    4000:	cf 91       	pop	r28
    4002:	08 95       	ret

00004004 <free>:
    4004:	cf 93       	push	r28
    4006:	df 93       	push	r29
    4008:	00 97       	sbiw	r24, 0x00	; 0
    400a:	09 f4       	brne	.+2      	; 0x400e <free+0xa>
    400c:	50 c0       	rjmp	.+160    	; 0x40ae <free+0xaa>
    400e:	ec 01       	movw	r28, r24
    4010:	22 97       	sbiw	r28, 0x02	; 2
    4012:	1b 82       	std	Y+3, r1	; 0x03
    4014:	1a 82       	std	Y+2, r1	; 0x02
    4016:	a0 91 a8 03 	lds	r26, 0x03A8
    401a:	b0 91 a9 03 	lds	r27, 0x03A9
    401e:	10 97       	sbiw	r26, 0x00	; 0
    4020:	09 f1       	breq	.+66     	; 0x4064 <free+0x60>
    4022:	40 e0       	ldi	r20, 0x00	; 0
    4024:	50 e0       	ldi	r21, 0x00	; 0
    4026:	ac 17       	cp	r26, r28
    4028:	bd 07       	cpc	r27, r29
    402a:	08 f1       	brcs	.+66     	; 0x406e <free+0x6a>
    402c:	bb 83       	std	Y+3, r27	; 0x03
    402e:	aa 83       	std	Y+2, r26	; 0x02
    4030:	fe 01       	movw	r30, r28
    4032:	21 91       	ld	r18, Z+
    4034:	31 91       	ld	r19, Z+
    4036:	e2 0f       	add	r30, r18
    4038:	f3 1f       	adc	r31, r19
    403a:	ae 17       	cp	r26, r30
    403c:	bf 07       	cpc	r27, r31
    403e:	79 f4       	brne	.+30     	; 0x405e <free+0x5a>
    4040:	8d 91       	ld	r24, X+
    4042:	9c 91       	ld	r25, X
    4044:	11 97       	sbiw	r26, 0x01	; 1
    4046:	28 0f       	add	r18, r24
    4048:	39 1f       	adc	r19, r25
    404a:	2e 5f       	subi	r18, 0xFE	; 254
    404c:	3f 4f       	sbci	r19, 0xFF	; 255
    404e:	39 83       	std	Y+1, r19	; 0x01
    4050:	28 83       	st	Y, r18
    4052:	12 96       	adiw	r26, 0x02	; 2
    4054:	8d 91       	ld	r24, X+
    4056:	9c 91       	ld	r25, X
    4058:	13 97       	sbiw	r26, 0x03	; 3
    405a:	9b 83       	std	Y+3, r25	; 0x03
    405c:	8a 83       	std	Y+2, r24	; 0x02
    405e:	41 15       	cp	r20, r1
    4060:	51 05       	cpc	r21, r1
    4062:	71 f4       	brne	.+28     	; 0x4080 <free+0x7c>
    4064:	d0 93 a9 03 	sts	0x03A9, r29
    4068:	c0 93 a8 03 	sts	0x03A8, r28
    406c:	20 c0       	rjmp	.+64     	; 0x40ae <free+0xaa>
    406e:	12 96       	adiw	r26, 0x02	; 2
    4070:	8d 91       	ld	r24, X+
    4072:	9c 91       	ld	r25, X
    4074:	13 97       	sbiw	r26, 0x03	; 3
    4076:	ad 01       	movw	r20, r26
    4078:	00 97       	sbiw	r24, 0x00	; 0
    407a:	11 f0       	breq	.+4      	; 0x4080 <free+0x7c>
    407c:	dc 01       	movw	r26, r24
    407e:	d3 cf       	rjmp	.-90     	; 0x4026 <free+0x22>
    4080:	fa 01       	movw	r30, r20
    4082:	d3 83       	std	Z+3, r29	; 0x03
    4084:	c2 83       	std	Z+2, r28	; 0x02
    4086:	21 91       	ld	r18, Z+
    4088:	31 91       	ld	r19, Z+
    408a:	e2 0f       	add	r30, r18
    408c:	f3 1f       	adc	r31, r19
    408e:	ce 17       	cp	r28, r30
    4090:	df 07       	cpc	r29, r31
    4092:	69 f4       	brne	.+26     	; 0x40ae <free+0xaa>
    4094:	88 81       	ld	r24, Y
    4096:	99 81       	ldd	r25, Y+1	; 0x01
    4098:	28 0f       	add	r18, r24
    409a:	39 1f       	adc	r19, r25
    409c:	2e 5f       	subi	r18, 0xFE	; 254
    409e:	3f 4f       	sbci	r19, 0xFF	; 255
    40a0:	fa 01       	movw	r30, r20
    40a2:	31 83       	std	Z+1, r19	; 0x01
    40a4:	20 83       	st	Z, r18
    40a6:	8a 81       	ldd	r24, Y+2	; 0x02
    40a8:	9b 81       	ldd	r25, Y+3	; 0x03
    40aa:	93 83       	std	Z+3, r25	; 0x03
    40ac:	82 83       	std	Z+2, r24	; 0x02
    40ae:	df 91       	pop	r29
    40b0:	cf 91       	pop	r28
    40b2:	08 95       	ret

000040b4 <memset>:
    40b4:	dc 01       	movw	r26, r24
    40b6:	01 c0       	rjmp	.+2      	; 0x40ba <memset+0x6>
    40b8:	6d 93       	st	X+, r22
    40ba:	41 50       	subi	r20, 0x01	; 1
    40bc:	50 40       	sbci	r21, 0x00	; 0
    40be:	e0 f7       	brcc	.-8      	; 0x40b8 <memset+0x4>
    40c0:	08 95       	ret

000040c2 <_exit>:
    40c2:	f8 94       	cli

000040c4 <__stop_program>:
    40c4:	ff cf       	rjmp	.-2      	; 0x40c4 <__stop_program>
